/*
Deployment script for ETL_Staging

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "ETL_Staging"
:setvar DefaultFilePrefix "ETL_Staging"
:setvar DefaultDataPath "C:\Program Files\Microsoft SQL Server\MSSQL13.MSSQLSERVER\MSSQL\DATA\"
:setvar DefaultLogPath "C:\Program Files\Microsoft SQL Server\MSSQL13.MSSQLSERVER\MSSQL\DATA\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [master];


GO

IF (DB_ID(N'$(DatabaseName)') IS NOT NULL) 
BEGIN
    ALTER DATABASE [$(DatabaseName)]
    SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
    DROP DATABASE [$(DatabaseName)];
END

GO
PRINT N'Creating $(DatabaseName)...'
GO
CREATE DATABASE [$(DatabaseName)]
    ON 
    PRIMARY(NAME = [$(DatabaseName)], FILENAME = N'$(DefaultDataPath)$(DefaultFilePrefix)_Primary.mdf')
    LOG ON (NAME = [$(DatabaseName)_log], FILENAME = N'$(DefaultLogPath)$(DefaultFilePrefix)_Primary.ldf') COLLATE SQL_Latin1_General_CP1_CI_AS
GO
USE [$(DatabaseName)];


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                NUMERIC_ROUNDABORT OFF,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON,
                CURSOR_DEFAULT LOCAL,
                RECOVERY SIMPLE,
                CURSOR_CLOSE_ON_COMMIT OFF,
                AUTO_CREATE_STATISTICS ON,
                AUTO_SHRINK OFF,
                AUTO_UPDATE_STATISTICS ON,
                RECURSIVE_TRIGGERS OFF 
            WITH ROLLBACK IMMEDIATE;
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CLOSE OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ALLOW_SNAPSHOT_ISOLATION OFF;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET READ_COMMITTED_SNAPSHOT OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_UPDATE_STATISTICS_ASYNC OFF,
                PAGE_VERIFY NONE,
                DATE_CORRELATION_OPTIMIZATION OFF,
                DISABLE_BROKER,
                PARAMETERIZATION SIMPLE,
                SUPPLEMENTAL_LOGGING OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET TRUSTWORTHY OFF,
        DB_CHAINING OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET HONOR_BROKER_PRIORITY OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET TARGET_RECOVERY_TIME = 0 SECONDS 
    WITH ROLLBACK IMMEDIATE;


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET FILESTREAM(NON_TRANSACTED_ACCESS = OFF),
                CONTAINMENT = NONE 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CREATE_STATISTICS ON(INCREMENTAL = OFF),
                MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT = OFF,
                DELAYED_DURABILITY = DISABLED 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE SCOPED CONFIGURATION SET MAXDOP = 0;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET MAXDOP = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET LEGACY_CARDINALITY_ESTIMATION = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET LEGACY_CARDINALITY_ESTIMATION = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET PARAMETER_SNIFFING = ON;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET PARAMETER_SNIFFING = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET QUERY_OPTIMIZER_HOTFIXES = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET QUERY_OPTIMIZER_HOTFIXES = PRIMARY;
    END


GO
IF fulltextserviceproperty(N'IsFulltextInstalled') = 1
    EXECUTE sp_fulltext_database 'enable';


GO
/*
 Pre-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be executed before the build script.	
 Use SQLCMD syntax to include a file in the pre-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the pre-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/
GO

GO
PRINT N'Creating [dbo].[FileList]...';


GO
CREATE TYPE [dbo].[FileList] AS TABLE (
    [Name]   NVARCHAR (100)  NOT NULL,
    [Path]   NVARCHAR (1000) NOT NULL,
    [Source] NVARCHAR (100)  NOT NULL);


GO
PRINT N'Creating [dbo].[Audit]...';


GO
CREATE TABLE [dbo].[Audit] (
    [AuditId]      INT             IDENTITY (1, 1) NOT NULL,
    [AuditObject]  [sysname]       NULL,
    [SourceObject] NVARCHAR (1000) NULL,
    [StartDT]      DATETIME        NULL,
    [EndDT]        DATETIME        NULL,
    [Op]           NVARCHAR (10)   NULL,
    [Err]          INT             NULL,
    [RowCnt]       INT             NULL,
    [RunId]        INT             NULL,
    CONSTRAINT [AuditPK] PRIMARY KEY CLUSTERED ([AuditId] ASC)
);


GO
PRINT N'Creating [dbo].[FileProcessProgress]...';


GO
CREATE TABLE [dbo].[FileProcessProgress] (
    [FileId]           INT             IDENTITY (1, 1) NOT NULL,
    [FileName]         NVARCHAR (100)  NOT NULL,
    [FullName]         NVARCHAR (1000) NOT NULL,
    [SourceName]       NVARCHAR (100)  NOT NULL,
    [ProgressStatusId] TINYINT         NOT NULL,
    [ProcessId]        INT             NULL,
    [Priority]         INT             NOT NULL,
    [CreateDt]         DATETIME        NOT NULL,
    [ChangeDt]         DATETIME        NOT NULL,
    [ChangeBy]         NVARCHAR (30)   NOT NULL,
    PRIMARY KEY CLUSTERED ([FileId] ASC),
    UNIQUE NONCLUSTERED ([SourceName] ASC, [FileName] ASC)
);


GO
PRINT N'Creating [dbo].[ProgressStatus]...';


GO
CREATE TABLE [dbo].[ProgressStatus] (
    [ProgressStatusId]   TINYINT       NOT NULL,
    [ProgressStatusName] NVARCHAR (30) NOT NULL,
    [CreateDt]           DATETIME      NOT NULL,
    [ChangeDt]           DATETIME      NOT NULL,
    [ChangeBy]           NVARCHAR (30) NOT NULL,
    PRIMARY KEY CLUSTERED ([ProgressStatusId] ASC),
    UNIQUE NONCLUSTERED ([ProgressStatusName] ASC)
);


GO
PRINT N'Creating unnamed constraint on [dbo].[FileProcessProgress]...';


GO
ALTER TABLE [dbo].[FileProcessProgress]
    ADD DEFAULT 0 FOR [Priority];


GO
PRINT N'Creating unnamed constraint on [dbo].[FileProcessProgress]...';


GO
ALTER TABLE [dbo].[FileProcessProgress]
    ADD DEFAULT getdate() FOR [CreateDt];


GO
PRINT N'Creating unnamed constraint on [dbo].[FileProcessProgress]...';


GO
ALTER TABLE [dbo].[FileProcessProgress]
    ADD DEFAULT getdate() FOR [ChangeDt];


GO
PRINT N'Creating unnamed constraint on [dbo].[FileProcessProgress]...';


GO
ALTER TABLE [dbo].[FileProcessProgress]
    ADD DEFAULT suser_sname() FOR [ChangeBy];


GO
PRINT N'Creating unnamed constraint on [dbo].[ProgressStatus]...';


GO
ALTER TABLE [dbo].[ProgressStatus]
    ADD DEFAULT getdate() FOR [CreateDt];


GO
PRINT N'Creating unnamed constraint on [dbo].[ProgressStatus]...';


GO
ALTER TABLE [dbo].[ProgressStatus]
    ADD DEFAULT getdate() FOR [ChangeDt];


GO
PRINT N'Creating unnamed constraint on [dbo].[ProgressStatus]...';


GO
ALTER TABLE [dbo].[ProgressStatus]
    ADD DEFAULT suser_sname() FOR [ChangeBy];


GO
PRINT N'Creating [dbo].[prc_Audit]...';


GO

/*
declare @Audit_Key int
exec dbo.[prc_Audit] @AuditMode = 1,@AuditId = @Audit_Key out,@AuditObject='Test',@Options='debug'
--select @Audit_Key
exec dbo.[prc_Audit] @AuditMode = 0,@AuditId = @Audit_Key,@Op='1',@RowCnt=100,@Options='debug'
exec dbo.[prc_Audit] @AuditMode = 2,@AuditId = @Audit_Key,@Op='1',@RowCnt=100,@Options='debug'
select * from Audit
*/
CREATE PROCEDURE dbo.prc_Audit
      @AuditId INT = NULL OUT
    , @AuditMode TINYINT = 0
    , @AuditObject SYSNAME = NULL
    , @SourceObject NVARCHAR(1000) = NULL
    , @Op NVARCHAR(10) = NULL
    , @Err INT = NULL
    , @RowCnt INT = NULL
    , @RunId INT = NULL
    , @Options NVARCHAR(100) = NULL
AS
/******************************************************************************
** File: prc_Audit.proc.sql
** Name: dbo.prc_Audit
**
** Desc: Set process run record; generates unique audit key.
**          
** Params: 
**    AudutMode: {0=Update audit; 1=Start audit; 2=Close audit}
**
** Returns:
**    Return code: {0=Success; Error code otherwise}.
*******************************************************************************
**       CHANGE HISTORY
*******************************************************************************
** Date        Author    Description
** ----------  --------  ------------------------------------------------------
** 04/20/2009  andrey@biasintelligence.com  Created procedure.
******************************************************************************/

-- Reduce processing overhead.
SET NOCOUNT ON;

-- Standard variable declarations.
DECLARE
      @InitialTransactionCount INT
    , @RowCount INT
    , @IsDebug BIT
    , @ReturnCode INT
    , @Message NVARCHAR(1000)
    , @ProcedureName SYSNAME
    ;
    
-- Set variable defaults.
SELECT
      @ProcedureName = OBJECT_NAME(@@PROCID)
    , @InitialTransactionCount = @@TRANCOUNT
    , @IsDebug = CASE WHEN CHARINDEX('debug',@Options) > 0 THEN 1 ELSE 0 END
    , @ReturnCode = 0 -- Default return code.
    ;

BEGIN TRY

-- STEP 1: Check for begin audit mode.
IF @AuditMode = 1  -- Begin mode.

   BEGIN -- NEW AUDIT
   
        -- STEP 2: Validate mode.
        IF @AuditId IS NOT NULL
            RAISERROR('Warning: AuditId cant be reused in BEGIN Audit mode . Key=%d', 1, 0, @AuditId) WITH NOWAIT;
   
        -- STEP 3: Insert beginning of audit.
        INSERT dbo.Audit (
                AuditObject
              , SourceObject
              , StartDT
              , Op
              , Err
              , RowCnt
              , RunId
              )
            VALUES (
                  @AuditObject
                , @SourceObject
                , GETDATE() -- Start date time.
                , @Op
                , ISNULL(@Err,0) -- Error code.
                , @RowCnt
                , @RunId
                )
                ;
                
        -- STEP 3: Retrieve auto-generated audit key value.
        SELECT @AuditId = SCOPE_IDENTITY();
      
        -- STEP 4: For debug mode, report audit is created.
        IF @IsDebug = 1
            RAISERROR('Audit record %d created.', 0, 1, @AuditId) WITH NOWAIT;
         
   END; -- NEW AUDIT
   
ELSE

    BEGIN -- EXISTING AUDIT
    
        -- STEP 5: Validate audit exists.
        IF NOT EXISTS (SELECT 1 FROM dbo.Audit WHERE AuditId = @AuditId)
            RAISERROR('Specified audit record %d does not exist.', 11, 11, @AuditId) WITH NOWAIT;
            
        -- STEP 6: Check for update audit mode.
        IF @AuditMode = 0 -- Update mode.

            BEGIN -- UPDATE AUDIT MODE
         
                -- STEP 7: Validate audit is not already closed.
                IF EXISTS (SELECT 1 FROM dbo.Audit WHERE AuditId = @AuditId AND EndDT IS NOT NULL)
                    RAISERROR('Cannot change audit record %d because it is already closed.', 11, 11, @AuditId) WITH NOWAIT;
            
                -- STEP 8: Update audit.
                UPDATE A SET
                      A.AuditObject = ISNULL(@AuditObject, A.AuditObject)
                    , A.SourceObject = ISNULL(@SourceObject, A.SourceObject)
                    , A.Op = ISNULL(@Op, A.Op)
                    , A.Err = ISNULL(@Err, A.Err)
                    , A.RowCnt = ISNULL(@RowCnt, A.RowCnt)
                    , A.RunId = ISNULL(@RunId, A.RunId)
                    FROM dbo.Audit A
                    WHERE A.AuditId = @AuditId
                ;

                -- STEP 9: For debug mode, report audit is updated.
                IF @IsDebug = 1
                    RAISERROR('Audit record %d is updated.', 0, 1, @AuditId) WITH NOWAIT;

            END; -- UPDATE AUDIT MODE

        -- STEP 10: Check for close audit mode.    
        ELSE IF @AuditMode = 2

           BEGIN -- CLOSE AUDIT MODE
           
                -- STEP 11: Update audit mode to closed state.
                UPDATE A SET
                      A.EndDT = GETDATE()
                    , A.Err = ISNULL(@Err, Err)
                    FROM dbo.Audit A
                    WHERE A.AuditId = @AuditId
                ;

                -- STEP 12: For debug mode, report audit is closed.
                IF @IsDebug = 1 
                    RAISERROR('Audit record %d closed.', 0, 1, @AuditId) WITH NOWAIT;
                 
           END; -- CLOSE AUDIT MODE
           
        -- STEP 13: Handle unknown audit mode conditions.
        ELSE

            BEGIN -- UNKNOWN MODE CONDITION
                
                -- STEP 14: Handle unknown mode condition.
                RAISERROR('Invalid audit mode specified for an existing audit record. Mode=%d', 11, 11, @AuditMode) WITH NOWAIT;
              
            END; -- UNKNOWN MODE CONDITION
            
    END; -- EXISTING AUDIT
    
END TRY
BEGIN CATCH

    -- Rollback uncommitted changes.
    IF @@TRANCOUNT > @InitialTransactionCount ROLLBACK TRAN;

    SELECT @ReturnCode = ERROR_NUMBER();
        
    -- Record an error condition.  
    UPDATE A SET 
          A.Err = ERROR_NUMBER()
        , A.EndDT = GETDATE()  -- Error implicitly closes an audit cycle.
        FROM dbo.Audit A
        WHERE A.AuditId = @AuditId
    ;
    
    SELECT @Message = 'Audit %d: failed with the message:' + ERROR_MESSAGE();
    RAISERROR(@Message, 11, 11, @AuditId) WITH NOWAIT;
    
END CATCH

RETURN @ReturnCode
GO
PRINT N'Creating [dbo].[prc_FileProcessGetNext]...';


GO
CREATE PROCEDURE dbo.prc_FileProcessGetNext
	 @SourceName nvarchar(100) = null
	,@Count int = 1
	,@processId int = 0
	,@options nvarchar(100) = null
AS
/*
exec dbo.prc_FileProcessGetNext 'testSource',5,0
*/
	SET NOCOUNT ON;
	--SET XACT_ABORT ON;
	DECLARE	 @msg nvarchar(max)
			,@debug bit
			,@tran int
			,@err int
			,@proc sysname = object_name(@@procid)
			,@rows int;

	SET @err = 0;
	SET @tran = @@TRANCOUNT;
			 
	BEGIN TRY

	SET @debug = CASE WHEN charindex('debug', @options) > 0 THEN 1 ELSE 0 END;


	UPDATE dst
	 SET ProgressStatusId = 1 --started
		,dst.processId = isnull(@processId,dst.processId)
		,dst.changeDt = getDate()
		,dst.changeBy = suser_sname()
		OUTPUT deleted.fileId,deleted.[fileName],deleted.[fullName],deleted.sourceName,inserted.processId
	FROM dbo.FileProcessProgress dst
	JOIN (SELECT TOP (@count) fp.fileId FROM dbo.FileProcessProgress fp WITH (TABLOCK)
	WHERE fp.ProgressStatusId = 0 AND fp.SourceName = ISNULL(@sourceName,fp.sourceName)
	ORDER BY fp.[Priority] desc, fp.CreateDt asc) lst
	ON dst.fileId = lst.fileId;


	RETURN 0;

	END TRY
	BEGIN CATCH
	   IF @@TRANCOUNT > @tran
	      ROLLBACK TRAN;
	      
	   SET @msg = ERROR_MESSAGE();
	   SET @Err = ERROR_NUMBER();

	   THROW @Err, @msg, 1;
	END CATCH

RETURN @err;
GO
PRINT N'Creating [dbo].[prc_FileProcessProgressUpdate]...';


GO
CREATE PROCEDURE dbo.prc_FileProcessProgressUpdate
	 @fileId int = null
	,@FileName nvarchar(100) = null
	,@SourceName nvarchar(100) = null
	,@ProgressStatusId tinyint = null
	,@ProgressStatusName nvarchar(100) = null
	,@processId int = null
	,@priority int = null
	,@options nvarchar(100) = null
AS
/*
exec dbo.prc_FileProcessProgressUpdate @fileId = 3, @progressStatusId = 0,@priority = 2
*/
	SET NOCOUNT ON;
	--SET XACT_ABORT ON;
	DECLARE	 @msg nvarchar(max)
			,@debug bit
			,@tran int
			,@err int
			,@proc sysname = object_name(@@procid)
			,@rows int;

	SET @err = 0;
	SET @tran = @@TRANCOUNT;
			 
	BEGIN TRY

	SET @debug = CASE WHEN charindex('debug', @options) > 0 THEN 1 ELSE 0 END;

	IF (@fileId IS NULL AND (@FileName IS NULL OR @SourceName IS NULL))
	BEGIN
		SET @msg = 'Invalid parameters. @fileId or @fileName and @sourceName are required';   
		THROW 50001, @msg, 1;
	END

	DECLARE @fId int = (SELECT fileId FROM dbo.FileProcessProgress
	 WHERE fileId = ISNULL(@fileId,fileId)
	 AND [fileName] = ISNULL(@fileName,[fileName])
	 AND [sourceName] = ISNULL(@sourceName,[sourceName]));

	IF (@fId IS NULL)
	BEGIN
		SET @msg = 'Invalid parameters. @fileId = ' + ISNULL(CAST(@fileId AS nvarchar(30)),'null')
		+ ' or @fileName = ' + ISNULL(@fileName,'null')
		+ ' or @sourceName = ' + ISNULL(@sourceName,'null') ;

		THROW 50002, @msg, 1;
	END


	IF (@ProgressStatusId IS NULL AND @ProgressStatusName IS NULL)
	BEGIN
		SET @msg = 'Invalid parameters. @ProgressStatusName or ProgressStatusName are required';   
		THROW 50001, @msg, 1;
	END

	DECLARE @statusId tinyint = (SELECT progressStatusId FROM dbo.ProgressStatus
	WHERE progressStatusId = ISNULL(@progressStatusId,progressStatusId)
	AND progressStatusName = ISNULL(@progressStatusName,progressStatusName));

	IF (@statusId IS NULL)
	BEGIN
		SET @msg = 'Invalid parameters. @progressStatusId = ' + ISNULL(CAST(@progressStatusId AS nvarchar(30)),'null')
		+ ' or @progressStatusName = ' + ISNULL(@progressStatusName,'null');

		THROW 50002, @msg, 1;
	END

	UPDATE dbo.FileProcessProgress
	 SET ProgressStatusId = isnull(@statusId,ProgressStatusId)
		,processId = isnull(@processId,processId)
		,[priority] = isnull(@priority,[priority])
		,changeDt = getDate()
		,changeBy = suser_sname()
	WHERE fileId = @fId;

	RETURN 0;

	END TRY
	BEGIN CATCH
	   IF @@TRANCOUNT > @tran
	      ROLLBACK TRAN;
	      
	   SET @msg = ERROR_MESSAGE();
	   SET @Err = ERROR_NUMBER();

	   THROW @Err, @msg, 1;
	END CATCH

RETURN @err;
GO
PRINT N'Creating [dbo].[prc_FileProcessRegisterNew]...';


GO
CREATE PROCEDURE dbo.prc_FileProcessRegisterNew
	 @list [dbo].[FileList] readonly
	,@processId int = 0
	,@priority int = 0
	,@options nvarchar(100) = null
AS
/*
declare @list [dbo].[FileList]
insert @list
values ('testFile1.json','c:\files\testFile1.json','testSource')
,('testFile2.json','c:\files\testFile1.json','testSource')
exec dbo.prc_FileProcessRegisterNew @list,1,1

*/

	SET NOCOUNT ON;
	--SET XACT_ABORT ON;
	DECLARE	 @msg nvarchar(max)
			,@debug bit
			,@tran int
			,@err int
			,@proc sysname = object_name(@@procid)
			,@rows int;

	SET @err = 0;
	SET @tran = @@TRANCOUNT;
			 
	BEGIN TRY

	SET @debug = CASE WHEN charindex('debug', @options) > 0 THEN 1 ELSE 0 END;
	IF NOT EXISTS (SELECT 1 FROM @list)
		RETURN 0;


	DECLARE @StatusId tinyint = 0; -- new records

	MERGE dbo.FileProcessProgress dst
	USING (SELECT [Name], [Path], [Source] FROM @list) src ([FileName], [FullName], [SourceName])
	ON src.[FileName] = dst.[FileName] AND src.[SourceName] = dst.[SourceName]
	WHEN NOT MATCHED BY TARGET THEN
	INSERT ([FileName], [FullName], [SourceName],[ProgressStatusId],[ProcessId],[Priority])
	VALUES ([FileName], [FullName], [SourceName],@statusId,@processId,@priority)
	;

	END TRY
	BEGIN CATCH
	   IF @@TRANCOUNT > @tran
	      ROLLBACK TRAN;
	      
	   SET @msg = ERROR_MESSAGE();
	   SET @Err = ERROR_NUMBER();

	   THROW @Err, @msg, 1;
	END CATCH

RETURN @err;
GO
PRINT N'Creating [dbo].[prc_StagingTablePrepare]...';


GO
create procedure [dbo].[prc_StagingTablePrepare] (
    @src           sysname
   ,@dst           sysname = null output
   ,@runid         int = null
   ,@options       varchar(255) = null
) as
begin
/******************************************************************************
** File:	[prc_StagingTablePrepare].sql
** Name:	[dbo].[prc_StagingTablePrepare]

** Desc:	prepare staging table. Create one or tructate if present. Proc uses @src table as template
**          
**
** Params:
** @src       -- table or view name to use as template
** @dst       -- returns delta table name
** @options   -- supported: debug,rebuild,index,uniqueindex
** Returns:
**
** Author:	andreys
** Date:	12/5/2008
** ****************************************************************************
** CHANGE HISTORY
** ****************************************************************************
** Date				Author	version	4	#bug			Description
** ----------------------------------------------------------------------------------------------------------
   2012-03-08       andreys                             add extended property metadata
														table: hasMetadata = 1
														column: isSPK = ordinal(1,2,3) --source PK ordinal
															    isType2 = 1 -- type2 column
																isAudit = 1 -- audit column
																isType2StartPeriod -- Type2 start period column
																isType2EndPeriod -- Type2 end period column
																isAction = 1 -- action column

  2017-03-13		andrey								add ident column back
  2017-03-30		andrey								remove src/dst db if the same to support azure dbs 
*/
--exec [prc_StagingTablePrepare] 'dbo.TestProperty','dbo.staging_TestProperty',0,'debug,rebuild,index'

   set nocount on

   declare @err                int
   declare @tran               int
   declare @proc               sysname
   declare @msg                nvarchar(1000)
   declare @query              nvarchar(max)
   declare @sql1               nvarchar(max)
   declare @debug              tinyint
   declare @rebuild            tinyint
   declare @needindex          tinyint
   declare @quotename          tinyint
   declare @srcDB              sysname
   declare @srcSchema          sysname

   declare @AuditCol           sysname
   declare @ActionCol          sysname
   declare @RecordStartCol     sysname
   declare @RecordEndCol       sysname

   set @err = 0
   set @tran = @@trancount
   set @debug = case when @options like '%debug%' then 1 else 0 end
   set @rebuild = case when @options like '%rebuild%' then 1 else 0 end
   set @needindex = case 
                      when @options like '%uniqueindex%' then 1
                      when @options like '%index%' then 2
                      else 0
                    end
   set @quotename = case when @options like '%quotename%' then 1 else 0 end

-----------------------------------------------------------------------------------------------------
--metadata defaults
-----------------------------------------------------------------------------------------------------
   set @AuditCol = 'AuditId'
   set @ActionCol = 'ActionId'
   set @RecordStartCol = 'RecordStartDate'
   set @RecordEndCol = 'RecordEndDate'

-----------------------------------------------------------------------------------------------------
--table name normalization
-----------------------------------------------------------------------------------------------------
   set @srcDB = isnull(parsename(@src,3),DB_NAME())
   set @srcdb = case when @srcdb = db_name() then '' else quotename(@srcdb) + '.' end;

   set @srcSchema = quotename(isnull(parsename(@src,2),'dbo'))
   set @src = case when len(@srcDB) > 0 then @srcDB + '.' else '' end + @srcSchema+ '.' + quotename(parsename(@src,1))
   if (@quotename = 0)
   	   set @dst = isnull(parsename(isnull(@dst,@src),2),'dbo')
				+ '.' + isnull(parsename(@dst,1),'staging_' + parsename(@src,1))
	else
      set @dst = quotename(isnull(parsename(isnull(@dst,@src),2),'dbo'))
            + '.' + quotename(isnull(parsename(@dst,1),'staging_' + parsename(@src,1)))

  create table #srccol
  ([name] sysname primary key
  ,[type] smallint
  ,[len]  smallint
  ,[prec] tinyint
  ,[scale] tinyint
  ,[is_ident] bit
  ,[is_null] bit
  ,[is_guid] bit
  ,[colid] smallint
  ,[pk] tinyint
  ,[spk] tinyint
  ,[is_type2] bit
  )

  create table #srcprop
  ([colname] sysname
  ,[propname]  sysname
  ,[propvalue] nvarchar(30)
  )

begin try

   if (object_id(@src) is null)
   begin
      raiserror('ERROR: unknown object in %s',11,10,@src)
   end


-----------------------------------------------------------------------------------------------------
--build column def set
-----------------------------------------------------------------------------------------------------
   set @query = '
declare @tbl sysname,@sch sysname;
set @tbl = parsename(@src,1);
set @sch = parsename(@src,2);
if exists(select 1 from <db>.sys.fn_listextendedproperty (NULL, ''schema'', @sch, ''table'', @tbl, default, default) where name = ''hasMetadata'' and value = 1)
begin
--use Extended Properties
   insert #srcprop
   select objname, name, cast(value as nvarchar(30)) from <db>.sys.fn_listextendedproperty (NULL, ''schema'', @sch, ''table'', @tbl, ''column'', default);

   insert #srccol
   select d.[name],d.system_type_id,d.max_length,d.[precision],d.[scale]
       ,d.[is_identity],d.[is_nullable],d.[is_rowguidcol],d.[column_id]
       ,isnull(ipkc.[key_ordinal],0),isnull(spk.[propvalue],0),isnull(t2.[propvalue],0)
    from <db>.sys.columns d
    left join <db>.sys.indexes ipk on ipk.[object_id] = d.[object_id] and  ipk.[is_primary_key] = 1
    left join <db>.sys.index_columns ipkc
           on ipk.[object_id] = ipkc.[object_id]
          and ipk.[index_id] = ipkc.[index_id]
          and d.[column_id] = ipkc.[column_id]
    left join #srcprop spk on d.[name] = spk.[colname] and spk.[propname] = ''isSPK''
    left join #srcprop t2 on d.[name] = t2.[colname] and t2.[propname] = ''isType2''
    where d.[object_id] = object_id(@src)
end
else
begin
--use defaults
   insert #srccol
   select d.[name],d.system_type_id,d.max_length,d.[precision],d.[scale]
       ,d.[is_identity],d.[is_nullable],d.[is_rowguidcol],d.[column_id]
       ,isnull(ipkc.[key_ordinal],0),isnull(ispkc.[key_ordinal],0),isnull(ispkc.[is_included_column],0)
    from <db>.sys.columns d
    left join <db>.sys.indexes ipk on ipk.[object_id] = d.[object_id] and  ipk.[is_primary_key] = 1
    left join <db>.sys.index_columns ipkc
           on ipk.[object_id] = ipkc.[object_id]
          and ipk.[index_id] = ipkc.[index_id]
          and d.[column_id] = ipkc.[column_id]
    left join <db>.sys.indexes ispk on ispk.[object_id] = d.[object_id] and  ispk.name like ''UQ_SPK_%''
    left join <db>.sys.index_columns ispkc
           on ispk.[object_id] = ispkc.[object_id]
          and ispk.[index_id] = ispkc.[index_id]
          and d.[column_id] = ispkc.[column_id]
    where d.[object_id] = object_id(@src)
end
'
    
   set @query = replace(@query,'<db>.',@srcDB)
   --print @query
   exec sp_executesql @query,N'@src sysname',@src = @src

   --if (@debug = 1)
   --begin
   --   select * from #srccol
   --end

  set @AuditCol = isnull((select top 1 [colname] from #srcprop where [propname] = 'isAudit' and [propvalue] = 1)
                            ,(select top 1 [name] from #srccol where [name] = @AuditCol));
   set @ActionCol = isnull((select top 1 [colname] from #srcprop where [propname] = 'isAction' and [propvalue] = 1)
                            ,(select top 1 [name] from #srccol where [name] = @ActionCol));
   set @RecordStartCol = isnull((select top 1 [colname] from #srcprop where [propname] = 'isType2StartPeriod' and [propvalue] = 1)
                            ,(select top 1 [name] from #srccol where [name] = @RecordStartCol));
   set @RecordEndCol = isnull((select top 1 [colname] from #srcprop where [propname] = 'isType2EndPeriod' and [propvalue] = 1)
                            ,(select top 1 [name] from #srccol where [name] = @RecordEndCol));

   --remove dw specific columns
   delete #srccol where [name] in (@AuditCol,@ActionCol,@RecordStartCol,@RecordEndCol)
   --remove identity column
   --need it for sync processing
   --delete #srccol where [is_ident] = 1

   --use spk as pk if provided
   if (exists(select 1 from #srccol where [spk] > 0))
   begin
      delete #srccol where [pk] > 0 and  [spk] = 0
      update #srccol set [pk] = [spk]
   end
   
   --remove pk requirement for staging
   if not exists(select 1 from #srccol where pk > 0)
   begin
      if (@needindex <> 0)
	  begin
         raiserror('WARNING: index can not be created. spk is required on %s',0,1,@src);
         set @needindex = 0;
	  end
      --raiserror('ERROR: pk is required in %s',11,10,@src)
   end
   if not exists(select 1 from #srccol)
   begin
      raiserror('ERROR: no source columns are found in %s',11,10,@src)
   end

-----------------------------------------------------------------------------------------------------
--check delta
-----------------------------------------------------------------------------------------------------
   if (@rebuild = 0)
   begin
      if object_id(@dst) is null
      begin
         set @rebuild = 1
      end
      else
      begin
         if exists(
            select 1 from (select d.[name] from sys.columns d where d.[object_id] = object_id(@dst)) d
              full join (select s.[name] from #srccol s) s
                on s.[name] = d.[name]
             where (s.[name] is null or d.name is null))
         begin
            exec ('drop table ' + @dst)
            set @rebuild = 1
         end
      end
   end
   else if object_id(@dst) is not null
   begin
      exec ('drop table ' + @dst)
   end


-----------------------------------------------------------------------------------------------------
--truncate or table create DDL
-----------------------------------------------------------------------------------------------------
   if (@rebuild = 0)
   begin
      set @query = 'truncate table ' + @dst + ';'
      if (@needIndex = 0 and exists(select 1 from sys.indexes where object_id = object_id(@dst) and name like 'uq_spk_%'))
         set @query = @query + 'drop index [uq_spk_' + parsename(@dst,1) + '] on ' + @dst + ';'
   end
   else
   begin
      set @query = 'create table ' + @dst + '(<columnlist>)'

      --<columnlist>
      set @sql1 = ''
      select @sql1 = @sql1 + ',' + quotename([name]) + ' ' + type_name([type])
                + case when [type] in (62) then '(' + cast(prec as nvarchar(10)) + ')'    
                       when [type] in (106,108) then '(' + cast(prec as nvarchar(10)) + ',' + cast(scale as nvarchar(10)) + ')'
                       when [type] in (165,167,173,175) then case when [len] = -1 then '(max)' else '(' + cast([len] as nvarchar(10)) + ')' end
                       when [type] in (231,239) then case when [len] = -1 then '(max)' else '(' + cast([len]/2 as nvarchar(10)) + ')' end
                       else '' 
                  end
                --+ case when ([pk] = 0) then ' null' else ' not null' end --+ char(13) + char(10)
                + case when ([is_null] = 0) then ' not null' else ' null' end --+ char(13) + char(10)
        from  #srccol
        order by [colid]

      set @sql1 = right(@sql1,len(@sql1) -1)
      set @query = replace(@query,'<columnlist>',@sql1)

   end

   if (@debug = 1)
   begin
      print @query
   end
   exec(@query)

 --create index for pre sorted input
   if (@rebuild = 1 and @needIndex > 0)
   begin
      set @query = 'create ' + case @needIndex when 1 then 'unique' else '' end + ' clustered index uq_spk_<tblname> on '
                 + @dst + '(<keycolumnlist>)'

      --<keycolumnlist>
      set @sql1 = ''
      select @sql1 = @sql1 + ',' + quotename([name])
        from  #srccol where [pk] > 0 and [is_type2] = 0
        order by [pk]

      set @sql1 = right(@sql1,len(@sql1) -1)
      set @query = replace(@query,'<keycolumnlist>',@sql1)
      set @query = replace(@query,'<tblname>',parsename(@dst,1))

      if (@debug = 1)
      begin
         print @query
      end
      exec(@query)
   end


end try
begin catch
   if @@trancount > @tran
      rollback tran

   set @dst = null
   set @Proc = ERROR_PROCEDURE()
   set @Msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   raiserror ('ERROR: PROC %s, MSG: %s',11,17,@Proc,@Msg) 
end catch

   return @err
end
GO
PRINT N'Creating [dbo].[prc_StagingTableUpload]...';


GO
create procedure [dbo].[prc_StagingTableUpload] (  
    @src      sysname  
   ,@dst      sysname
   ,@RunId    int = 0
   ,@options  varchar(255) = null  
) as  
begin  
/******************************************************************************  
** File: [prc_StagingTableUpload].sql  
** Name: [dbo].[prc_StagingTableUpload]  
  
** Desc: Delete and Insert data from src into dst table. dst must have primary key.   
**            
**  
** Params:  
** @src  -- fully qualified source table name. if database is not specified the db  
**               defaults to current database, if schema is not specified schema defaults to dbo  
** @dst  -- domain destination. must exists in current database. if schema is not specified schema defaults to dbo  
** @options   -- debug
                ,fullmerge --insert+update+softdelete
				,reload --truncate+insert
				,append --insert without check
				,checksum --update only changed records
				,appendnew --insert new only
** Returns:  
**  
** Author: andreys  
** Date: 11/05/2008  
** ****************************************************************************  
** CHANGE HISTORY  
** ****************************************************************************  
** Date        Author   version  #bug   Description
** ----------------------------------------------------------------------------------------------------------  
** 20011-12-29 andrey                  added type2 logic. Type2 columns are included columns in the UQ_SPK index
                                                         also RecordStartDate, RecordEndDate columns are required  
   2012-03-08       andreys            add extended property metadata
														table: hasMetadata = 1
														column: isSPK = ordinal(1,2,3) --source PK ordinal
															    isType2 = 1 -- type2 column
																isAudit = 1 -- audit column
																isAction = 1 -- action column
																isType2StartPeriod -- Type2 start period column
																isType2EndPeriod -- Type2 end period column
  2012-05-30		andrey				fix Soft Delete. After Soft Delete set ActionId to 1 - insert
  2013-05-13		andrey				check for type2 columns
  2013-05-21		andrey				move type2 filter from join to match clause
  2017-01-21		andrey				fix merge when table has only PK or SPK columns
  2017-03-13		andrey				comment audit calls + allow identity on pk
  2017-03-30		andrey				remove src/dst db if the same to support azure dbs 
*/
--exec [prc_StagingTablePrepare] 'dbo.TestProperty','dbo.staging_TestProperty',0,'debug,rebuild,index'
  
   set nocount on  
  
   declare @err                int
   declare @tran               int
   declare @proc               sysname  
   declare @msg                nvarchar(1000)  
   declare @query              nvarchar(max)  
   declare @sql1               nvarchar(max)  
   declare @sql2               nvarchar(max)  
   declare @srcdb              sysname  
   declare @dstdb              sysname  
   declare @debug              bit
   declare @delete             bit
   declare @reload             bit
   declare @append             bit
   declare @appendnew      bit
   declare @check              bit
   declare @rows               int
   declare @is_tbl             tinyint
   declare @is_type2           bit

   declare @AuditCol           sysname
   declare @ActionCol          sysname
   declare @RecordStartCol     sysname
   declare @RecordEndCol       sysname

   set @proc = object_name(@@procid)  
   set @err = 0  
   set @tran = @@trancount
   set @debug = case when @options like '%debug%' then 1 else 0 end  
   set @delete = case when @options like '%fullmerge%' then 1 else 0 end
   set @reload = case when @options like '%reload%' then 1 else 0 end
   set @append = case when @options like '%append%' and @options not like '%appendnew%' then 1 else 0 end
   set @check = case when @options like '%checksum%' then 1 else 0 end
   set @appendnew = case when @options like '%appendnew%' then 1 else 0 end
                                                   
   set @RunId = ISNULL(@RunId,0)
   
-----------------------------------------------------------------------------------------------------
--metadata defaults
-----------------------------------------------------------------------------------------------------
   set @AuditCol = 'AuditId'
   set @ActionCol = 'ActionId'
   set @RecordStartCol = 'RecordStartDate'
   set @RecordEndCol = 'RecordEndDate'
-----------------------------------------------------------------------------------------------------  
--table name normalization  
-----------------------------------------------------------------------------------------------------  
   if (charindex('#',parsename(@src,1)) > 0)  
   begin  
      set @srcdb = quotename('tempdb') + '.';  
      set @src = quotename(parsename(@src,1))  
   end  
   else  
   begin  
      set @srcdb = isnull(parsename(@src,3),db_name())
      set @srcdb = case when @srcdb = db_name() then '' else quotename(@srcdb) + '.' end;

      set @src = @srcdb  
               + quotename(isnull(parsename(@src,2),'dbo')) + '.'
			   + quotename(parsename(@src,1));
   end  
  
   set @dstdb = isnull(parsename(@dst,3),db_name());
   set @dstdb = case when @dstdb = db_name() then '' else quotename(@dstdb) + '.' end;
   set @dst = @dstdb  
            + quotename(isnull(parsename(@dst,2),'dbo')) + '.'
			+ quotename(parsename(@dst,1))  
  
  
  create table #srccol  
  ([src_name] sysname  
  ,[type] smallint  
  ,[len]  smallint  
  ,[prec] tinyint  
  ,[scale] tinyint
  ,[spk] tinyint)  
  
  
  create table #dstcol  
  ([name] sysname  
  ,[src_name] sysname null  
  ,[type] smallint  
  ,[len]  smallint  
  ,[prec] tinyint  
  ,[scale] tinyint  
  ,[is_ident] bit  
  ,[is_null] bit  
  ,[is_guid] bit  
  ,[has_src] bit
  ,[is_add] bit
  ,[pk] tinyint 
  ,[spk] tinyint
  ,[is_type2] bit) 
  
  
  create table #dstprop
  ([colname] sysname
  ,[propname]  sysname
  ,[propvalue] nvarchar(30)
  )

begin try 
  
   set @is_tbl = 0;
   if (object_id(case when @srcdb = quotename('tempdb') + '.' then @srcdb + '.' else '' end + @src,'U') is not null)
      set @is_tbl = 1;
   else if (object_id(case when @srcdb = quotename('tempdb') + '.' then @srcdb + '.' else '' end + @src) is null)  
      raiserror('ERROR: unknown source table in %s',11,10,@src)  
     
   if (object_id(@dst) is null)  
   begin  
      raiserror('ERROR: unknown destination table in %s',11,10,@dst)  
   end  
  
-----------------------------------------------------------------------------------------------------  
--bring srcTable def over  
-----------------------------------------------------------------------------------------------------  
  
   set @query = '  
      insert #srccol  
      select s.[name],s.system_type_id,s.max_length,s.[precision],s.[scale],isnull(ispkc.[key_ordinal],0)  
        from ' + @srcdb + 'sys.columns s
    left join ' + @srcdb + 'sys.indexes ispk on ispk.[object_id] = s.[object_id] and  ispk.name like ''UQ_SPK_%''
    left join ' + @srcdb + 'sys.index_columns ispkc
           on ispk.[object_id] = ispkc.[object_id]
          and ispk.[index_id] = ispkc.[index_id]
          and s.[column_id] = ispkc.[column_id] 
       where s.[object_id] = object_id(''' + case when @srcdb = quotename('tempdb') + '.' then @srcdb + '.' else '' end + @src + ''')  
     '  
  
   --if (@debug = 1)  
   --begin  
   --   print @query  
   --end  
  
   exec(@query)  
  
   --if (@debug = 1)  
   --begin  
   --   select * from #srccol  
   --end  

-----------------------------------------------------------------------------------------------------  
--build column def set  
-----------------------------------------------------------------------------------------------------  
  set @query = '
declare @tbl sysname,@sch sysname;
set @tbl = parsename(@dst,1);
set @sch = parsename(@dst,2);
if exists(select 1 from <db>.sys.fn_listextendedproperty (NULL, ''schema'', @sch, ''table'', @tbl, default, default) where name = ''hasMetadata'' and value = 1)
begin
--use Extended Properties
   insert #dstprop
   select objname, name, cast(value as nvarchar(30)) from <db>.sys.fn_listextendedproperty (NULL, ''schema'', @sch, ''table'', @tbl, ''column'', default);

  insert #dstcol  
  select 
      [name]     = d.[name]
     ,[src_name] = s.[src_name]
     ,[type]     = d.system_type_id
     ,[len]      = d.max_length
     ,[prec]     = d.[precision]
     ,[scale]    = d.[scale]  
     ,[is_ident] = d.[is_identity]
     ,[is_null]  = d.[is_nullable]
     ,[is_guid]  = d.[is_rowguidcol]
     ,[has_src]  = case when s.[src_name] is null then 0 else 1 end
     ,[is_add]   = case when d.system_type_id in (48,52,56,59,60,62,106,108,122,127) then 1 else 0 end  
     ,isnull(ipkc.[key_ordinal],0)
     ,isnull(spk.[propvalue],0)
     ,isnull(t2.[propvalue],0)
    from <db>.sys.columns d  
    left join #srccol s on d.[name] = s.[src_name]  
    left join <db>.sys.indexes ipk on ipk.[object_id] = d.[object_id] and  ipk.[is_primary_key] = 1
    left join <db>.sys.index_columns ipkc
           on ipk.[object_id] = ipkc.[object_id]
          and ipk.[index_id] = ipkc.[index_id]
          and d.[column_id] = ipkc.[column_id]
    left join #dstprop spk on d.[name] = spk.[colname] and spk.[propname] = ''isSPK''
    left join #dstprop t2 on d.[name] = t2.[colname] and t2.[propname] = ''isType2''
    where d.[object_id] = object_id(@dst)

end
else
begin
--use defaults

  insert #dstcol  
  select 
      [name]     = d.[name]
     ,[src_name] = s.[src_name]
     ,[type]     = d.system_type_id
     ,[len]      = d.max_length
     ,[prec]     = d.[precision]
     ,[scale]    = d.[scale]  
     ,[is_ident] = d.[is_identity]
     ,[is_null]  = d.[is_nullable]
     ,[is_guid]  = d.[is_rowguidcol]
     ,[has_src]  = case when s.[src_name] is null then 0 else 1 end
     ,[is_add]   = case when d.system_type_id in (48,52,56,59,60,62,106,108,122,127) then 1 else 0 end  
     ,isnull(ipkc.[key_ordinal],0)
     ,isnull(ispkc.[key_ordinal],0)
     ,isnull(ispkc.[is_included_column],0)
    from <db>.sys.columns d  
    left join #srccol s on d.[name] = s.[src_name]  
    left join <db>.sys.indexes ipk on ipk.[object_id] = d.[object_id] and  ipk.[is_primary_key] = 1
    left join <db>.sys.index_columns ipkc
           on ipk.[object_id] = ipkc.[object_id]
          and ipk.[index_id] = ipkc.[index_id]
          and d.[column_id] = ipkc.[column_id]
    left join <db>.sys.indexes ispk on ispk.[object_id] = d.[object_id] and  ispk.name like ''UQ_SPK_%''
    left join <db>.sys.index_columns ispkc
           on ispk.[object_id] = ispkc.[object_id]
          and ispk.[index_id] = ispkc.[index_id]
          and d.[column_id] = ispkc.[column_id]
    where d.[object_id] = object_id(@dst)
end
'
  
   set @query = replace(@query,'<db>.',@dstdb)
   exec sp_executesql @query,N'@dst sysname',@dst = @dst

   --if (@debug is not null)
   --begin
   --   select * from #dstcol
   --end

   set @AuditCol = isnull((select top 1 [colname] from #dstprop where [propname] = 'isAudit' and [propvalue] = 1)
                            ,(select top 1 [name] from #dstcol where [name] = @AuditCol));
   set @ActionCol = isnull((select top 1 [colname] from #dstprop where [propname] = 'isAction' and [propvalue] = 1)
                            ,(select top 1 [name] from #dstcol where [name] = @ActionCol));
   set @RecordStartCol = isnull((select top 1 [colname] from #dstprop where [propname] = 'isType2StartPeriod' and [propvalue] = 1)
                            ,(select top 1 [name] from #dstcol where [name] = @RecordStartCol));
   set @RecordEndCol = isnull((select top 1 [colname] from #dstprop where [propname] = 'isType2EndPeriod' and [propvalue] = 1)
                            ,(select top 1 [name] from #dstcol where [name] = @RecordEndCol));

   set @is_type2 = 0;
   if (@RecordStartCol is not null and @RecordEndCol is not null)
   begin
      set @is_type2 = 1;
   end

   --remove dw specific columns
   delete #dstcol where [name] in (@AuditCol,@ActionCol,@RecordStartCol,@RecordEndCol)

if (@reload = 1 or @append = 1)
begin
-----------------------------------------------------------------------------------------------------  
--reload/append
-----------------------------------------------------------------------------------------------------  

   set @query =
 'declare @AuditId int,@Err int,@Rows int,@dt date;
set @dt = getdate();
begin try
if exists (select 1 from <src>)
begin
   --exec <dstdb>.dbo.prc_Audit @AuditId = @AuditId out,@AuditMode = 1,@AuditObject = ''<dst>'',@Op = ''<op>'',@RunId = @RunID,@Options = @Options
'
+ case when @reload = 1 then ' truncate table <dst> ' else '' end
+ '  
  <IdentityOn>
   insert <dst>
   (<dstlist>)
   select <selectlist>
     from <src>

  set @rows = @@rowcount
  --raiserror(''%d rows reloaded into <dst> table'',0,1,@rows) with nowait 
  <IdentityOff>

   --exec <dstdb>.dbo.prc_Audit @AuditId = @AuditId,@AuditMode = 0,@RowCnt = @Rows,@Options = @Options
   --exec <dstdb>.dbo.prc_Audit @AuditId = @AuditId,@AuditMode = 2,@Options = @Options

end  
end try  
begin catch
  <IdentityOff>
   declare @msg nvarchar(500)  
   set @msg = error_message()
   set @Err = error_number()
  
   --if (@AuditId is not null) 
   --   exec <dstdb>.dbo.prc_Audit @AuditId = @AuditId,@AuditMode = 2,@Err = @Err,@Options = @Options
   raiserror (@msg,11,17) 
end catch  
     '  
end
else
begin

   --use spk as pk if provided
   if (not exists(select 1 from #dstcol where [spk] > 0))
   begin
      update #dstcol set [spk] = [pk]
   end

  
   if (not exists(select 1 from #dstcol where [spk] > 0))  
   begin  
      raiserror('ERROR: dst table %s must have spk in order to join to src table',11,10,@dst)  
   end  
   if (exists(select 1 from #dstcol where [spk] > 0 and [has_src] = 0))  
   begin  
      raiserror('ERROR: src table must have dst spk columns present',11,10,@dst)  
   end  
   if (exists(select 1 from #dstcol where [pk] = 0 and [is_ident] = 1))  
   begin  
      raiserror('ERROR: identity on non pk column is not supported',11,10,@dst)  
   end  

   if (@is_type2 = 0)
   begin
-----------------------------------------------------------------------------------------------------  
--type1 merge
-----------------------------------------------------------------------------------------------------  
   set @query =
 'declare @AuditId int,@Err int,@Rows int
begin try
if exists (select 1 from <src>)
begin
  --exec <dstdb>.dbo.prc_Audit @AuditId = @AuditId out,@AuditMode = 1,@AuditObject = ''<dst>'',@Op = ''<op>'',@RunId = @RunID,@Options = @Options
  <performanceindex>

  <IdentityOn>
   merge <dst> as dst
   using (select <selectlist> from <src>) as src
         (<dstlist>)
      on (<joinlist>)
  --1  when matched <type1checksum> then 
  --1 update Set <updatelist>
       when not matched by target then 
      insert (<dstlist>)
      values (<dstlist>)
  --2  when not matched by source <delete>
  ;
--OUTPUT $action;

  set @rows = @@rowcount
  --raiserror(''%d rows merged into <dst> table'',0,1,@rows) with nowait 
  <IdentityOff>

  --exec <dstdb>.dbo.prc_Audit @AuditId = @AuditId,@AuditMode = 0,@RowCnt = @Rows,@Options = @Options
  --exec <dstdb>.dbo.prc_Audit @AuditId = @AuditId,@AuditMode = 2,@Options = @Options

end  
end try  
begin catch  
  <IdentityOff>
   declare @msg nvarchar(500)  
   set @msg = error_message()
   set @Err = error_number()
  
   --if (@AuditId is not null) 
   --   exec <dstdb>.dbo.prc_Audit @AuditId = @AuditId,@AuditMode = 2,@Err = @Err,@Options = @Options
   raiserror (@msg,11,17) 
end catch  
     '  
--<appendnew> option
--or dst only has pk/spk columns (no need for update)
   if (@appendnew = 0
   and exists (select 1 from #dstcol where spk = 0 and has_src = 1))
      set @query = replace(@query,'--1','')


--<fullmerge> option
--<delete>
   if (@delete = 1)
   begin
      set @query = replace(@query,'--2','');
	  if (@ActionCol is null)
         set @query = replace(@query,'<delete>','then delete'); --hard delete if action col is not defined
	  else
	  begin
	     set @sql1 = ' and dst.' +  @ActionCol + ' <> 3 then update set dst.' +  @ActionCol + ' = 3' + case when @AuditCol is not null then ',dst.' +  @AuditCol + ' = @AuditId' else '' end;
		 set @query = replace(@query,'<delete>',@sql1);
	  end
   end


   end
   else
   begin
-----------------------------------------------------------------------------------------------------  
--type2 merge
-----------------------------------------------------------------------------------------------------  
--if type2 columns are not defined set all none key columns to type2
   if (not exists(select 1 from #dstcol where [is_type2] = 1))  
   begin  
      update #dstcol set [is_type2] = 1 where [spk] = 0;
      SET @rows = @@ROWCOUNT;
      if (@rows = 0)
		raiserror('ERROR: no type2 columns found',11,10)  
   end

   set @query =
 'declare @AuditId int,@Err int,@Rows int,@tran int,@dt date;
 set @tran = @@TRANCOUNT;
 set @dt = getdate();
begin try
if exists (select 1 from <src>)
begin
  --exec <dstdb>.dbo.prc_Audit @AuditId = @AuditId out,@AuditMode = 1,@AuditObject = ''<dst>'',@Op = ''<op>'',@RunId = @RunID,@Options = @Options
  <performanceindex>

   begin tran;
   merge <dst> as dst
   using (select <selectlist> from <src>) as src
         (<dstlist>)
      on (<joinlist>)
    when matched <type2checksum>
	and (dst.' + @RecordEndCol + ' is null and dst.' + @RecordStartCol + ' < @dt) then 
  update Set dst.' + @RecordEndCol + ' = @dt;

  set @rows = @@rowcount
  --raiserror(''%d rows t2 closed recorded merged into <dst> table'',0,1,@rows) with nowait 

   merge <dst> as dst
   using (select <selectlist> from <src>) as src
         (<dstlist>)
      on (<joinlist>)
	 and (dst.' + @RecordEndCol + ' is null)
--1	when matched <type1checksum> then
--1  update Set <updatelist>
       when not matched by target then 
      insert (<dstlist>)
      values (<dstlist>);

  set @rows = @rows + @@rowcount
  --raiserror(''%d rows t1 merged into <dst> table'',0,1,@rows) with nowait 

  commit tran;

  --exec <dstdb>.dbo.prc_Audit @AuditId = @AuditId,@AuditMode = 0,@RowCnt = @Rows,@Options = @Options
  --exec <dstdb>.dbo.prc_Audit @AuditId = @AuditId,@AuditMode = 2,@Options = @Options

end  
end try  
begin catch

   if  (@tran < @@TRANCOUNT) 
      rollback tran;

   declare @msg nvarchar(500)  
   set @msg = error_message()
   set @Err = error_number()
  
   --if (@AuditId is not null) 
   --   exec <dstdb>.dbo.prc_Audit @AuditId = @AuditId,@AuditMode = 2,@Err = @Err,@Options = @Options
   raiserror (@msg,11,17) 
end catch  
     '  

--dst only has pk/spk columns (no need for update)
   if exists (select 1 from #dstcol where spk = 0 and has_src = 1)
      set @query = replace(@query,'--1','')


--<type2checksum>
   set @sql1 = ''
   set @sql2 = ''
   select @sql1 = @sql1 + ',src.' + quotename([src_name]) 
       ,@sql2 = @sql2 + ',dst.' + quotename([name])  
    from  #dstcol where [has_src] = 1 and [is_type2] = 1
      
   if (len(@sql1) > 0)
   begin
	   set @sql1 = right(@sql1,len(@sql1) -1)
	   set @sql2 = right(@sql2,len(@sql2) -1)
	   set @sql1 = ' and binary_checksum(' + @sql1 + ') <> binary_checksum(' + @sql2 + ')'
	   set @query = replace(@query,'<type2checksum>',@sql1)
   end

   end



--<performanceindex>
   set @sql1 = ''
   if (@is_tbl = 1 and not exists(select 1 from #srccol where [spk] > 0))
   begin
      select @sql1 = @sql1 + ',' + quotename([src_name])
        from  #dstcol where [spk] > 0 and [is_type2] = 0
        order by [spk]
      
	  select @sql1 = 'create unique clustered index [uq_spk_' + parsename(@src,1) + '] on <src>(' + right(@sql1,len(@sql1) -1) +')'
   end

   set @query = replace(@query,'<performanceindex>',@sql1)


--<type1checksum> option
   set @sql1 = ''
   set @sql2 = ''
   if (@check = 1)
   begin
      select @sql1 = @sql1 + ',src.' + quotename([src_name]) 
            ,@sql2 = @sql2 + ',dst.' + quotename([name])  
      from  #dstcol where [has_src] = 1 and [spk] = 0 --and [is_type2] = 0
      
      if (len(@sql1) > 0)
	  begin
		  set @sql1 = right(@sql1,len(@sql1) -1)
		  set @sql2 = right(@sql2,len(@sql2) -1)
		  set @sql1 = ' and (binary_checksum(' + @sql1 + ') <> binary_checksum(' + @sql2 + ')'
					+ case when @ActionCol is not null then ' or dst.' + @ActionCol + ' = 3' else '' end + ')'
      end          
   end
   set @query = replace(@query,'<type1checksum>',@sql1)

--<joinlist>
   set @sql1 = ''
   select @sql1 = @sql1 + ' and src.' + quotename([name]) + ' = dst.' + quotename([src_name])
     from  #dstcol where [spk] > 0 and [is_type2] = 0

   set @sql1 = right(@sql1,len(@sql1) -4)
   set @query = replace(@query,'<joinlist>',@sql1)


--<updatelist>
   set @sql1 = case when @AuditCol is not null then ',dst.' + @AuditCol + ' = @AuditId' else '' end
             + case when @ActionCol is not null then ',dst.' + @ActionCol + ' = case dst.' + @ActionCol + ' when 3 then 1 else 2 end' else '' end  --insert if deleted else update
   select @sql1 = @sql1 + ',dst.' + quotename([name]) + ' = src.' + quotename([src_name]) 
         ,@sql2 = @sql2 + ',' + quotename([name])  
   from  #dstcol where [has_src] = 1 and [spk] = 0 --and [is_type2] = 0

   
   if (len(@sql1) > 0)
   begin
	   set @sql1 = right(@sql1,len(@sql1) -1)
	   set @query = replace(@query,'<updatelist>',@sql1)
   end
end

--<selectlist>
--<dstlist>
set @sql1 = case when @AuditCol is not null then ',@AuditId' else '' end
          + case when @ActionCol is not null then ',1' else '' end  --insert
          + case when @is_type2 = 1 then ',@dt,null' else '' end 
set @sql2 = case when @AuditCol is not null then ',' + @AuditCol else '' end
          + case when @ActionCol is not null then ',' + @ActionCol else '' end
          + case when @is_type2 = 1 then ',' + @RecordStartCol + ',' + @RecordEndCol else '' end
select @sql1 = @sql1 + ',' + quotename([src_name])  
      ,@sql2 = @sql2 + ',' + quotename([name])  
from  #dstcol where [has_src] = 1 

set @sql1 = right(@sql1, len(@sql1)-1) -- remove leading comma
set @sql2 = right(@sql2, len(@sql2)-1) -- remove leading comma  

set @query = replace(@query, '<selectlist>', @sql1)  
set @query = replace(@query, '<dstlist>', @sql2)  

--<Identity>
if exists(select 1 from  #dstcol where [is_ident] = 1 and [has_src] = 1) -- and [pk] = 0
begin
   set @query = replace(@query, '<IdentityOn>', 'set identity_insert <dst> on;')  
   set @query = replace(@query, '<IdentityOff>', 'set identity_insert <dst> off;')  
end
else
begin
   set @query = replace(@query, '<IdentityOn>', '')  
   set @query = replace(@query, '<IdentityOff>', '')  
end

--<src>  
--<dst>  
--<dstdb>  
set @query = replace(@query, '<dst>', @dst)  
set @query = replace(@query, '<src>', @src)  
set @query = replace(@query, '<dstdb>.', @dstdb)  
  
--<op>
set @sql1 = case when @reload = 1 then 'RELOAD'
               when @append = 1 then 'APPEND'
			   when @is_type2 = 1 then 'MERGE_T2'
               else 'MERGE_T1'
			 end
set @query = replace(@query, '<op>', @sql1)  

if (@debug = 1)  
begin  
  print @query  
end                 

exec sp_executesql @query,N'@RunID int,@Options varchar(255)',@RunID = @RunID,@Options = @Options

end try  
begin catch  
   if @@trancount > @tran  
      rollback tran  
  
   set @Proc = ERROR_PROCEDURE()  
   set @Msg = ERROR_MESSAGE()  
   set @Err = ERROR_NUMBER()  
   raiserror ('ERROR: PROC %s, MSG: %s',11,17,@Proc,@Msg)   
end catch  
  
   return @err  
end
;
GO
/*
Post-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/
GO

GO
DECLARE @VarDecimalSupported AS BIT;

SELECT @VarDecimalSupported = 0;

IF ((ServerProperty(N'EngineEdition') = 3)
    AND (((@@microsoftversion / power(2, 24) = 9)
          AND (@@microsoftversion & 0xffff >= 3024))
         OR ((@@microsoftversion / power(2, 24) = 10)
             AND (@@microsoftversion & 0xffff >= 1600))))
    SELECT @VarDecimalSupported = 1;

IF (@VarDecimalSupported > 0)
    BEGIN
        EXECUTE sp_db_vardecimal_storage_format N'$(DatabaseName)', 'ON';
    END


GO
PRINT N'Update complete.';


GO
