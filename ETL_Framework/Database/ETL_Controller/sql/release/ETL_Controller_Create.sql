/*
Deployment script for ETL_Controller

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "ETL_Controller"
:setvar DefaultFilePrefix "ETL_Controller"
:setvar DefaultDataPath ""
:setvar DefaultLogPath ""

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [master];


GO
PRINT N'Creating $(DatabaseName)...'
GO
CREATE DATABASE [$(DatabaseName)] COLLATE SQL_Latin1_General_CP1_CI_AS
GO
DECLARE  @job_state INT = 0;
DECLARE  @index INT = 0;
DECLARE @EscapedDBNameLiteral sysname = N'$(DatabaseName)'
WAITFOR DELAY '00:00:30';
WHILE (@index < 60) 
BEGIN
	SET @job_state = ISNULL( (SELECT SUM (result)  FROM (
		SELECT TOP 1 [state] AS result
		FROM sys.dm_operation_status WHERE resource_type = 0 
		AND operation = 'CREATE DATABASE' AND major_resource_id = @EscapedDBNameLiteral AND [state] = 2
		ORDER BY start_time DESC
		) r), -1);

	SET @index = @index + 1;

	IF @job_state = 0 /* pending */ OR @job_state = 1 /* in progress */ OR @job_state = -1 /* job not found */ OR (SELECT [state] FROM sys.databases WHERE name = @EscapedDBNameLiteral) <> 0
		WAITFOR DELAY '00:00:30';
	ELSE 
    	BREAK;
END
GO
USE [$(DatabaseName)];


GO
USE [$(DatabaseName)];


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                NUMERIC_ROUNDABORT OFF,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT OFF,
                CURSOR_CLOSE_ON_COMMIT OFF,
                AUTO_CREATE_STATISTICS ON,
                AUTO_SHRINK OFF,
                AUTO_UPDATE_STATISTICS ON,
                RECURSIVE_TRIGGERS OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ALLOW_SNAPSHOT_ISOLATION OFF;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_UPDATE_STATISTICS_ASYNC OFF,
                DATE_CORRELATION_OPTIMIZATION OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CREATE_STATISTICS ON(INCREMENTAL = OFF) 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE (QUERY_CAPTURE_MODE = AUTO, OPERATION_MODE = READ_WRITE, DATA_FLUSH_INTERVAL_SECONDS = 900, INTERVAL_LENGTH_MINUTES = 60, MAX_PLANS_PER_QUERY = 200, CLEANUP_POLICY = (STALE_QUERY_THRESHOLD_DAYS = 30), MAX_STORAGE_SIZE_MB = 100) 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE SCOPED CONFIGURATION SET MAXDOP = 0;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET MAXDOP = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET LEGACY_CARDINALITY_ESTIMATION = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET LEGACY_CARDINALITY_ESTIMATION = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET PARAMETER_SNIFFING = ON;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET PARAMETER_SNIFFING = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET QUERY_OPTIMIZER_HOTFIXES = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET QUERY_OPTIMIZER_HOTFIXES = PRIMARY;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET TEMPORAL_HISTORY_RETENTION ON 
            WITH ROLLBACK IMMEDIATE;
    END


GO
/*
 Pre-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be executed before the build script.	
 Use SQLCMD syntax to include a file in the pre-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the pre-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/
GO

GO
PRINT N'Creating [dbo].[ETLClient_DE]...';


GO
CREATE XML SCHEMA COLLECTION [dbo].[ETLClient_DE]
    AS N'<?xml version="1.0"?>
<xsd:schema xmlns="DeltaExtractor.XSD" xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="DeltaExtractor.XSD"  elementFormDefault="qualified">
	<!-- Guid Pattern definition -->
	<xsd:simpleType name="GUID">
		<xsd:restriction base="xsd:string">
			<xsd:pattern value="[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}" />
		</xsd:restriction>
	</xsd:simpleType>
  
	<!-- List of possible actions -->
	<xsd:simpleType name="Actions">
		<xsd:restriction base="xsd:string">
      <xsd:enumeration value="MoveData" />
    </xsd:restriction>
	</xsd:simpleType>


  <!-- Sharepoint Destination Action -->
  <xsd:simpleType name="SPAction">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="Modification" />
      <xsd:enumeration value="Deletion" />
    </xsd:restriction>
  </xsd:simpleType>

  <!-- AccessMode -->
  <xsd:simpleType name="AccessMode">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="OpenRowset" />
      <xsd:enumeration value="OpenRowset From Variable" />
      <xsd:enumeration value="SQL Command" />
      <xsd:enumeration value="SQL Command From Variable" />
      <xsd:enumeration value="Table or view" />
      <xsd:enumeration value="Table Name" />
      <xsd:enumeration value="OpenRowset Using FastLoad" />
      <xsd:enumeration value="OpenRowset Using FastLoad From Variable" />
    </xsd:restriction>
  </xsd:simpleType>

  <!-- BindNumericMode -->
  <xsd:simpleType name="NumericMode">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="Char" />
      <xsd:enumeration value="Numeric" />
    </xsd:restriction>
  </xsd:simpleType>

  <!-- BindCharMode -->
  <xsd:simpleType name="CharMode">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="ANSI" />
      <xsd:enumeration value="Unicode" />
    </xsd:restriction>
  </xsd:simpleType>

  <!-- FetchMode -->
  <xsd:simpleType name="FetchMode">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="Batch" />
      <xsd:enumeration value="Row by row" />
    </xsd:restriction>
  </xsd:simpleType>

  <xsd:simpleType name="CompressionMethod">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="GZIP" />
      <xsd:enumeration value="XPRESS" />
      <xsd:enumeration value="ZIP" />
      <xsd:enumeration value="NONE" />
    </xsd:restriction>
  </xsd:simpleType>
  
	<xsd:simpleType name="ExcelVersion">
		<xsd:restriction base="xsd:string">
      <xsd:enumeration value="Microsoft Excel 97-2003" />
      <xsd:enumeration value="Microsoft Excel 2007" />
      <xsd:enumeration value="Microsoft Excel 2010" />
      <xsd:enumeration value="Microsoft Excel 2013" />
    </xsd:restriction>
	</xsd:simpleType>

  <xsd:simpleType name="FlatFileFormat">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="Delimited" />
      <xsd:enumeration value="FixedWidth" />
      <xsd:enumeration value="RaggedRight" />
    </xsd:restriction>
  </xsd:simpleType>

  <xsd:simpleType name="QueryType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="SQL" />
      <xsd:enumeration value="MDX" />
      <xsd:enumeration value="XMLA" />
    </xsd:restriction>
  </xsd:simpleType>

  <xsd:simpleType name="PartitionFunction">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="UPS" />
      <xsd:enumeration value="SRC" />
      <xsd:enumeration value="NONE" />
    </xsd:restriction>
  </xsd:simpleType>

  <!-- Partition block properties -->
  <xsd:complexType name="PartitionBlock">
    <xsd:sequence>
      <xsd:element name="Input" type="xsd:string" maxOccurs="1" minOccurs="0" />
      <xsd:element name="Output" type="xsd:string" maxOccurs="1" minOccurs="0" />
    </xsd:sequence>
    <xsd:attribute name="Function" type="PartitionFunction" use="required"/>
  </xsd:complexType>


  <!-- Partition range properties -->
  <xsd:complexType name="PartitionRange">
    <xsd:attribute name="Min" type="xsd:int" use="optional"/>
    <xsd:attribute name="Max" type="xsd:int" use="optional"/>
  </xsd:complexType>


  <!-- ODataSource -->
  <xsd:complexType name="ODataSource">
    <xsd:sequence>
      <xsd:element name="ConnectionString" type="xsd:string" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="CustomProperties">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="DefaultStringLength" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="CollectionName" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="Query" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="ResourcePath" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="UseResourcePath" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>

  <!-- SharePointSource -->
  <xsd:complexType name="SharePointSource">
    <xsd:sequence>
      <xsd:element name="ConnectionString" type="xsd:string" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="CustomProperties">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="BatchSize" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="CamlQuery" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="IncludeFolders" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="IsRecursive" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="SharePointCulture" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="SiteListName" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="SiteListViewName" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="SiteUrl" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="DecodeLookupColumns" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="IncludeHiddenColumns" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="UseConnectionManager" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>

  <!-- SharePointDestination -->
  <xsd:complexType name="SharePointDestination">
    <xsd:sequence>
      <xsd:element name="ConnectionString" type="xsd:string" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="CustomProperties">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="BatchSize" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="BatchType" type="SPAction" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="SharePointCulture" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="SiteListName" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="SiteListViewName" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="SiteUrl" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="UseConnectionManager" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>

  <!-- FlatFileSource -->
  <xsd:complexType name="FlatFileSource">
    <xsd:sequence>
      <xsd:element name="CustomProperties">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="CodePage" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="ConnectionString" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="DataRowsToSkip" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="Format" type="FlatFileFormat" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="ColumnNamesInFirstDataRow" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="HeaderRowDelimiter" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="HeaderRowsToSkip" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="TextQualifier" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="Unicode" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="ColumnDelimiter" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="RecordDelimiter" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="FileNameColumnName" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="RetainNulls" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="DataCompression" type="CompressionMethod" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="StagingAreaTableName" type="xsd:string" minOccurs="0" maxOccurs="1"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>

  <!-- FlatFileDestination -->
  <xsd:complexType name="FlatFileDestination">
    <xsd:sequence>
      <xsd:element name="PartitionRange" type="PartitionRange" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="CustomProperties">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="CodePage" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="ConnectionString" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="DataRowsToSkip" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="Format" type="FlatFileFormat" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="ColumnNamesInFirstDataRow" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="HeaderRowDelimiter" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="HeaderRowsToSkip" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="TextQualifier" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="Unicode" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="ColumnDelimiter" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="RecordDelimiter" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="Header" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="Override" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="DataCompression" type="CompressionMethod" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="StagingAreaTableName" type="xsd:string" minOccurs="0" maxOccurs="1"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>


  <!-- ExcelSource -->
  <xsd:complexType name="ExcelSource">
    <xsd:sequence>
      <xsd:element name="ConnectionString" type="xsd:string" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="FilePath" type="xsd:string" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="Header" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="ExcelVersion" type="ExcelVersion" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="CustomProperties">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="AccessMode" type="AccessMode" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="OpenRowset" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="SqlCommand" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="CommandTimeout" type="xsd:int" minOccurs="0" maxOccurs="1"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="DataCompression" type="CompressionMethod" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="StagingAreaTableName" type="xsd:string" minOccurs="0" maxOccurs="1"/>
    </xsd:sequence>
  </xsd:complexType>

  <!-- ExcelDestination -->
  <xsd:complexType name="ExcelDestination">
    <xsd:sequence>
      <xsd:element name="ConnectionString" type="xsd:string" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="FilePath" type="xsd:string" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="Header" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="ExcelVersion" type="ExcelVersion" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="PartitionRange" type="PartitionRange" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="CustomProperties">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="AccessMode" type="AccessMode" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="OpenRowset" type="xsd:string" minOccurs="1" maxOccurs="1"/>
            <xsd:element name="CommandTimeout" type="xsd:int" minOccurs="1" maxOccurs="1"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="DataCompression" type="CompressionMethod" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="StagingAreaTableName" type="xsd:string" minOccurs="0" maxOccurs="1"/>
    </xsd:sequence>
  </xsd:complexType>


  <!-- Database Connection -->
	<xsd:complexType name="DBConnection">
    <xsd:sequence>
      <xsd:choice>
        <xsd:sequence>
          <xsd:element name="Server" type="xsd:string" maxOccurs="1" minOccurs="0" />
          <xsd:element name="Database" type="xsd:string" maxOccurs="1" minOccurs="0" />
        </xsd:sequence>
        <xsd:sequence>
          <xsd:element name="ConnectionString" type="xsd:string" maxOccurs="1" minOccurs="0" />
          <xsd:element name="Qualifier" type="xsd:string" maxOccurs="1" minOccurs="0" />
        </xsd:sequence>
      </xsd:choice>
      <xsd:element name="QueryTimeout" type="xsd:integer" maxOccurs="1" minOccurs="0" />
    </xsd:sequence>
	</xsd:complexType>

	<!-- OLEDB Source -->
	<xsd:complexType name="OleDbSource">
		<xsd:sequence>
			<xsd:element name="DBConnection" type="DBConnection" minOccurs="1" maxOccurs="1"/>
      <xsd:element name="QueryType" type="QueryType" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="CustomProperties">
				<xsd:complexType>
					<xsd:sequence>
						<xsd:element name="AccessMode" type="AccessMode" minOccurs="0" maxOccurs="1"/>
						<xsd:element name="SqlCommand" type="xsd:string" minOccurs="1" maxOccurs="1"/>
						<xsd:element name="CommandTimeout" type="xsd:int" minOccurs="0" maxOccurs="1"/>
					</xsd:sequence>
				</xsd:complexType>
			</xsd:element>
		</xsd:sequence>
	</xsd:complexType>

  <!-- ADONET Source -->
  <xsd:complexType name="AdoNetSource">
    <xsd:sequence>
      <xsd:element name="DBConnection" type="DBConnection" minOccurs="1" maxOccurs="1"/>
      <xsd:element name="CustomProperties">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="AccessMode" type="AccessMode" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="SqlCommand" type="xsd:string" minOccurs="1" maxOccurs="1"/>
            <xsd:element name="CommandTimeout" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="AllowImplicitStringConversion" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>

  <!-- ODBC Source -->
  <xsd:complexType name="OdbcSource">
    <xsd:sequence>
      <xsd:element name="DBConnection" type="DBConnection" minOccurs="1" maxOccurs="1"/>
      <xsd:element name="CustomProperties">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="AccessMode" type="AccessMode" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="SqlCommand" type="xsd:string" minOccurs="1" maxOccurs="1"/>
            <xsd:element name="StatementTimeout" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="BatchSize" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="LobChunkSize" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="ExposeCharColumnsAsUnicode" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="FetchMethod" type="FetchMode" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="DefaultCodePage" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="BindNumericAs" type="NumericMode" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="BindCharColumnsAs" type="CharMode" minOccurs="0" maxOccurs="1"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>


  <!-- Staging block properties -->
  <xsd:complexType name="StagingBlock">
    <xsd:sequence>
      <xsd:element name="StagingTableName" type="xsd:string" maxOccurs="1" minOccurs="0" />
      <xsd:element name="StagingTablePrepare" type="xsd:string" maxOccurs="1" minOccurs="0" />
      <xsd:element name="StagingTableUpload" type="xsd:string" maxOccurs="1" minOccurs="0" />
      <xsd:element name="UserOptions" type="xsd:string" minOccurs="0" maxOccurs="1"/>
    </xsd:sequence>
    <xsd:attribute name="Staging" type="xsd:boolean" use="required"/>
  </xsd:complexType>


  <!-- OLEDB Destination -->
	<xsd:complexType name="OleDbDestination">
		<xsd:sequence>
			<xsd:element name="DBConnection" type="DBConnection" minOccurs="1" maxOccurs="1"/>
			<xsd:element name="StagingBlock" type="StagingBlock" maxOccurs="1" minOccurs="0" />
      <xsd:element name="PartitionRange" type="PartitionRange" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="CustomProperties">
				<xsd:complexType>
					<xsd:sequence>
						<xsd:element name="AccessMode" type="AccessMode" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="OpenRowset" type="xsd:string" minOccurs="1" maxOccurs="1"/>
            <xsd:element name="FastLoadOptions" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="FastLoadKeepIdentity" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="FastLoadKeepNulls" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="FastLoadMaxInsertCommitSize" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="CommandTimeout" type="xsd:int" minOccurs="0" maxOccurs="1"/>
					</xsd:sequence>
				</xsd:complexType>
			</xsd:element>
		</xsd:sequence>
	</xsd:complexType>

  <!-- ADONET Destination -->
  <xsd:complexType name="AdoNetDestination">
    <xsd:sequence>
      <xsd:element name="DBConnection" type="DBConnection" minOccurs="1" maxOccurs="1"/>
      <xsd:element name="StagingBlock" type="StagingBlock" maxOccurs="1" minOccurs="0" />
      <xsd:element name="PartitionRange" type="PartitionRange" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="CustomProperties">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="TableOrViewName" type="xsd:string" minOccurs="1" maxOccurs="1"/>
            <xsd:element name="BatchSize" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="UseBulkInsertWhenPossible" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="CommandTimeout" type="xsd:int" minOccurs="0" maxOccurs="1"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>

  <!-- ODBC Destination -->
  <xsd:complexType name="OdbcDestination">
    <xsd:sequence>
      <xsd:element name="DBConnection" type="DBConnection" minOccurs="1" maxOccurs="1"/>
      <xsd:element name="StagingBlock" type="StagingBlock" maxOccurs="1" minOccurs="0" />
      <xsd:element name="PartitionRange" type="PartitionRange" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="CustomProperties">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="InsertMethod" type="FetchMode" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="BindCharColumnsAs" type="CharMode" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="BindNumericAs" type="NumericMode" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="TableName" type="xsd:string" minOccurs="1" maxOccurs="1"/>
            <xsd:element name="BatchSize" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="TransactionSize" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="LobChunkSize" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="StatementTimeout" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="DefaultCodePage" type="xsd:int" minOccurs="0" maxOccurs="1"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>

  <!-- SQLBULK Destination -->
  <xsd:complexType name="SqlBulkDestination">
    <xsd:sequence>
      <xsd:element name="DBConnection" type="DBConnection" minOccurs="1" maxOccurs="1"/>
      <xsd:element name="StagingBlock" type="StagingBlock" maxOccurs="1" minOccurs="0" />
      <xsd:element name="PartitionRange" type="PartitionRange" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="CustomProperties">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="DefaultCodePage" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="AlwaysUseDefaultCodePage" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="BulkInsertTableName" type="xsd:string" minOccurs="1" maxOccurs="1"/>
            <xsd:element name="BulkInsertCheckConstraints" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="BulkInsertFirstRow" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="BulkInsertFireTriggers" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="BulkInsertKeepIdentity" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="BulkInsertKeepNulls" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="BulkInsertLastRow" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="BulkInsertMaxErrors" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="BulkInsertOrder" type="xsd:string" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="BulkInsertTablock" type="xsd:boolean" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="Timeout" type="xsd:int" minOccurs="0" maxOccurs="1"/>
            <xsd:element name="MaxInsertCommitSize" type="xsd:int" minOccurs="0" maxOccurs="1"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>


  <!-- Complex type for destinations -->
	<xsd:complexType name="DataDestination">
    <xsd:sequence>
      <xsd:element name="OleDbDestination" type="OleDbDestination" minOccurs="0" maxOccurs="unbounded"/>
      <xsd:element name="FlatFileDestination" type="FlatFileDestination" minOccurs="0" maxOccurs="unbounded"/>
      <xsd:element name="ExcelDestination" type="ExcelDestination" minOccurs="0" maxOccurs="unbounded"/>
      <xsd:element name="SharePointDestination" type="SharePointDestination" minOccurs="0" maxOccurs="unbounded"/>
      <xsd:element name="AdoNetDestination" type="AdoNetDestination" minOccurs="0" maxOccurs="unbounded"/>
      <xsd:element name="OdbcDestination" type="OdbcDestination" minOccurs="0" maxOccurs="unbounded"/>
      <xsd:element name="SqlBulkDestination" type="SqlBulkDestination" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
	</xsd:complexType>


	<!-- Complex type for sources -->
	<xsd:complexType name="DataSource">
	 <xsd:choice>
	  <xsd:sequence>
	    <xsd:element name="OleDbSource" type="OleDbSource" minOccurs="0" maxOccurs="1"/>
	  </xsd:sequence>
	  <xsd:sequence>
        <xsd:element name="FlatFileSource" type="FlatFileSource" minOccurs="0" maxOccurs="1" />
      </xsd:sequence>
      <xsd:sequence>
        <xsd:element name="ExcelSource" type="ExcelSource" minOccurs="0" maxOccurs="1" />
      </xsd:sequence>
      <xsd:sequence>
        <xsd:element name="SharePointSource" type="SharePointSource" minOccurs="0" maxOccurs="1" />
      </xsd:sequence>
      <xsd:sequence>
        <xsd:element name="AdoNetSource" type="AdoNetSource" minOccurs="0" maxOccurs="1"/>
      </xsd:sequence>
      <xsd:sequence>
        <xsd:element name="OdbcSource" type="OdbcSource" minOccurs="0" maxOccurs="1"/>
      </xsd:sequence>
      <xsd:sequence>
        <xsd:element name="ODataSource" type="ODataSource" minOccurs="0" maxOccurs="1"/>
      </xsd:sequence>
    </xsd:choice>
  </xsd:complexType>


	<xsd:complexType name="MoveData">
		<xsd:sequence maxOccurs="1" minOccurs="1">
			<xsd:element name="DataSource" type="DataSource" maxOccurs="1" minOccurs="1" />
			<xsd:element name="DataDestination" type="DataDestination" minOccurs="1" maxOccurs="1" />
			<xsd:element name="StagingAreaRoot" type="xsd:string" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="Partition" type="PartitionBlock" maxOccurs="1" minOccurs="0" />
      <xsd:element name="SavePackage" maxOccurs="1" minOccurs="0">
        <xsd:complexType>
          <xsd:simpleContent>
            <xsd:extension base="xsd:string">
              <xsd:attribute name="Save" type="xsd:boolean"  use="required"/>
              <xsd:attribute name="Load" type="xsd:boolean"  use="optional"/>
            </xsd:extension>
          </xsd:simpleContent>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
	</xsd:complexType>

  <xsd:complexType name="RunPackage">
    <xsd:sequence maxOccurs="1" minOccurs="1">
      <xsd:element name="File" type="xsd:string" maxOccurs="1" minOccurs="1" />
    </xsd:sequence>
  </xsd:complexType>

  <!-- ETL_Controller Header -->
  <xsd:complexType name="ETLHeader">
    <xsd:sequence maxOccurs="1" minOccurs="1">
      <xsd:element name="BatchID" type="xsd:int" maxOccurs="1" minOccurs="1" />
      <xsd:element name="StepID" type="xsd:int" maxOccurs="1" minOccurs="1" />
      <xsd:element name="RunID" type="xsd:int" maxOccurs="1" minOccurs="1" />
      <xsd:element name="Controller" type="DBConnection" maxOccurs="1" minOccurs="1" />
      <xsd:element name="Node" type="DBConnection" maxOccurs="1" minOccurs="0" />
      <xsd:element name="Conversation" type="GUID" maxOccurs="1" minOccurs="0" />
      <xsd:element name="ConversationGrp" type="GUID" maxOccurs="1" minOccurs="0" />
      <xsd:element name="Options" type="xsd:int" maxOccurs="1" minOccurs="0" />
    </xsd:sequence>
  </xsd:complexType>

  <!-- BIAS Workflow header -->
  <xsd:complexType name="BIASHeader">
    <xsd:complexContent>
      <xsd:restriction base="xsd:anyType">
        <xsd:sequence />
        <xsd:attribute name="RunID" type="xsd:int" use="required" />
        <xsd:attribute name="UserOptions" type="xsd:string" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>


  <!-- Parameters to be passed -->
	<xsd:complexType name="Parameters">
		<xsd:sequence minOccurs="1" maxOccurs="1">
      <xsd:choice>
        <xsd:sequence>
          <xsd:element name="ETLHeader" type="ETLHeader" maxOccurs="1" minOccurs="0" />
        </xsd:sequence>
        <xsd:sequence>
          <xsd:element name="BIASHeader" type="BIASHeader" maxOccurs="1" minOccurs="0" />
        </xsd:sequence>
      </xsd:choice>
      <xsd:choice>
				<xsd:sequence>
					<xsd:element name="MoveData" type="MoveData"  maxOccurs="1" minOccurs="0"/>
				</xsd:sequence>
        <xsd:sequence>
          <xsd:element name="RunPackage" type="RunPackage"  maxOccurs="1" minOccurs="0"/>
        </xsd:sequence>
      </xsd:choice>
    </xsd:sequence>
	</xsd:complexType>
	<xsd:element name="Parameters" type="Parameters" />
</xsd:schema>';


GO
PRINT N'Creating [dbo].[ETLController]...';


GO
CREATE XML SCHEMA COLLECTION [dbo].[ETLController]
    AS N'<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:t="ETLController.XSD" targetNamespace="ETLController.XSD" elementFormDefault="qualified">
  <xsd:element name="Attributes" type="t:Attributes" />
  <xsd:element name="Context" type="t:Context" />
  <xsd:element name="Counters">
    <xsd:complexType>
      <xsd:complexContent>
        <xsd:restriction base="xsd:anyType">
          <xsd:sequence>
            <xsd:element name="Counter" minOccurs="0" maxOccurs="unbounded">
              <xsd:complexType>
                <xsd:simpleContent>
                  <xsd:extension base="xsd:string">
                    <xsd:attribute name="Name" type="xsd:string" use="required" />
                    <xsd:attribute name="RunID" type="xsd:int" use="required" />
                  </xsd:extension>
                </xsd:simpleContent>
              </xsd:complexType>
            </xsd:element>
          </xsd:sequence>
          <xsd:attribute name="BatchID" type="xsd:int" use="required" />
          <xsd:attribute name="StepID" type="xsd:int" />
          <xsd:attribute name="ConstID" type="xsd:int" />
          <xsd:attribute name="RunID" type="xsd:int" use="required" />
        </xsd:restriction>
      </xsd:complexContent>
    </xsd:complexType>
  </xsd:element>
  <xsd:element name="Header" type="t:Header" />
  <xsd:element name="ProcessInfo">
    <xsd:complexType>
      <xsd:complexContent>
        <xsd:restriction base="xsd:anyType">
          <xsd:sequence>
            <xsd:element name="Header" type="t:Header" />
            <xsd:element name="Message">
              <xsd:complexType>
                <xsd:simpleContent>
                  <xsd:extension base="xsd:string">
                    <xsd:attribute name="Error" type="xsd:int" />
                  </xsd:extension>
                </xsd:simpleContent>
              </xsd:complexType>
            </xsd:element>
          </xsd:sequence>
          <xsd:attribute name="Error" type="xsd:int" />
        </xsd:restriction>
      </xsd:complexContent>
    </xsd:complexType>
  </xsd:element>
  <xsd:element name="ProcessReceipt">
    <xsd:complexType>
      <xsd:complexContent>
        <xsd:restriction base="xsd:anyType">
          <xsd:sequence>
            <xsd:element name="Header" type="t:Header" />
            <xsd:element name="Status">
              <xsd:complexType>
                <xsd:complexContent>
                  <xsd:restriction base="xsd:anyType">
                    <xsd:sequence>
                      <xsd:element name="msg" type="xsd:string" minOccurs="0" />
                    </xsd:sequence>
                    <xsd:attribute name="StatusID" type="xsd:int" use="required" />
                    <xsd:attribute name="Error" type="xsd:int" use="required" />
                  </xsd:restriction>
                </xsd:complexContent>
              </xsd:complexType>
            </xsd:element>
          </xsd:sequence>
        </xsd:restriction>
      </xsd:complexContent>
    </xsd:complexType>
  </xsd:element>
  <xsd:element name="ProcessRequest">
    <xsd:complexType>
      <xsd:complexContent>
        <xsd:restriction base="xsd:anyType">
          <xsd:sequence>
            <xsd:element name="Header" type="t:Header" />
            <xsd:element name="SrcConversation" type="xsd:string" minOccurs="0" />
            <xsd:element name="SrcConversationGrp" type="xsd:string" minOccurs="0" />
            <xsd:element name="DstConversation" type="xsd:string" minOccurs="0" />
            <xsd:element name="DstConversationGrp" type="xsd:string" minOccurs="0" />
            <xsd:element name="Context" type="t:Context" minOccurs="0" />
          </xsd:sequence>
        </xsd:restriction>
      </xsd:complexContent>
    </xsd:complexType>
  </xsd:element>
  <xsd:complexType name="Attributes">
    <xsd:complexContent>
      <xsd:restriction base="xsd:anyType">
        <xsd:sequence>
          <xsd:element name="Attribute" minOccurs="0" maxOccurs="unbounded">
            <xsd:complexType>
              <xsd:simpleContent>
                <xsd:extension base="xsd:string">
                  <xsd:attribute name="Name" type="xsd:string" use="required" />
                </xsd:extension>
              </xsd:simpleContent>
            </xsd:complexType>
          </xsd:element>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="Constraints">
    <xsd:complexContent>
      <xsd:restriction base="xsd:anyType">
        <xsd:sequence>
          <xsd:element name="Constraint" minOccurs="0" maxOccurs="unbounded">
            <xsd:complexType>
              <xsd:complexContent>
                <xsd:restriction base="xsd:anyType">
                  <xsd:sequence>
                    <xsd:element name="Process" type="t:Process" />
                    <xsd:element name="Attributes" type="t:Attributes" minOccurs="0" maxOccurs="unbounded" />
                  </xsd:sequence>
                  <xsd:attribute name="ConstID" type="xsd:int" use="required" />
                  <xsd:attribute name="ConstOrder" type="xsd:string" />
                  <xsd:attribute name="WaitPeriod" type="xsd:int" />
                  <xsd:attribute name="Disabled" type="xsd:int" />
                  <xsd:attribute name="Ping" type="xsd:int" />
                </xsd:restriction>
              </xsd:complexContent>
            </xsd:complexType>
          </xsd:element>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="Context">
    <xsd:complexContent>
      <xsd:restriction base="xsd:anyType">
        <xsd:sequence>
          <xsd:element name="OnSuccess" type="t:Process" minOccurs="0" />
          <xsd:element name="OnFailure" type="t:Process" minOccurs="0" />
          <xsd:element name="Attributes" type="t:Attributes" minOccurs="0" maxOccurs="unbounded" />
          <xsd:element name="Constraints" type="t:Constraints" minOccurs="0" maxOccurs="unbounded" />
          <xsd:element name="Steps" minOccurs="0">
            <xsd:complexType>
              <xsd:complexContent>
                <xsd:restriction base="xsd:anyType">
                  <xsd:sequence>
                    <xsd:element name="Step" minOccurs="0" maxOccurs="unbounded">
                      <xsd:complexType>
                        <xsd:complexContent>
                          <xsd:restriction base="xsd:anyType">
                            <xsd:sequence>
                              <xsd:element name="Process" type="t:Process" />
                              <xsd:element name="OnSuccess" type="t:Process" minOccurs="0" />
                              <xsd:element name="OnFailure" type="t:Process" minOccurs="0" />
                              <xsd:element name="Attributes" type="t:Attributes" minOccurs="0" maxOccurs="unbounded" />
                              <xsd:element name="Constraints" type="t:Constraints" minOccurs="0" maxOccurs="unbounded" />
                            </xsd:sequence>
                            <xsd:attribute name="StepID" type="xsd:int" use="required" />
                            <xsd:attribute name="StepName" type="xsd:string" />
                            <xsd:attribute name="StepDesc" type="xsd:string" />
                            <xsd:attribute name="StepOrder" type="xsd:string" />
                            <xsd:attribute name="IgnoreErr" type="xsd:int" />
                            <xsd:attribute name="Restart" type="xsd:int" />
                            <xsd:attribute name="Disabled" type="xsd:int" />
                            <xsd:attribute name="SeqGroup" type="xsd:string" />
                            <xsd:attribute name="PriGroup" type="xsd:string" />
                            <xsd:attribute name="Retry" type="xsd:int" />
                            <xsd:attribute name="Delay" type="xsd:int" />
                            <xsd:attribute name="LoopGroup" type="xsd:string" />
                            <xsd:attribute name="Timeout" type="xsd:int" />
                          </xsd:restriction>
                        </xsd:complexContent>
                      </xsd:complexType>
                    </xsd:element>
                  </xsd:sequence>
                </xsd:restriction>
              </xsd:complexContent>
            </xsd:complexType>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="BatchID" type="xsd:int" use="required" />
        <xsd:attribute name="BatchName" type="xsd:string" />
        <xsd:attribute name="BatchDesc" type="xsd:string" />
        <xsd:attribute name="IgnoreErr" type="xsd:int" />
        <xsd:attribute name="Restart" type="xsd:int" />
        <xsd:attribute name="Disabled" type="xsd:int" />
        <xsd:attribute name="MaxThread" type="xsd:int" />
        <xsd:attribute name="Timeout" type="xsd:int" />
        <xsd:attribute name="Lifetime" type="xsd:int" />
        <xsd:attribute name="Ping" type="xsd:int" />
        <xsd:attribute name="HistRet" type="xsd:int" />
        <xsd:attribute name="Retry" type="xsd:int" />
        <xsd:attribute name="Delay" type="xsd:int" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="Header">
    <xsd:complexContent>
      <xsd:restriction base="xsd:anyType">
        <xsd:sequence />
        <xsd:attribute name="BatchID" type="xsd:int" use="required" />
        <xsd:attribute name="StepID" type="xsd:int" />
        <xsd:attribute name="ConstID" type="xsd:int" />
        <xsd:attribute name="RunID" type="xsd:int" use="required" />
        <xsd:attribute name="Options" type="xsd:int" />
        <xsd:attribute name="Scope" type="xsd:int" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="Process">
    <xsd:complexContent>
      <xsd:restriction base="xsd:anyType">
        <xsd:sequence>
          <xsd:element name="Process" type="xsd:string" minOccurs="0" />
          <xsd:element name="Param" type="xsd:string" minOccurs="0" />
        </xsd:sequence>
        <xsd:attribute name="ProcessID" type="xsd:int" use="required" />
        <xsd:attribute name="ScopeID" type="xsd:int" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
</xsd:schema>';


GO
PRINT N'Creating [dbo].[ETLBatchRun]...';


GO
CREATE TABLE [dbo].[ETLBatchRun] (
    [RunID]      INT            IDENTITY (1, 1) NOT NULL,
    [BatchID]    INT            NOT NULL,
    [StatusDT]   DATETIME       NULL,
    [StatusID]   TINYINT        NULL,
    [Err]        INT            NULL,
    [StartTime]  DATETIME       NULL,
    [EndTime]    DATETIME       NULL,
    [ModifiedBY] NVARCHAR (100) NOT NULL,
    PRIMARY KEY CLUSTERED ([RunID] ASC),
    UNIQUE NONCLUSTERED ([BatchID] ASC, [RunID] ASC) ON [PRIMARY]
);


GO
PRINT N'Creating [dbo].[ETLProcess]...';


GO
CREATE TABLE [dbo].[ETLProcess] (
    [ProcessID] INT             NOT NULL,
    [Process]   [sysname]       NOT NULL,
    [Param]     NVARCHAR (2048) NULL,
    [ScopeID]   TINYINT         NULL,
    PRIMARY KEY CLUSTERED ([ProcessID] ASC)
);


GO
PRINT N'Creating [dbo].[ETLStep]...';


GO
CREATE TABLE [dbo].[ETLStep] (
    [StepID]      INT           NOT NULL,
    [BatchID]     INT           NOT NULL,
    [StepName]    VARCHAR (100) NOT NULL,
    [StepDesc]    VARCHAR (500) NULL,
    [StepProcID]  INT           NOT NULL,
    [OnSuccessID] INT           NULL,
    [OnFailureID] INT           NULL,
    [IgnoreErr]   TINYINT       NULL,
    [StepOrder]   VARCHAR (10)  NULL,
    [StatusDT]    DATETIME      NULL,
    [StatusID]    TINYINT       NULL,
    [Err]         INT           NULL,
    PRIMARY KEY CLUSTERED ([BatchID] ASC, [StepID] ASC),
    UNIQUE NONCLUSTERED ([StepName] ASC, [BatchID] ASC) ON [PRIMARY]
);


GO
PRINT N'Creating [dbo].[ETLStepAttribute]...';


GO
CREATE TABLE [dbo].[ETLStepAttribute] (
    [BatchID]        INT            NOT NULL,
    [StepID]         INT            NOT NULL,
    [AttributeName]  VARCHAR (100)  NOT NULL,
    [AttributeValue] VARCHAR (8000) NULL,
    PRIMARY KEY CLUSTERED ([BatchID] ASC, [StepID] ASC, [AttributeName] ASC)
);


GO
PRINT N'Creating [dbo].[ETLStepConstraint]...';


GO
CREATE TABLE [dbo].[ETLStepConstraint] (
    [ConstID]    INT          NOT NULL,
    [StepID]     INT          NOT NULL,
    [BatchID]    INT          NOT NULL,
    [ProcessID]  INT          NOT NULL,
    [ConstOrder] VARCHAR (10) NULL,
    [WaitPeriod] INT          NULL,
    PRIMARY KEY CLUSTERED ([BatchID] ASC, [StepID] ASC, [ConstID] ASC)
);


GO
PRINT N'Creating [dbo].[ETLStepConstraintAttribute]...';


GO
CREATE TABLE [dbo].[ETLStepConstraintAttribute] (
    [BatchID]        INT            NOT NULL,
    [StepID]         INT            NOT NULL,
    [ConstID]        INT            NOT NULL,
    [AttributeName]  VARCHAR (100)  NOT NULL,
    [AttributeValue] VARCHAR (8000) NULL,
    PRIMARY KEY CLUSTERED ([BatchID] ASC, [StepID] ASC, [ConstID] ASC, [AttributeName] ASC)
);


GO
PRINT N'Creating [dbo].[ETLStepRun]...';


GO
CREATE TABLE [dbo].[ETLStepRun] (
    [RunID]     INT          NOT NULL,
    [BatchID]   INT          NOT NULL,
    [StepID]    INT          NOT NULL,
    [StatusDT]  DATETIME     NULL,
    [StatusID]  TINYINT      NULL,
    [spid]      INT          NULL,
    [StepOrder] VARCHAR (10) NULL,
    [IgnoreErr] TINYINT      NULL,
    [Err]       INT          NULL,
    [StartTime] DATETIME     NULL,
    [EndTime]   DATETIME     NULL,
    [SeqGroup]  VARCHAR (10) NULL,
    [PriGroup]  VARCHAR (10) NULL,
    [SvcName]   [sysname]    NULL,
    PRIMARY KEY CLUSTERED ([RunID] ASC, [StepID] ASC),
    UNIQUE NONCLUSTERED ([BatchID] ASC, [StepID] ASC) ON [PRIMARY]
);


GO
PRINT N'Creating [dbo].[ETLStepRunCounter]...';


GO
CREATE TABLE [dbo].[ETLStepRunCounter] (
    [BatchID]      INT            NOT NULL,
    [StepID]       INT            NOT NULL,
    [RunID]        INT            NOT NULL,
    [CounterName]  VARCHAR (100)  NOT NULL,
    [CounterValue] VARCHAR (1000) NULL,
    [CreatedDTim]  SMALLDATETIME  NOT NULL,
    [ModifiedDTim] SMALLDATETIME  NOT NULL,
    PRIMARY KEY CLUSTERED ([RunID] ASC, [CounterName] ASC, [BatchID] ASC, [StepID] ASC)
);


GO
PRINT N'Creating [dbo].[ETLStepRunHistory]...';


GO
CREATE TABLE [dbo].[ETLStepRunHistory] (
    [RunID]     INT          NOT NULL,
    [BatchID]   INT          NOT NULL,
    [StepID]    INT          NOT NULL,
    [StatusDT]  DATETIME     NULL,
    [StatusID]  TINYINT      NULL,
    [spid]      INT          NULL,
    [StepOrder] VARCHAR (10) NULL,
    [IgnoreErr] TINYINT      NULL,
    [Err]       INT          NULL,
    [StartTime] DATETIME     NULL,
    [EndTime]   DATETIME     NULL,
    [SeqGroup]  VARCHAR (10) NULL,
    [PriGroup]  VARCHAR (10) NULL,
    [SvcName]   [sysname]    NULL,
    PRIMARY KEY CLUSTERED ([RunID] ASC, [BatchID] ASC, [StepID] ASC)
);


GO
PRINT N'Creating [dbo].[ETLStepRunHistoryLog]...';


GO
CREATE TABLE [dbo].[ETLStepRunHistoryLog] (
    [LogID]      INT            IDENTITY (1, 1) NOT NULL,
    [RunID]      INT            NOT NULL,
    [BatchID]    INT            NOT NULL,
    [StepID]     INT            NOT NULL,
    [Err]        INT            NOT NULL,
    [LogDT]      DATETIME       NULL,
    [LogMessage] NVARCHAR (MAX) NULL,
    PRIMARY KEY CLUSTERED ([RunID] ASC, [LogID] ASC),
    UNIQUE NONCLUSTERED ([BatchID] ASC, [StepID] ASC, [LogID] ASC) ON [PRIMARY]
);


GO
PRINT N'Creating [dbo].[ETLBatch]...';


GO
CREATE TABLE [dbo].[ETLBatch] (
    [BatchID]      INT           NOT NULL,
    [BatchName]    VARCHAR (30)  NOT NULL,
    [BatchDesc]    VARCHAR (500) NULL,
    [OnSuccessID]  INT           NULL,
    [OnFailureID]  INT           NULL,
    [IgnoreErr]    TINYINT       NULL,
    [RestartOnErr] TINYINT       NULL,
    [StatusDT]     DATETIME      NULL,
    [StatusID]     TINYINT       NULL,
    [Err]          INT           NULL,
    [EndTime]      DATETIME      NULL,
    PRIMARY KEY CLUSTERED ([BatchID] ASC),
    UNIQUE NONCLUSTERED ([BatchName] ASC) ON [PRIMARY]
);


GO
PRINT N'Creating [dbo].[ETLBatchAttribute]...';


GO
CREATE TABLE [dbo].[ETLBatchAttribute] (
    [BatchID]        INT            NOT NULL,
    [AttributeName]  VARCHAR (100)  NOT NULL,
    [AttributeValue] VARCHAR (8000) NULL,
    PRIMARY KEY CLUSTERED ([BatchID] ASC, [AttributeName] ASC)
);


GO
PRINT N'Creating [dbo].[ETLBatchConstraint]...';


GO
CREATE TABLE [dbo].[ETLBatchConstraint] (
    [ConstID]    INT          NOT NULL,
    [BatchID]    INT          NOT NULL,
    [ProcessID]  INT          NOT NULL,
    [ConstOrder] VARCHAR (10) NULL,
    [WaitPeriod] INT          NULL,
    PRIMARY KEY CLUSTERED ([BatchID] ASC, [ConstID] ASC)
);


GO
PRINT N'Creating [dbo].[ETLBatchConstraintAttribute]...';


GO
CREATE TABLE [dbo].[ETLBatchConstraintAttribute] (
    [BatchID]        INT            NOT NULL,
    [ConstID]        INT            NOT NULL,
    [AttributeName]  VARCHAR (100)  NOT NULL,
    [AttributeValue] VARCHAR (8000) NULL,
    PRIMARY KEY CLUSTERED ([BatchID] ASC, [ConstID] ASC, [AttributeName] ASC)
);


GO
PRINT N'Creating [dbo].[SystemParameters]...';


GO
CREATE TABLE [dbo].[SystemParameters] (
    [ParameterType]          VARCHAR (100)   NOT NULL,
    [ParameterName]          VARCHAR (100)   NOT NULL,
    [ParameterValue_Current] VARBINARY (MAX) NULL,
    [ParameterValue_New]     VARBINARY (MAX) NULL,
    [ParameterValue_Default] VARBINARY (MAX) NULL,
    [ParameterDesc]          VARCHAR (1024)  NOT NULL,
    [EnvironmentName]        VARCHAR (100)   NOT NULL,
    [LastModifiedBy]         [sysname]       NOT NULL,
    [LastModifiedDtim]       DATETIME        NOT NULL
);


GO
PRINT N'Creating [dbo].[Dsv]...';


GO
CREATE TABLE [dbo].[Dsv] (
    [DsvID]   INT           IDENTITY (1, 1) NOT NULL,
    [DsvName] NVARCHAR (30) NOT NULL,
    [DsvType] TINYINT       NOT NULL,
    [FromDT]  DATETIME      NOT NULL,
    [ToDT]    DATETIME      NOT NULL,
    [Dsv]     XML           NOT NULL,
    CONSTRAINT [PK_Dsv] PRIMARY KEY CLUSTERED ([DsvID] ASC),
    CONSTRAINT [UQ_Dsv01] UNIQUE NONCLUSTERED ([DsvName] ASC, [DsvType] ASC) ON [PRIMARY]
);


GO
PRINT N'Creating unnamed constraint on [dbo].[ETLBatchRun]...';


GO
ALTER TABLE [dbo].[ETLBatchRun]
    ADD DEFAULT (suser_sname()) FOR [ModifiedBY];


GO
PRINT N'Creating unnamed constraint on [dbo].[ETLStepRunCounter]...';


GO
ALTER TABLE [dbo].[ETLStepRunCounter]
    ADD DEFAULT (getdate()) FOR [CreatedDTim];


GO
PRINT N'Creating unnamed constraint on [dbo].[ETLStepRunCounter]...';


GO
ALTER TABLE [dbo].[ETLStepRunCounter]
    ADD DEFAULT (getdate()) FOR [ModifiedDTim];


GO
PRINT N'Creating unnamed constraint on [dbo].[SystemParameters]...';


GO
ALTER TABLE [dbo].[SystemParameters]
    ADD DEFAULT SYSTEM_USER FOR [LastModifiedBy];


GO
PRINT N'Creating unnamed constraint on [dbo].[SystemParameters]...';


GO
ALTER TABLE [dbo].[SystemParameters]
    ADD DEFAULT CURRENT_TIMESTAMP FOR [LastModifiedDtim];


GO
PRINT N'Creating unnamed constraint on [dbo].[Dsv]...';


GO
ALTER TABLE [dbo].[Dsv]
    ADD DEFAULT (getdate()) FOR [FromDT];


GO
PRINT N'Creating unnamed constraint on [dbo].[Dsv]...';


GO
ALTER TABLE [dbo].[Dsv]
    ADD DEFAULT ('9999-12-31') FOR [ToDT];


GO
PRINT N'Creating [dbo].[SystemParametersEnvironmentNameCK]...';


GO
ALTER TABLE [dbo].[SystemParameters]
    ADD CONSTRAINT [SystemParametersEnvironmentNameCK] CHECK (EnvironmentName IN ('ALL', 'DEV', 'TEST', 'UAT','PPE', 'PROD'));


GO
PRINT N'Creating [dbo].[fn_AttributeGet]...';


GO
/*
select * from ETLStepAttribute
select [dbo].fn_AttributeGet (-10,1,null,'StepName')
*/
create function [dbo].[fn_AttributeGet] (
    @BatchID int
   ,@StepID int
   ,@ConstID int
   ,@AttributeName nvarchar(100)
)
returns nvarchar(4000)
 as
begin
/******************************************************************************
** File:	[fn_AttributeGet].sql
** Name:	[dbo].[fn_AttributeGet]

** SD Location: VSS/Development/SubjectAreas/BI/Database/Schema/Function/[fn_AttributeGet].sql:

** Desc:	return  user defined attribute value for batch/step/const combination
**          
**
** Params:
** Returns:
**
** Author:	andreys
** Date:	08/01/2007
** ****************************************************************************
** CHANGE HISTORY
** ****************************************************************************
** Date				Author	version	4	#bug			Description
** ----------------------------------------------------------------------------------------------------------

*/
   declare @v nvarchar(4000)

   if (@ConstId is not null and @StepID is null)
      if (@AttributeName = 'ConstOrder')
         select @v = ConstOrder from dbo.[ETLBatchConstraint] where BatchID = @BatchID and ConstId = @ConstID;
      else if (@AttributeName = 'WaitPeriod')
         select @v = WaitPeriod from dbo.[ETLBatchConstraint] where BatchID = @BatchID and ConstId = @ConstID;
      else 
         select @v = AttributeValue
           from dbo.[ETLBatchConstraintAttribute]
          where BatchID = @BatchID and ConstId = @ConstID and AttributeName = @AttributeName;
   else if (@ConstId is not null and @StepID is not null)
      if (@AttributeName = 'ConstOrder')
         select @v = ConstOrder from dbo.[ETLStepConstraint] where BatchID = @BatchID and StepID = @StepID and ConstId = @ConstID;
      else if (@AttributeName = 'WaitPeriod')
         select @v = WaitPeriod from dbo.[ETLStepConstraint] where BatchID = @BatchID and StepID = @StepID and ConstId = @ConstID;
      else 
         select @v = AttributeValue
           from dbo.[ETLStepConstraintAttribute]
          where BatchID = @BatchID and StepID = @StepID and ConstId = @ConstID and AttributeName = @AttributeName
   else if (@StepID is not null)
       if (@AttributeName = 'StepName')
         select @v = StepName from dbo.[ETLStep] where BatchID = @BatchID and StepID = @StepID;
       else if (@AttributeName = 'StepDesc')
         select @v = StepDesc from dbo.[ETLStep] where BatchID = @BatchID and StepID = @StepID;
       else if (@AttributeName = 'IgnoreErr')
         select @v = IgnoreErr from dbo.[ETLStep] where BatchID = @BatchID and StepID = @StepID;
       else if (@AttributeName = 'StepOrder')
         select @v = StepOrder from dbo.[ETLStep] where BatchID = @BatchID and StepID = @StepID;
       else
         select @v = AttributeValue
           from dbo.[ETLStepAttribute]
          where BatchID = @BatchID and StepID = @StepID and AttributeName = @AttributeName
   else 
       if (@AttributeName = 'BatchName')
         select @v = BatchName from dbo.[ETLBatch] where BatchID = @BatchID;
       else if (@AttributeName = 'BatchDesc')
         select @v = BatchDesc from dbo.[ETLBatch] where BatchID = @BatchID;
       else if (@AttributeName = 'IgnoreErr')
         select @v = IgnoreErr from dbo.[ETLBatch] where BatchID = @BatchID;
       else if (@AttributeName = 'RestartOnErr')
         select @v = RestartOnErr from dbo.[ETLBatch] where BatchID = @BatchID;
       else
         select @v = AttributeValue
           from dbo.[ETLBatchAttribute]
          where BatchID = @BatchID and AttributeName = @AttributeName

   return (@v)
end
GO
PRINT N'Creating [dbo].[fn_CounterGet]...';


GO
/*
select * from ETLStepRunCounter
select [dbo].[fn_CounterGet] (20,0,0,'ExProcessID')
*/
create function [dbo].[fn_CounterGet] (
    @BatchID int
   ,@StepID int
   ,@RunID int
   ,@CounterName nvarchar(100)
)
returns nvarchar(1000)
 as
begin
/******************************************************************************
** File:	[fn_CounterGet].sql
** Name:	[dbo].[fn_CounterGet]

** SD Location: VSS/Development/SubjectAreas/BI/Database/Schema/Function/fn_CounterGet.sql:

** Desc:	return  user defined counter value for batch/step/run combination
**          
**
** Params:
** @Request      --xml containing @RunID/StepID/BatchID
** Returns:
**
** Author:	andreys
** Date:	08/01/2007
** ****************************************************************************
** CHANGE HISTORY
** ****************************************************************************
** Date				Author	version	4	#bug			Description
** ----------------------------------------------------------------------------------------------------------

*/

   return (select top(1) CounterValue
             from dbo.[ETLStepRunCounter]
            where BatchID = @BatchID and StepID = @StepID and RunID = @RunID and CounterName = @CounterName)
end
GO
PRINT N'Creating [dbo].[fn_ETLCounterGet]...';


GO
/*
select * from ETLStepRunCounter
select [dbo].[fn_ETLCounterGet] (20,0,0,'ExProcessID')
*/
create function [dbo].[fn_ETLCounterGet] (
    @BatchID int
   ,@StepID int
   ,@RunID int
   ,@CounterName nvarchar(100)
)
returns nvarchar(1000)
 as
begin
/******************************************************************************
** File:	[fn_ETLCounterGet].sql
** Name:	[dbo].[fn_ETLCounterGet]

** SD Location: VSS/Development/SubjectAreas/BI/Database/Schema40/Function/[fn_ETLCounterGet].sql:

** Desc:	return  user defined counter value for batch/step/run combination
**          
**
** Params:
** @Request      --xml containing @RunID/StepID/BatchID
** Returns:
**
** Author:	andreys
** Date:	08/01/2007
** ****************************************************************************
** CHANGE HISTORY
** ****************************************************************************
** Date				Author	version	4	#bug			Description
** ----------------------------------------------------------------------------------------------------------

*/

   return (select top(1) CounterValue
             from dbo.[ETLStepRunCounter]
            where BatchID = @BatchID and StepID = @StepID and RunID = @RunID and CounterName = @CounterName)
end
GO
PRINT N'Creating [dbo].[fn_SystemParameter]...';


GO

/*
** Name:  [dbo].[fn_SystemParameter]
**
** $Workfile: fn_systemparameter.sql $
** $Archive: /Development/SubjectAreas/UserActivityStats/Database/Schema/Function/fn_systemparameter.sql $
**
** Purpose:
**      This script creates a function to return the current setting for
**  the specified system parameter.
**
** $Author: Karlj $
** $Revision: 6 $
** $BuildVersion: $
**
** Pre-conditions:
**      The system parameters are defined in the [dbo].[SystemParameters]
**  table.
**
** Input Arguments:
**
**      Name:         @ParameterCategory
**      Datatype:     udt_ParameterType
**      Default:      None
**      Description:  The system parameter category.
**
**      Name:         @ParameterName
**      Datatype:     udt_ParameterName
**      Default:      None
**      Description:  The system parameter name.  Names are unique to a
**                    parameter category.
**
** Return Type:
**      [udt_ParameterValue]
**
** Results Set:
**      None
**
** Post-conditions:
**      No changes are made to the database.
*/

CREATE FUNCTION [dbo].[fn_SystemParameter] (
        @ParameterType VARCHAR(100)    -- System parameter type.
      , @ParameterName VARCHAR(100)        -- System parameter name.
	  , @EnvironmentName VARCHAR(100)	  -- Environment Name
	  --, @Passphrase VARCHAR(100) = '7CCC1B81-EA9E-4710-AD10-43452169017E'
    ) RETURNS varchar(max) AS

    BEGIN

		DECLARE @Passphrase VARCHAR(100) = '7CCC1B81-EA9E-4710-AD10-43452169017E';
        RETURN (SELECT TOP 1 CAST(  
			DecryptByPassphrase(@Passphrase,ISNULL([ParameterValue_Current],[ParameterValue_Default]), 1 ,   
			HashBytes('SHA1', CONVERT(varbinary(100), ParameterName))) as varchar(max)) 		
          FROM [dbo].[SystemParameters]
         WHERE [ParameterType] = @ParameterType
           AND [ParameterName] = @ParameterName
		   AND EnvironmentName = @EnvironmentName);

    END
GO
PRINT N'Creating [dbo].[fn_GetBase64String]...';


GO

CREATE FUNCTION [dbo].[fn_GetBase64String]
(
	@StringToEncode nvarchar(max)
) RETURNS nvarchar(max)
AS
BEGIN
/******************************************************************
**	D File:         fn_GetBase64String.SQL
**
**	D Desc:         Encode string as base 64 to pass to DeltaExtractor
**
**	D Auth:         vensri
**	D Date:         12/18/2007
**
**	Param:			@StringToEncode - The string to encode
**  Returns:		nvarchar(max) the base 64 encoded string
*******************************************************************
**      Change History
*******************************************************************
**  Date:            Author:            Description:
******************************************************************/
	DECLARE @xmlDoc xml

	SELECT @xmlDoc = (select cast( @StringToEncode as varbinary(max))
	FOR XML RAW ('row'), elements, BINARY BASE64, type)

	return (select @xmlDoc.value('(/row)[1]','nvarchar(max)'))

END
GO
PRINT N'Creating [dbo].[prc_ETLAttributeSet]...';


GO

/*
exec [dbo].[prc_ETLAttributeSet] -10,-5,null,'RestartOnErr','1'
select * from ETLBatch
*/
CREATE procedure [dbo].[prc_ETLAttributeSet] (
    @BatchID int
   ,@StepID int = null
   ,@ConstID int = null
   ,@AttributeName nvarchar(100)
   ,@AttributeValue nvarchar(4000)
)
 as
begin
/******************************************************************************
** File:	[prc_ETLAttributeSet].sql
** Name:	[dbo].[prc_ETLAttributeSet]

** SD Location: VSS/Development/SubjectAreas/BI/Database/Schema40/Procedure/[prc_ETLAttributeSet].sql:

** Desc:	set  user defined attribute value for batch/step/const combination
**          
**
** Params:
** Returns:
**
** Author:	andreys
** Date:	08/01/2007
** ****************************************************************************
** CHANGE HISTORY
** ****************************************************************************
** Date				Author	version	4	#bug			Description
** ----------------------------------------------------------------------------------------------------------
** 2012-01-09       andreys                             validate inpits
*/
set nocount on
declare @msg nvarchar(max)
declare @Err int
declare @proc sysname

set @Err = 0
set @proc = OBJECT_NAME(@@procid)

begin try

   if (not exists(select 1 from dbo.ETLBatch where BatchID = @BatchID))
      raiserror('Invalid Parameter b=%d',11,11,@BatchID);


   if (@ConstId is not null and @StepID is null)
   begin
      if (not exists(select 1 from dbo.ETLBatchConstraint where BatchID = @BatchID and ConstId = @ConstId))
         raiserror('Invalid Parameter bc=%d.%d',11,11,@BatchID,@ConstID);
  --columns
      if (@AttributeName = 'ConstOrder')
         update dbo.[ETLBatchConstraint]
            set ConstOrder = @AttributeValue
          where BatchID = @BatchID and ConstId = @ConstID
      else if (@AttributeName = 'WaitPeriod')
         update dbo.[ETLBatchConstraint]
            set ConstOrder = @AttributeValue
          where BatchID = @BatchID and ConstId = @ConstID
   --attributes 
      else if exists(select 1 from dbo.[ETLBatchConstraintAttribute]
                 where BatchID = @BatchID and ConstId = @ConstID and AttributeName = @AttributeName)
         if (@AttributeValue is null)
            delete dbo.[ETLBatchConstraintAttribute]
             where BatchID = @BatchID and ConstId = @ConstID and AttributeName = @AttributeName
         else
            update dbo.[ETLBatchConstraintAttribute]
               set AttributeValue = @AttributeValue
             where BatchID = @BatchID and ConstId = @ConstID and AttributeName = @AttributeName
      else if (@AttributeValue is not null)
         insert dbo.[ETLBatchConstraintAttribute] (BatchID,ConstID,AttributeName,AttributeValue)
         values (@BatchID,@ConstID,@AttributeName,@AttributeValue)
   end
   else if (@ConstId is not null and @StepID is not null)
   begin
      if (not exists(select 1 from dbo.ETLStepConstraint where BatchID = @BatchID and StepID = @StepID and ConstID = @ConstID))
         raiserror('Invalid Parameter  for the bsc= %d.%d.%d',11,11,@BatchID,@StepID,@ConstID);
   --columns
      if (@AttributeName = 'ConstOrder')
         update dbo.[ETLStepConstraint]
            set ConstOrder = @AttributeValue
          where BatchID = @BatchID and StepID = @StepID and ConstId = @ConstID
      else if (@AttributeName = 'WaitPeriod')
         update dbo.[ETLStepConstraint]
            set ConstOrder = @AttributeValue
          where BatchID = @BatchID and StepID = @StepID and ConstId = @ConstID
   --attributes 
     else if exists(select 1 from dbo.[ETLStepConstraintAttribute]
                 where BatchID = @BatchID and StepID = @StepID and ConstId = @ConstID and AttributeName = @AttributeName)
         if (@AttributeValue is null)
            delete dbo.[ETLStepConstraintAttribute]
             where BatchID = @BatchID and StepID = @StepID  and ConstId = @ConstID and AttributeName = @AttributeName
         else
            update dbo.[ETLStepConstraintAttribute]
               set AttributeValue = @AttributeValue
             where BatchID = @BatchID and StepID = @StepID  and ConstId = @ConstID and AttributeName = @AttributeName
      else if (@AttributeValue is not null)
         insert dbo.[ETLStepConstraintAttribute] (BatchID,StepID,ConstID,AttributeName,AttributeValue)
         values (@BatchID,@StepID,@ConstID,@AttributeName,@AttributeValue)
   end
   else if (@StepID is not null)
   begin
      if (not exists(select 1 from dbo.ETLStep where BatchID = @BatchID and StepID = @StepID))
         raiserror('Invalid Parameter  for the bs= %d.%d',11,11,@BatchID,@StepID);
    --columns
      if (@AttributeName = 'StepName')
         update dbo.[ETLStep]
            set StepName = @AttributeValue
          where BatchID = @BatchID and StepID = @StepID
      else if (@AttributeName = 'StepDesc')
         update dbo.[ETLStep]
            set StepDesc = @AttributeValue
          where BatchID = @BatchID and StepID = @StepID
      else if (@AttributeName = 'IgnoreErr')
         update dbo.[ETLStep]
            set IgnoreErr = @AttributeValue
          where BatchID = @BatchID and StepID = @StepID
      else if (@AttributeName = 'StepOrder')
         update dbo.[ETLStep]
            set StepOrder = @AttributeValue
          where BatchID = @BatchID and StepID = @StepID
   --attributes 
      else if exists(select 1 from dbo.[ETLStepAttribute]
                 where BatchID = @BatchID and StepId = @StepID and AttributeName = @AttributeName)
         if (@AttributeValue is null)
            delete dbo.[ETLStepAttribute]
             where BatchID = @BatchID and StepID = @StepID and AttributeName = @AttributeName
         else
            update dbo.[ETLStepAttribute]
               set AttributeValue = @AttributeValue
             where BatchID = @BatchID and StepId = @StepID and AttributeName = @AttributeName
      else if (@AttributeValue is not null)
         insert dbo.[ETLStepAttribute] (BatchID,StepID,AttributeName,AttributeValue)
         values (@BatchID,@StepID,@AttributeName,@AttributeValue)
   end
   else
   begin
    --columns
      if (@AttributeName = 'BatchName')
         update dbo.[ETLBatch]
            set BatchName = @AttributeValue
          where BatchID = @BatchID
      else if (@AttributeName = 'BatchDesc')
         update dbo.[ETLBatch]
            set BatchDesc = @AttributeValue
          where BatchID = @BatchID
      else if (@AttributeName = 'IgnoreErr')
         update dbo.[ETLBatch]
            set IgnoreErr = @AttributeValue
          where BatchID = @BatchID
      else if (@AttributeName = 'RestartOnErr')
         update dbo.[ETLBatch]
            set RestartOnErr = @AttributeValue
          where BatchID = @BatchID
   --attributes 
      else if exists(select 1 from dbo.[ETLBatchAttribute]
                 where BatchID = @BatchID and AttributeName = @AttributeName)
         if (@AttributeValue is null)
            delete dbo.[ETLBatchAttribute]
             where BatchID = @BatchID and AttributeName = @AttributeName
         else
            update dbo.[ETLBatchAttribute]
               set AttributeValue = @AttributeValue
             where BatchID = @BatchID and AttributeName = @AttributeName
      else if (@AttributeValue is not null)
         insert dbo.[ETLBatchAttribute] (BatchID,AttributeName,AttributeValue)
         values (@BatchID,@AttributeName,@AttributeValue)
   end

end try
begin catch	
	if @@trancount > 0 rollback tran
	
   set @Proc = ERROR_PROCEDURE()
   set @Msg = ERROR_MESSAGE()
   raiserror ('ERROR: PROC %s, MSG: %s',11,17,@Proc,@Msg) 
   set @Err = ERROR_NUMBER()
end catch
   return 0
end
GO
PRINT N'Creating [dbo].[prc_ETLCounterSet]...';


GO
/*
exec dbo.prc_ETLCounterSet -20,1,0,'test2','bbb'
select dbo.fn_ETLCounterGet (-20,1,0,'test2')

*/
create procedure [dbo].[prc_ETLCounterSet] (
    @pBatchID int
   ,@pStepID int = null
   ,@pRunID int = null
   ,@pName varchar(100) = null
   ,@pValue nvarchar(max)

) as
begin
/******************************************************************************
** File:	[prc_ETLCounterSet].sql
** Name:	[dbo].[prc_ETLCounterSet]

** SD Location: VSS/Development/SubjectAreas/BI/Database/Schema/Procedure/[prc_ETLCounterSet].sql:

** Desc:	set client Counter value
**          
**
** Params:
** Returns:
**
** Author:	andreys
** Date:	10/30/2007
** ****************************************************************************
** CHANGE HISTORY
** ****************************************************************************
** Date				Author	version	4	#bug			Description
** ----------------------------------------------------------------------------------------------------------
** 2012-01-09       andreys                             validate inpits

*/

set nocount on
declare @err                int
declare @proc               sysname
declare @msg                nvarchar(1000)
declare @debug              tinyint
declare @Options            int
declare @query              nvarchar(max)

declare @BatchID int
declare @StepID int
declare @RunID int
declare @LGRunID int
declare @ProcErr int
declare @ProcName sysname
declare @Counters xml(ETLController)

set @err = 0
begin try

set @BatchID = @pBatchID
set @StepID = isnull(@pStepID,0)
set @RunID = isnull(@pRunID,0)

   if (not exists(select 1 from dbo.ETLBatch where BatchID = @BatchID))
      raiserror('Invalid Parameter b=%d',11,11,@BatchID);
   if (@RunID <> 0 and not exists(select 1 from dbo.ETLBatchRun where BatchID = @BatchID and RunID = @RunID))
      raiserror('Invalid Parameter br=%d',11,11,@BatchID,@RunID);
   if (@StepID <> 0 and not exists(select 1 from dbo.ETLStep where BatchID = @BatchID and StepID = @StepID))
      raiserror('Invalid Parameter bs=%d',11,11,@BatchID,@StepID);


   if exists(select 1 from dbo.[ETLStepRunCounter]
                      where RunID = @RunID and StepID = @StepID
                        and BatchID = @BatchID and CounterName = @pName)
   begin
      if @pValue is null
      begin
         delete dbo.[ETLStepRunCounter]
          where RunID = @RunID and StepID = @StepID
            and BatchID = @BatchID and CounterName = @pName
         --raiserror('record was deleted from dbo.ETLStepRunCounter',0,1)
      end
      else
      begin
         update dbo.[ETLStepRunCounter]
         set CounterValue = @pValue
          where RunID = @RunID and StepID = @StepID
            and BatchID = @BatchID and CounterName = @pName
         --raiserror('record was updated in dbo.ETLStepRunCounter',0,1)
      end
   end
   else
   begin
      insert dbo.[ETLStepRunCounter]
      (RunID,StepID,CounterName,BatchID,CounterValue)
      values(@RunID,@StepID,@pName,@BatchID,@pValue)
      --raiserror('record was inserted into dbo.ETLStepRunCounter',0,1)
   end


end try
begin catch
   set @Proc = ERROR_PROCEDURE()
   set @pValue = null
   set @Msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   raiserror ('ERROR: PROC %s, MSG: %s',11,11,@Proc,@Msg) 
end catch

return @err
end
GO
PRINT N'Creating [dbo].[prc_ReadProcessReceipt]...';


GO
/*
declare @s int,@e int,@m nvarchar(max)
declare @pHeader xml
declare @pHeader1 xml
declare @pProcessReceipt xml
exec dbo.prc_CreateHeader @pHeader out,1,null,null,4,10
select @pHeader
exec dbo.prc_CreateProcessReceipt @pProcessReceipt out,@pHeader,2,5000,'xxx'
select @pProcessReceipt
exec dbo.prc_ReadProcessReceipt @pProcessReceipt,@pHeader1 out,@s out,@e out,@m out
select @s,@e,@m
select @pHeader1
*/
CREATE PROCEDURE [dbo].[prc_ReadProcessReceipt]
    @pProcessReceipt xml([ETLController])
   ,@pHeader xml([ETLController]) = null output
   ,@pStatusID int = null output
   ,@pErr int = null output
   ,@pErrMsg nvarchar(max) = null output
As
/******************************************************************
**D File:         prc_ReadProcessReceipt.SQL
**
**D Desc:         read Receipt object
**
**D Auth:         andreys
**D Date:         10/27/2007
**
*******************************************************************
**      Change History
*******************************************************************
**  Date:            Author:            Description:
******************************************************************/
SET NOCOUNT ON
DECLARE @Err INT
DECLARE @ProcErr INT
DECLARE @Cnt INT
DECLARE @ProcName sysname
DECLARE @msg nvarchar(max)

SET @ProcName = OBJECT_NAME(@@PROCID)
SET @Err = 0
SET @ProcErr = 0

begin try
SELECT @pHeader = @pProcessReceipt.query('declare namespace etl="ETLController.XSD";(/etl:ProcessReceipt/etl:Header)[1]')
SET @pStatusID = @pProcessReceipt.value('declare namespace etl="ETLController.XSD";(/etl:ProcessReceipt/etl:Status/@StatusID)[1]','int')
SET @pErr = @pProcessReceipt.value('declare namespace etl="ETLController.XSD";(/etl:ProcessReceipt/etl:Status/@Error)[1]','int')
SET @pErrMsg = @pProcessReceipt.value('declare namespace etl="ETLController.XSD";(/etl:ProcessReceipt/etl:Status/etl:msg)[1]','nvarchar(max)')
end try
begin catch
   set @msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   set @pHeader = null
   raiserror (@msg,11,11)
end catch

RETURN @Err
GO
PRINT N'Creating [dbo].[prc_ReadProcessInfo]...';


GO
/*
declare @m nvarchar(max)
declare @e int
declare @pHeader xml
declare @pHeader1 xml
declare @pProcessInfo xml
exec dbo.prc_CreateHeader @pHeader out,1,null,null,4,10
select @pHeader
exec dbo.prc_CreateProcessInfo @pProcessInfo out,@pHeader,'xxx',10
select @pProcessInfo
exec dbo.prc_ReadProcessInfo @pProcessInfo,@pHeader1 out,@m out,@e out
select @e,@m
select @pHeader1
*/
CREATE PROCEDURE [dbo].[prc_ReadProcessInfo]
    @pProcessInfo xml([ETLController])
   ,@pHeader xml([ETLController]) = null output
   ,@pMsg nvarchar(max) = null output
   ,@pErr int = null output
As
/******************************************************************
**D File:         prc_ReadProcessInfo.SQL
**
**D Desc:         read Info object
**
**D Auth:         andreys
**D Date:         10/27/2007
**
*******************************************************************
**      Change History
*******************************************************************
**  Date:            Author:            Description:
******************************************************************/
SET NOCOUNT ON
DECLARE @Err INT
DECLARE @ProcErr INT
DECLARE @Cnt INT
DECLARE @ProcName sysname
DECLARE @msg nvarchar(max)

SET @ProcName = OBJECT_NAME(@@PROCID)
SET @Err = 0
SET @ProcErr = 0

begin try
SELECT @pHeader = @pProcessInfo.query('declare namespace etl="ETLController.XSD";(/etl:ProcessInfo/etl:Header)[1]')
 ;WITH XMLNAMESPACES ('ETLController.XSD' as etl)
SELECT @pMsg = p.m.value('string(.)[1]','nvarchar(max)')
      ,@pErr = p.m.value('(./@Error)[1]','nvarchar(max)')
  FROM @pProcessInfo.nodes('/etl:ProcessInfo/etl:Message') as p(m)
end try
begin catch
   set @msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   set @pHeader = null
   raiserror (@msg,11,11)
end catch

RETURN @Err
GO
PRINT N'Creating [dbo].[prc_ReadHeader]...';


GO
/*
declare @pHeader xml
declare @b int,@s int,@c int,@o int,@r int,@sc int
exec dbo.prc_CreateHeader @pHeader out,1,2,null,4,10,5
select @pHeader
exec dbo.prc_ReadHeader @pHeader,@b out,@s out,@c out,@r out,@o out,@sc out
select @b,@s,@c,@r,@o,@sc
*/
CREATE PROCEDURE [dbo].[prc_ReadHeader]
    @pHeader xml([ETLController])
   ,@pBatchID int = null output
   ,@pStepID int = null output
   ,@pConstID int = null output
   ,@pRunID int = null output
   ,@pOptions int = null output
   ,@pScope int = null output
As
/******************************************************************
**D File:         prc_ReadHeader.SQL
**
**D Desc:         read Header object
**
**D Auth:         andreys
**D Date:         10/27/2007
**
*******************************************************************
**      Change History
*******************************************************************
**  Date:            Author:            Description:
******************************************************************/
SET NOCOUNT ON
DECLARE @Err INT
DECLARE @ProcErr INT
DECLARE @Cnt INT
DECLARE @ProcName sysname
DECLARE @msg nvarchar(max)

SET @ProcName = OBJECT_NAME(@@PROCID)
SET @Err = 0
SET @ProcErr = 0

begin try

;with xmlnamespaces('ETLController.XSD' as etl)
select @pBatchID = h.d.value('(./@BatchID)[1]','int')
      ,@pStepID = h.d.value('(./@StepID)[1]','int')
      ,@pConstID = h.d.value('(./@ConstID)[1]','int')
      ,@pRunID = h.d.value('(./@RunID)[1]','int')
      ,@pOptions = h.d.value('(./@Options)[1]','int')
      ,@pScope = h.d.value('(./@Scope)[1]','int')
  from @pHeader.nodes('(/etl:Header)') h(d)

end try
begin catch
   set @msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   set @pHeader = null
   raiserror (@msg,11,11)
end catch

RETURN @Err
GO
PRINT N'Creating [dbo].[prc_ReadCounter]...';


GO
/*
declare @value nvarchar(max)
declare @RunID int
declare @pHeader xml
declare @pCounters xml
exec dbo.prc_CreateHeader @pHeader out,1,1,1,4,1
exec dbo.prc_CreateCounters @pCounters out,@pHeader
select @pCounters
exec dbo.prc_ReadCounter @pCounters,'test',@value out,@RunID out
select @value,@RunID
*/
CREATE PROCEDURE [dbo].[prc_ReadCounter]
    @pCounters xml([ETLController])
   ,@pName nvarchar(100) = null output
   ,@pValue nvarchar(max) = null output
   ,@pRunID int = null output
As
/******************************************************************
**D File:         prc_ReadCounter.SQL
**
**D Desc:         read Counter
**
**D Auth:         andreys
**D Date:         10/27/2007
**
*******************************************************************
**      Change History
*******************************************************************
**  Date:            Author:            Description:
******************************************************************/
SET NOCOUNT ON
DECLARE @Err INT
DECLARE @ProcErr INT
DECLARE @Cnt INT
DECLARE @ProcName sysname
DECLARE @msg nvarchar(max)

SET @ProcName = OBJECT_NAME(@@PROCID)
SET @Err = 0
SET @ProcErr = 0

begin try
  ;with xmlnamespaces('ETLController.XSD' as etl)
  select @pValue = c.a.value('(.)[1]','nvarchar(max)')
        ,@pRunID = c.a.value('(./@RunID)[1]','int')
  from @pCounters.nodes('/etl:Counters/etl:Counter[@Name=(sql:variable("@pName"))]') c(a)
end try
begin catch
   set @msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   set @pValue = null
   raiserror (@msg,11,11)
end catch

RETURN @Err
GO
PRINT N'Creating [dbo].[prc_ReadAttribute]...';


GO
/*
declare @value nvarchar(max)
declare @pHeader xml
declare @pContext xml
declare @pProcessRequest xml
declare @pAttributes xml
exec dbo.prc_CreateHeader @pHeader out,101,1,1,4,1
exec dbo.prc_CreateContext @pContext out,@pHeader
exec dbo.prc_CreateProcessRequest @pProcessRequest out,@pHeader,@pContext
--select @pProcessRequest
exec dbo.prc_ReadContextAttributes @pProcessRequest,@pAttributes out
select @pAttributes
exec dbo.prc_ReadAttribute @pAttributes,'SQL',@value out
select @value
*/
CREATE PROCEDURE [dbo].[prc_ReadAttribute]
    @pAttributes xml([ETLController])
   ,@pName nvarchar(100) = null output
   ,@pValue nvarchar(max) = null output
As
/******************************************************************
**D File:         prc_ReadAttribute.SQL
**
**D Desc:         read Attribute
**
**D Auth:         andreys
**D Date:         10/27/2007
**
*******************************************************************
**      Change History
*******************************************************************
**  Date:            Author:            Description:
******************************************************************/
SET NOCOUNT ON
DECLARE @Err INT
DECLARE @ProcErr INT
DECLARE @Cnt INT
DECLARE @ProcName sysname
DECLARE @msg nvarchar(max)

SET @ProcName = OBJECT_NAME(@@PROCID)
SET @Err = 0
SET @ProcErr = 0

begin try
  set @pValue = @pAttributes.value('declare namespace etl="ETLController.XSD";
   (/etl:Attributes/etl:Attribute[@Name=(sql:variable("@pName"))])[1]','nvarchar(max)')
end try
begin catch
   set @msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   set @pValue = null
   raiserror (@msg,11,11)
end catch

RETURN @Err
GO
PRINT N'Creating [dbo].[prc_Print]...';


GO
/*
declare @m nvarchar(max)
declare @pHeader xml
declare @pProcessInfo xml
exec dbo.prc_CreateHeader @pHeader out,1,null,null,4,1
select @pHeader
exec dbo.prc_CreateProcessInfo @pProcessInfo out,@pHeader,'xxx'
select @pProcessInfo
exec dbo.prc_Print @pProcessInfo
*/

CREATE PROCEDURE [dbo].[prc_Print]
      @pProcessInfo xml([ETLController])
     ,@pConversation uniqueidentifier = NULL
     ,@pConversationGrp uniqueidentifier = NULL
As
/******************************************************************
**D File:         prc_Print.SQL
**
**D Desc:         Print or Send a processing Info message
**
**D Auth:         andreys
**D Date:         10/27/2007
**
** Param:
        @pProcessInfo       - message object
        @pConversation      - conversation handle to send the message
        @pConversationGrp   - conversation group handle
*******************************************************************
**      Change History
*******************************************************************
**  Date:            Author:            Description:
******************************************************************/
SET NOCOUNT ON
DECLARE @Err INT
DECLARE @Now nvarchar(30)
DECLARE @msg nvarchar(max)
DECLARE @RunID int
DECLARE @BatchID int
DECLARE @StepID int
DECLARE @Options int
DECLARE @debug int
DECLARE @Header xml(ETLController)

SET @Err = 0
-------------------------------------------------------------------
--Return Statuses
--2 - Success
--3 - Failure
--4 - Error
-------------------------------------------------------------------
BEGIN TRY
-- DE should be provided with Master Srv and Dd which will not work with send
-- since conversation handle comes from Slave
-- disable send and rely on standard output for Master Print instead
-- and use send on Slave only. Slave node should not do table insert
set @pConversation = null;
IF (@pConversation IS NOT NULL)
BEGIN

   RAISERROR ('not implemented',0,1) WITH NOWAIT
  --;SEND ON CONVERSATION @pConversation
  -- MESSAGE TYPE [ETLController_InfoMessage]
  --    (CAST(@pProcessInfo AS varbinary(max)));

END
ELSE
BEGIN
   exec dbo.[prc_ReadProcessInfo] @pProcessInfo,@Header out,@msg out,@Err out;
   exec dbo.[prc_ReadHeader] @Header,@BatchID out,@StepID out,null,@RunID out,@Options out;

   SET @debug = ISNULL(@Options & 1,0);
   IF (isnull(@RunID,0) <> 0 OR @debug = 1)
   BEGIN
     --PRINT @msg;

     INSERT dbo.[ETLStepRunHistoryLog]
      (RunID,BatchID,StepID,LogDT,Err,LogMessage)
     VALUES(@RunID,isnull(@BatchID,0),isnull(@StepID,0),getdate(),isnull(@Err,0),@msg);
   END
     
   SET @Err = 0;
END

END TRY
BEGIN CATCH
    SET @Err = ERROR_NUMBER();
    SET @msg = ERROR_MESSAGE();
    RAISERROR('Error %d %s',11,11,@Err,@msg);
END CATCH

RETURN @Err
GO
PRINT N'Creating [dbo].[prc_CreateProcessRequest]...';


GO
/*
declare @uid uniqueidentifier
declare @pHeader xml
declare @pContext xml
declare @pProcessRequest xml
set @uid = newid()
exec dbo.prc_CreateHeader @pHeader out,-10,null,null,4,10
--exec dbo.prc_CreateContext @pContext out,@pHeader
exec dbo.prc_CreateProcessRequest @pProcessRequest out,@pHeader,@pContext,@uid
select @pHeader
select @pContext
select @pProcessRequest
*/
CREATE PROCEDURE [dbo].[prc_CreateProcessRequest]
    @pProcessRequest xml([ETLController]) output
   ,@pHeader xml([ETLController])
   ,@pContext xml([ETLController])
   ,@pConversation uniqueidentifier = null
   ,@pConversationGrp uniqueidentifier = null
As
/******************************************************************
**D File:         prc_CreateProcessRequest.SQL
**
**D Desc:         return ProcessRequest object
**
**D Auth:         andreys
**D Date:         10/27/2007
**
*******************************************************************
**      Change History
*******************************************************************
**  Date:            Author:            Description:
******************************************************************/
SET NOCOUNT ON
DECLARE @Err INT
DECLARE @ProcErr INT
DECLARE @Cnt INT
DECLARE @ProcName sysname
DECLARE @msg nvarchar(max)
DECLARE @x xml
DECLARE @nHandle nvarchar(36)
DECLARE @nHandleGrp nvarchar(36)
DECLARE @pr nvarchar(max)

SET @ProcName = OBJECT_NAME(@@PROCID)
SET @Err = 0
SET @ProcErr = 0

set @nHandle= isnull(cast(@pConversation as nvarchar(36)),'')
set @nHandleGrp= isnull(cast(@pConversationGrp as nvarchar(36)),'')

begin try
set @pr = '
  <etl:ProcessRequest xmlns:etl="ETLController.XSD">
   <etl:Header/>
   <etl:SrcConversation>' + @nHandle + '</etl:SrcConversation>
   <etl:SrcConversationGrp>' + @nHandleGrp + '</etl:SrcConversationGrp>
   <etl:DstConversation/>
   <etl:DstConversationGrp/>
   <etl:Context/>
   </etl:ProcessRequest>
'
set @pr = replace(@pr,'<etl:Header/>',cast(@pHeader as nvarchar(max)))

set @pr = replace(@pr,'<etl:Context/>',isnull(cast(@pContext as nvarchar(max)),''))

set @pProcessRequest = @pr

end try
begin catch
   set @msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   set @pHeader = null
   raiserror (@msg,11,11)
end catch

RETURN @Err
GO
PRINT N'Creating [dbo].[prc_CreateProcessReceipt]...';


GO
/*
declare @pHeader xml
declare @pProcessReceipt xml
exec dbo.prc_CreateHeader @pHeader out,1,null,null,4,10
select @pHeader
exec dbo.prc_CreateProcessReceipt @pProcessReceipt out,@pHeader,2,5000,null
select @pProcessReceipt
*/
CREATE PROCEDURE [dbo].[prc_CreateProcessReceipt]
    @pProcessReceipt xml([ETLController]) output
   ,@pHeader xml([ETLController])
   ,@pStatusID int
   ,@pErr int
   ,@pErrMsg nvarchar(max) = null
As
/******************************************************************
**D File:         prc_CreateProcessReceipt.SQL
**
**D Desc:         return ProcessReceipt object
**
**D Auth:         andreys
**D Date:         10/27/2007
**
*******************************************************************
**      Change History
*******************************************************************
**  Date:            Author:            Description:
******************************************************************/
SET NOCOUNT ON
DECLARE @Err INT
DECLARE @ProcErr INT
DECLARE @Cnt INT
DECLARE @ProcName sysname
DECLARE @msg nvarchar(max)

SET @ProcName = OBJECT_NAME(@@PROCID)
SET @Err = 0
SET @ProcErr = 0

begin try
SELECT @pProcessReceipt = @pHeader.query('declare namespace etl="ETLController.XSD";
  <etl:ProcessReceipt>
   {etl:Header}
   <etl:Status StatusID="{sql:variable("@pStatusID")}" Error="{sql:variable("@pErr")}">
    <etl:msg>{sql:variable("@pErrMsg")}</etl:msg>
   </etl:Status>
  </etl:ProcessReceipt>
')
end try
begin catch
   set @msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   set @pHeader = null
   raiserror (@msg,11,11)
end catch

RETURN @Err
GO
PRINT N'Creating [dbo].[prc_CreateProcessInfo]...';


GO
/*
declare @pHeader xml
declare @pProcessInfo xml
exec dbo.etl_CreateHeader @pHeader out,1,null,null,4,1
select @pHeader
exec dbo.etl_CreateProcessInfo @pProcessInfo out,@pHeader,'xxx'
select @pProcessInfo
*/
CREATE PROCEDURE [dbo].[prc_CreateProcessInfo]
    @pProcessInfo xml([ETLController]) output
   ,@pHeader xml([ETLController])
   ,@pMsg nvarchar(max)
   ,@pErr int = null
As
/******************************************************************
**D File:         etl_CreateProcessInfo.SQL
**
**D Desc:         return ProcessInfo object
**
**D Auth:         andreys
**D Date:         10/27/2007
**
*******************************************************************
**      Change History
*******************************************************************
**  Date:            Author:            Description:
******************************************************************/
SET NOCOUNT ON
DECLARE @Err INT
DECLARE @ProcErr INT
DECLARE @Cnt INT
DECLARE @ProcName sysname
DECLARE @msg nvarchar(max)
DECLARE @Options int
DECLARE @debug tinyint
DECLARE @now nvarchar(30)
DECLARE @Prefix nvarchar(100)
DECLARE @BatchID int
DECLARE @StepID int

SET @ProcName = OBJECT_NAME(@@PROCID)
SET @Err = 0
SET @ProcErr = 0
SET @pErr = ISNULL(@pErr,0)

begin try

exec dbo.[prc_ReadHeader] @pHeader,@BatchID out,@StepID out,null,null,@Options out
set @debug = NULLIF(@Options & 1,0)

IF (@debug IS NOT NULL)
BEGIN
   --SET @Now = CONVERT(NVARCHAR(30),getdate(),121)
   SET @Prefix = CAST(isnull(@BatchID,0) as nvarchar(10)) + '.' + CAST(isnull(@StepID,0) as nvarchar(10))
               + ':' /*+ @@SERVERNAME + '.' + DB_NAME()*/ + 'SP=' + CAST(@@SPID AS nvarchar(10))
               + ':' + 'Er=' + CAST(@pErr AS nvarchar(10))
   --SET @pMsg =  'DEBUG(' + @@SERVERNAME + '.' + DB_NAME() + ' ID=' + CAST(@@SPID AS nvarchar(100)) + ':' + @Now + ') ' + isnull(@pMsg,'null')
   SET @pMsg =  'DEBUG(' + @Prefix + ') ' + isnull(@pMsg,'null')
   SET @pMsg =  isnull(@pMsg,'null')
END



SELECT @pProcessInfo = @pHeader.query('declare namespace etl="ETLController.XSD";
  <etl:ProcessInfo>
   {etl:Header}
   <etl:Message Error="{sql:variable("@pErr")}">{sql:variable("@pMsg")}</etl:Message>
  </etl:ProcessInfo>
')
 
 
 
end try
begin catch
   set @msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   set @pHeader = null
   raiserror (@msg,11,11)
end catch

RETURN @Err
GO
PRINT N'Creating [dbo].[prc_CreateHeader]...';


GO
/*
declare @pHeader xml
exec dbo.prc_CreateHeader @pHeader out,1,null,null,4,10
select @pHeader
*/
CREATE PROCEDURE [dbo].[prc_CreateHeader]
    @pHeader xml([ETLController]) output
   ,@pBatchID int
   ,@pStepID int = null
   ,@pConstID int = null
   ,@pRunID int
   ,@pOptions int = null
   ,@pScope int = null
As
/******************************************************************
**D File:         prc_CreateHeader.SQL
**
**D Desc:         return Header object
**
**D Auth:         andreys
**D Date:         10/27/2007
**
*******************************************************************
**      Change History
*******************************************************************
**  Date:            Author:            Description:
******************************************************************/
SET NOCOUNT ON
DECLARE @Err INT
DECLARE @ProcErr INT
DECLARE @Cnt INT
DECLARE @ProcName sysname
DECLARE @msg nvarchar(max)

SET @ProcName = OBJECT_NAME(@@PROCID)
SET @Err = 0
SET @ProcErr = 0

begin try
SET @pHeader =
  '<etl:Header xmlns:etl="ETLController.XSD"'
+ ' BatchID="' + CAST(@pBatchID AS nvarchar(30)) + '"'
+ CASE WHEN @pStepID IS NOT NULL THEN ' StepID="' + CAST(@pStepID AS nvarchar(30)) + '"' ELSE '' END
+ CASE WHEN @pConstID IS NOT NULL THEN N' ConstID="' + CAST(@pConstID AS nvarchar(30)) + '"' ELSE '' END
+ ' RunID="' + CAST(@pRunID AS nvarchar(30)) + '"'
+ CASE WHEN @pOptions IS NOT NULL THEN N' Options="' + CAST(@pOptions AS nvarchar(30)) + '"' ELSE '' END
+ CASE WHEN @pScope IS NOT NULL THEN N' Scope="' + CAST(@pScope AS nvarchar(30)) + '"' ELSE '' END
+ ' />'
end try
begin catch
   set @msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   set @pHeader = null
   raiserror (@msg,11,11)
end catch

RETURN @Err
GO
PRINT N'Creating [dbo].[prc_CreateCounters]...';


GO

/*
select * from ETLBatchRun where batchid = 130

--select * from ETLStepRunCounter
--insert ETLStepRunCounter
--values(-20,1,4,'test','xxx')
--insert ETLStepRunCounter
--values(-20,1,3,'test1','yyy')
declare @pHeader xml
declare @pCounters xml
exec dbo.prc_CreateHeader @pHeader out,-20,1,null,4,1
--select @pHeader
exec dbo.prc_CreateCounters @pCounters out,@pHeader
select @pCounters

*/
CREATE procedure [dbo].[prc_CreateCounters] (
    @pCounters xml ([ETLController]) output
   ,@pHeader xml([ETLController])
   ,@pName nvarchar(100) = null
) as
begin
/******************************************************************************
** File:	[prc_CreateCounters].sql
** Name:	[dbo].[prc_CreateCounters]

** SD Location: VSS/Development/SubjectAreas/BI/Database/Schema/Procedure/[prc_ETLStepCounterGet].sql:

** Desc:	return Counters object for a header context
**          
**
** Params:
** Returns:
**
** Author:	andreys
** Date:	10/30/2007
** ****************************************************************************
** CHANGE HISTORY
** ****************************************************************************
** Date				Author	version	4	#bug			Description
** ----------------------------------------------------------------------------------------------------------

*/

set nocount on

declare @msg                nvarchar(1000)
declare @debug              tinyint
declare @Options            int
declare @query              nvarchar(max)

declare @BatchID int
declare @StepID int
declare @RunID int
declare @ProcName sysname
declare @ProcessInfo xml(ETLController)
declare @Err int

set @ProcName = object_name(@@procid)
begin try

exec dbo.[prc_ReadHeader] @pHeader,@BatchID out,@StepID out,null,@RunID out,@Options out
set @debug = nullif(@Options & 1,0)

if (@debug = 1)
begin
   SET @msg =  'BEGIN Procedure ' + @ProcName + ' with context'
         + ' BatchID=' + isnull(cast(@BatchID as nvarchar(10)),'null')
         + ' StepID=' + isnull(cast(@StepID as nvarchar(10)),'null')
         + ' RunID=' + isnull(cast(@RunID as nvarchar(10)),'null')

   exec dbo.[prc_CreateProcessInfo] @ProcessInfo out,@pHeader=@pHeader,@pMsg=@msg
   exec dbo.[prc_Print] @pProcessInfo=@ProcessInfo
end

set @StepID = isnull(@StepID,0)

--return last known value for all counters
;with xmlnamespaces('ETLController.XSD' as etl)
select @pCounters = 
(select @BatchID as '@BatchID',nullif(@StepID,0) as '@StepID',@RunID as '@RunID'
,(select
        c.CounterName as '@Name'
       ,c.RunID as '@RunID'
       ,c.CounterValue as '*'
    from dbo.[ETLStepRunCounter] c (nolock)
    join (select max(c.RunID) as RunID, c.CounterName
            from dbo.[ETLStepRunCounter] c (nolock)
           where c.RunID <= @RunID and c.StepID = @StepID and c.BatchID = @BatchID
             and (@pName is null or c.CounterName = @pName)
           group by c.CounterName) p
      on c.RunID = p.RunID and c.CounterName = p.CounterName
   where (c.StepID = @StepID and c.BatchID = @BatchID
     and (@pName is null or c.CounterName = @pName))
     for xml path('etl:Counter'),type)
for xml path('etl:Counters'),type
)

if (@debug = 1)
begin
   SET @msg =  'END Procedure ' + @ProcName
   exec dbo.[prc_CreateProcessInfo] @ProcessInfo out,@pHeader=@pHeader,@pMsg=@msg
   exec dbo.[prc_Print] @pProcessInfo=@ProcessInfo
end

end try
begin catch	
	if @@trancount > 0 rollback tran
   set @msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   set @pCounters = null
   raiserror (@msg,11,11)
end catch
   return 0
end
GO
PRINT N'Creating [dbo].[prc_ApplicationLog]...';


GO
/*
exec dbo.prc_ApplicationLog 'test message',1,1,1,1
*/

CREATE PROCEDURE [dbo].[prc_ApplicationLog]
      @pMessage nvarchar(max)
     ,@pErr int = null
     ,@pBatchId int = null
     ,@pStepId int = null
     ,@pRunId int = 0
     ,@pConversation uniqueidentifier = NULL
     ,@pConversationGrp uniqueidentifier = NULL
     ,@pOptions nvarchar(100) = null
As
/******************************************************************
**D File:         prc_ApplicationLog.SQL
**
**D Desc:         Log external message
**
**D Auth:         andreys
**D Date:         06/27/2009
**
** Param:
*******************************************************************
**      Change History
*******************************************************************
**  Date:            Author:            Description:
******************************************************************/
SET NOCOUNT ON
DECLARE @Err INT
DECLARE @Now nvarchar(30)
DECLARE @msg nvarchar(max)
DECLARE @RunID int
DECLARE @BatchID int
DECLARE @StepID int
DECLARE @Options int
DECLARE @debug int
DECLARE @Header xml(ETLController)
DECLARE @ProcessInfo xml(ETLController)

SET @Err = 0
-------------------------------------------------------------------
--Return Statuses
--2 - Success
--3 - Failure
--4 - Error
-------------------------------------------------------------------
BEGIN TRY
    

set @BatchID = ISNULL(@pBatchID,0)
set @StepID = ISNULL(@pStepID,0)
set @RunID = ISNULL(@pRunID,0)
set @debug = CASE WHEN CHARINDEX('debug',@pOptions) > 0 THEN 1 ELSE 0 END;


--use conversation only for Slave; use table insert for master
set @pConversation = NULL;
IF (@pConversation IS NOT NULL)
BEGIN
   exec dbo.[prc_CreateHeader] @Header out,@BatchId,@StepId,null,@RunId,@debug
   exec dbo.[prc_CreateProcessInfo] @ProcessInfo out,@Header,@pMessage,@pErr

   RAISERROR ('not implemented',0,1) WITH NOWAIT
  --;SEND ON CONVERSATION @pConversation
  -- MESSAGE TYPE [ETLController_InfoMessage]
  --    (CAST(@ProcessInfo AS varbinary(max)))

END
ELSE
BEGIN

   if (@debug = 1)
      PRINT @pMessage;
      
   IF (isnull(@RunID,0) <> 0)
     INSERT dbo.[ETLStepRunHistoryLog]
      (RunID,BatchID,StepID,LogDT,Err,LogMessage)
     VALUES(@RunID,isnull(@BatchID,0),isnull(@StepID,0),getdate(),isnull(@pErr,0),@pMessage)
END

END TRY
BEGIN CATCH
    SET @Err = ERROR_NUMBER()
    SET @msg = ERROR_MESSAGE()
    RAISERROR('Error %d %s',10,11,@Err,@msg)
END CATCH

RETURN @Err
GO
PRINT N'Creating [dbo].[prc_ExportMetadataScript]...';


GO
create procedure [dbo].[prc_ExportMetadataScript]
 @BatchName nvarchar(100) = null
,@BatchId int = null
,@Script nvarchar(max) = null out
as
/******************************************************************************
** File:	[prc_ExportMetadataScript].sql
** Name:	[dbo].[prc_ExportMetadataScript]

** Desc:	export workflow metadata to sql script
**          
**
** Params:
** Returns:
**
** Author:	andrey
** Date:	11/27/2016
** ****************************************************************************
** CHANGE HISTORY
** ****************************************************************************
** Date				Author	version	4	#bug			Description
** ----------------------------------------------------------------------------------------------------------
declare @script nvarchar(max);
exec prc_ExportMetadataScript @batchId = 100,@script = @script out
print substring (@Script,1,4000)
print substring (@Script,4001,8000)
print substring (@Script,8001,12000)
print substring (@Script,12001,16000)

*/
set nocount on;

set @script = '';
declare @sql nvarchar(max);

begin try

declare @msg nvarchar(2000);
if (@BatchName is null and @BatchId is null)
begin
	set @msg = 'Invalid input parameters. BatchId or BatchName are required';
	throw 50001,@msg,1; 
end


declare @bid int, @batchDesc nvarchar(1000);
select top 1
	 @bid = batchId
 from dbo.ETLBatch
where batchId = isnull(@batchId,batchId)
  and batchName = isnull(@batchName,batchName);

if (@bid is null)
begin
	set @msg = 'Invalid input parameters. BatchId: ' + isnull(cast(@batchId as nvarchar(30)),'null')
			 + ' or BatchName:' + isnull(@BatchName,'null');
	throw 50002,@msg,1; 
end

select top 1
	 @batchId = batchId
	,@BatchName = batchName
	,@BatchDesc = batchDesc
from dbo.ETLBatch
where batchId = @bid;


set @Script = '
---------------------------------------------------------
--' + @batchDesc + '
---------------------------------------------------------
set quoted_identIfier on;
set nocount on;
Declare @Batchid int,@BatchName nvarchar(100) ;
set @BatchID = ' + cast(@batchId as nvarchar(30)) + ';
set @BatchName = ''' + @batchName + ''';

print '' Compiling '' + @BatchName;

begin try
-------------------------------------------------------
--remove Workflow metadata
-------------------------------------------------------
exec dbo.prc_RemoveContext @BatchName;
'

set @sql = (select
	     + '''' + isnull(batchDesc,@batchName) + ''','
		 + isnull(cast(OnSuccessID as nvarchar(10)),'null') + ','
		 + isnull(cast(OnFailureID as nvarchar(10)),'null') + ','
		 + isnull(cast(IgnoreErr as nvarchar(10)),'0') + ','
		 + isnull(cast(RestartOnErr as nvarchar(10)),'0')
from dbo.ETLBatch where batchId = @batchId);

set @Script += '

-------------------------------------------------------
--create workflow record 
-------------------------------------------------------
--set identity_insert dbo.ETLBatch on;
insert dbo.ETLBatch
(BatchID,BatchName,BatchDesc,OnSuccessID,OnFailureID,IgnoreErr,RestartOnErr)
values (@BatchID,@BatchName,' + @sql + ');
--set identity_insert dbo.ETLBatch off;
'
--system attributes
set @sql = '';
select @sql += ',(@batchId,''' + ba.attributeName + ''',''' + replace(ba.attributeValue,'''','''''') + ''')
'
from dbo.ETLBatchAttribute ba
where ba.batchId = @batchId
and  ba.AttributeName in ('HISTRET','MAXTHREAD','PING','TIMEOUT','LIFETIME','RETRY','DELAY');

if (len(@sql) > 0)
set @Script += '
-------------------------------------------------------
--Define workflow level system attributes
--those attributes can be referenced in wf body like <etl:MaxThread> etc.
-------------------------------------------------------
insert dbo.ETLBatchAttribute
(BatchID,AttributeName,AttributeValue)
values
 ' + right(@sql,len(@sql) - 1) + ';';


--user attributes
set @sql = '';
select @sql += ',(@batchId,''' + ba.attributeName + ''',''' + replace(ba.attributeValue,'''','''''') + ''')
'
from dbo.ETLBatchAttribute ba
where ba.batchId = @batchId
and  ba.AttributeName not in ('HISTRET','MAXTHREAD','PING','TIMEOUT','LIFETIME','RETRY','DELAY');

if (len(@sql) > 0)
set @Script += '
-------------------------------------------------------
--Define workflow level user attributes
-- use systemparameters to store global configuration parameters
-- select * from systemparameters
-------------------------------------------------------
insert dbo.ETLBatchAttribute
(BatchID,AttributeName,AttributeValue)
values
 ' + right(@sql,len(@sql) - 1) + ';';


if exists (select 1 from dbo.ETLBatchConstraint where batchId = @batchId)
begin

set @Script += '
-------------------------------------------------------
--create batch level constraints
-------------------------------------------------------

'
set @sql = '';
select @sql += ',(@batchId,'
		 + cast(constId as nvarchar(10)) + ','
		 + isnull(cast(ProcessId as nvarchar(10)),'null') + ','
		 + isnull('''' + ConstOrder + '''','null') + ','
		 + isnull(cast(WaitPeriod as nvarchar(10)),'0') + ')'
from dbo.ETLBatchConstraint where batchId = @batchId
order by constId;


if (len(@sql) > 0)
set @Script += '
--set identity_insert dbo.ETLBatchConstraint on
insert dbo.ETLBatchConstraint
(BatchID,ConstID,ProcessID,ConstOrder,WaitPeriod)
values
' + right(@sql,len(@sql) - 1) + ';
--set identity_insert dbo.ETLBatchConstraint off;
';

--system attributes
set @sql = '';
select @sql += ',(@batchId,' + cast(bca.ConstId as nvarchar(10)) + ',''' + bca.attributeName + ''',''' + replace(bca.attributeValue,'''','''''') + ''')
'
from dbo.ETLBatchConstraintAttribute bca
where bca.batchId = @batchId
and  bca.AttributeName in ('DISABLED','PING')
order by bca.constId;

if (len(@sql) > 0)
begin
set @Script += '
-------------------------------------------------------
--Define workflow constraint level system attributes
-------------------------------------------------------
insert dbo.ETLBatchConstraintAttribute
(BatchID,ConstId,AttributeName,AttributeValue)
values
 ' + right(@sql,len(@sql) - 1) + ';';

--user attributes
set @sql = '';
select @sql += ',(@batchId,' + cast(bca.ConstId as nvarchar(10)) + ',''' + bca.attributeName + ''',''' + replace(bca.attributeValue,'''','''''') + ''')
'
from dbo.ETLBatchConstraintAttribute bca
where bca.batchId = @batchId
and  bca.AttributeName not in ('DISABLED','PING')
order by bca.constId;


set @Script += '

-------------------------------------------------------
--Define workflow constraint level user attributes
-------------------------------------------------------
insert dbo.ETLBatchConstraintAttribute
(BatchID,ConstId,AttributeName,AttributeValue)
values
 ' + right(@sql,len(@sql) - 1) + ';';

end
end

--steps
set @Script += '

-------------------------------------------------------
--create workflow steps
-------------------------------------------------------
declare @stepId int;
';

declare step_cur cursor local fast_forward
for select StepId from dbo.ETLStep
where BatchId = @BatchId;

declare @stepId int = 0;
open step_cur
while (1=1)
begin

fetch next from step_cur into @stepId;
if (@@FETCH_STATUS <> 0) break;

select @sql = '(@batchId,@stepId,'
		 + '''' + StepName + '''' + ','
		 + isnull('''' + StepDesc + '''','null') + ','
		 + cast(StepProcId as nvarchar(10)) + ','
		 + isnull(cast(OnSuccessID as nvarchar(10)),'null') + ','
		 + isnull(cast(OnFailureID as nvarchar(10)),'null') + ','
		 + isnull(cast(IgnoreErr as nvarchar(10)),'0') + ','
		 + isnull('''' + StepOrder + '''','null') + ')
'
from dbo.ETLStep where batchId = @batchId and stepId = @stepId;

set @Script += '

-------------------------------------------------------
--step: ' + cast(@stepId as nvarchar(10)) + '
-------------------------------------------------------
set @stepId = ' + cast(@stepId as nvarchar(10)) + ';
--set identity_insert dbo.ETLStep on;
insert dbo.ETLStep
(BatchID,StepID,StepName,StepDesc,StepProcID,OnSuccessID,OnFailureID,IgnoreErr,StepOrder)
values
 ' + @sql + ';
--set identity_insert dbo.ETLStep off;
';

--step attributes
--system attributes
set @sql = '';
select @sql += ',(@batchId,@stepId,''' + sa.attributeName + ''',''' + replace(sa.attributeValue,'''','''''') + ''')
'
from dbo.ETLStepAttribute sa
where sa.batchId = @batchId and sa.stepId = @stepId
and  sa.AttributeName in ('DISABLED','SEQGROUP','PRIGROUP','RETRY','DELAY','RESTART','LOOPGROUP');

if (len(@sql) > 0)
set @Script += '
-------------------------------------------------------
--Define workflow step level system attributes
--those attributes can be referenced in wf body like <etl:Disabled> etc.
-------------------------------------------------------
insert dbo.ETLStepAttribute
(BatchID,StepId,AttributeName,AttributeValue)
values
 ' + right(@sql,len(@sql) - 1) + ';';


--user attributes
set @sql = '';
select @sql += ',(@batchId,@stepId,''' + sa.attributeName + ''',''' + replace(sa.attributeValue,'''','''''') + ''')
'
from dbo.ETLStepAttribute sa
where sa.batchId = @batchId and sa.stepId = @stepId
and  sa.AttributeName not in ('DISABLED','SEQGROUP','PRIGROUP','RETRY','DELAY','RESTART','LOOPGROUP');

if (len(@sql) > 0)
set @Script += '
-------------------------------------------------------
--Define workflow step level user attributes
-------------------------------------------------------
insert dbo.ETLStepAttribute
(BatchID,StepId,AttributeName,AttributeValue)
values
 ' + right(@sql,len(@sql) - 1) + ';';


if exists (select 1 from dbo.ETLStepConstraint where batchId = @batchId and stepId = @stepId)
begin

set @Script += '
-------------------------------------------------------
--create step level constraints
-------------------------------------------------------

'
set @sql = '';
select @sql += ',(@batchId,@stepId,'
		 + cast(constId as nvarchar(10)) + ','
		 + isnull(cast(ProcessId as nvarchar(10)),'null') + ','
		 + isnull('''' + ConstOrder + '''','null') + ','
		 + isnull(cast(WaitPeriod as nvarchar(10)),'0') + ')'
from dbo.ETLStepConstraint where batchId = @batchId and stepId = @stepId
order by ConstId;


if (len(@sql) > 0)
set @Script += '
--set identity_insert dbo.ETLStepConstraint on
insert dbo.ETLStepConstraint
(BatchID,StepID,ConstID,,ProcessID,ConstOrder,WaitPeriod)
values
' + right(@sql,len(@sql) - 1) + ';
--set identity_insert dbo.ETLStepConstraint off;
';

--system attributes
set @sql = '';
select @sql += ',(@batchId,@stepId,' + cast(sca.ConstId as nvarchar(10)) + ',''' + sca.attributeName + ''',''' + replace(sca.attributeValue,'''','''''') + ''')
'
from dbo.ETLStepConstraintAttribute sca
where sca.batchId = @batchId and sca.stepId = @stepId
and  sca.AttributeName in ('DISABLED','PING')
order by sca.constId;

if (len(@sql) > 0)
begin
set @Script += '
-------------------------------------------------------
--Define workflow step constraint level system attributes
-------------------------------------------------------
insert dbo.ETLStepConstraintAttribute
(BatchID,StepID,ConstId,AttributeName,AttributeValue)
values
 ' + right(@sql,len(@sql) - 1) + ';';

--user attributes
set @sql = '';
select @sql += ',(@batchId,@stepId,' + cast(sca.ConstId as nvarchar(10)) + ',''' + sca.attributeName + ''',''' + replace(sca.attributeValue,'''','''''') + ''')
'
from dbo.ETLStepConstraintAttribute sca
where sca.batchId = @batchId
and  sca.AttributeName not in ('DISABLED','PING')
order by sca.constId;

set @Script += '

-------------------------------------------------------
--Define workflow step constraint level user attributes
-------------------------------------------------------
insert dbo.ETLStepConstraintAttribute
(BatchID,StepID,ConstId,AttributeName,AttributeValue)
values
 ' + right(@sql,len(@sql) - 1) + ';';

end
end

end
deallocate step_cur;

set @Script += '

end try
begin catch
   declare @msg nvarchar(1000)
   set @msg = ''ERRROR: set metadata failed with message: '' + error_message();
   throw 50001, @msg, 1;
end catch
'
;

--print substring (@Script,1,4000)
--print substring (@Script,4001,8000)
--print substring (@Script,8001,12000)
--print substring (@Script,12001,16000)

end try
begin catch
   set @msg = 'Failed to script etadata: ' + error_message();
   throw 50001, @msg, 1;
end catch
GO
PRINT N'Creating [dbo].[prc_Finalize]...';


GO
CREATE procedure [dbo].[prc_Finalize] (
    @pHeader xml(ETLController)
   ,@pHandle uniqueidentifier = null
   ,@pStatusID smallint
   
) as
begin
/******************************************************************************
** File:	[prc_Finalize].sql
** Name:	[dbo].[prc_Finalize]

** SD Location: VSS/Development/SubjectAreas/BI/Database/Schema/Procedure/[prc_Finalize].sql:

** Desc:	clean up the execution tables
**          
**
** Params:
** Returns:
**
** Author:	andreys
** Date:	10/15/2011
** ****************************************************************************
** CHANGE HISTORY
** ****************************************************************************
** Date				Author	version	4	#bug			Description
** ----------------------------------------------------------------------------------------------------------

*/

set nocount on
declare @err                int
declare @proc               sysname
declare @msg                nvarchar(1000)
declare @debug              tinyint
declare @Rows               int

declare @ProcErr int
declare @ProcName sysname
declare @BatchID int
declare @RunID int
declare @Options int
declare @ProcessInfo xml (ETLController)

set @ProcName = object_name(@@PROCID);

set @err = 0;
begin try

exec dbo.prc_ReadHeader @pHeader,@BatchID out,null,null,@RunID out,@Options out;
set @debug = @Options & 1;

--Finalize All stuck RunIDs
--set @RunID = null;

declare @run table (RunID int primary key);
insert @run
select distinct RunID from dbo.ETLStepRun
 where BatchID = @BatchID AND (RunID = @RunID OR isnull(@RunID,0) = 0)
 union select RunID from dbo.ETLBatchRun
 where BatchID = @BatchID AND (RunID = @RunID OR (isnull(@RunID,0) = 0 and StatusID = 1));

select @RunID = MAX(RunID) from @run;

UPDATE s
  SET s.StatusID = CASE WHEN t.StatusID = 1 THEN @pStatusID ELSE t.StatusID END,s.StatusDT = t.StatusDT,s.Err = t.Err
 FROM dbo.ETLStep s
 JOIN  dbo.ETLStepRun t ON s.StepID = t.StepID AND s.BatchID = t.BatchID
 JOIN @run r on t.RunID = r.RunID
WHERE s.BatchID = @BatchID;

UPDATE b
 SET b.EndTime = getdate()
    ,b.StatusID = @pStatusID
    ,b.StatusDT = getdate()
    ,b.Err = case when @pStatusID = 2 then 0 else 50103 end
FROM dbo.ETLBatchRun b
JOIN @run r ON b.RunID = r.RunID
WHERE b.BatchID = @BatchID;

DELETE dbo.ETLStepRun
OUTPUT deleted.RunID,deleted.BatchID,deleted.StepID,deleted.StatusDT
 ,CASE WHEN deleted.StatusID = 1 THEN @pStatusID ELSE deleted.StatusID END
 ,deleted.SPID,deleted.StepOrder,deleted.IgnoreErr
 ,deleted.Err,deleted.StartTime,deleted.EndTime,deleted.SeqGroup,deleted.PriGroup,deleted.SvcName
 INTO dbo.ETLStepRunHistory
(RunID,BatchID,StepID,StatusDT,StatusID,SPID,StepOrder,IgnoreErr
,Err,StartTime,EndTime,SeqGroup,PriGroup,SvcName)
FROM dbo.ETLStepRun s
JOIN @run r ON s.RunID = r.RunID
WHERE s.BatchID = @BatchID;

set @Rows = @@ROWCOUNT;
IF (@Debug = 1)
BEGIN
  SET @msg = '   Moved ' + CAST(@Rows as nvarchar(30)) + ' rows in ETLStepRunHistory for BatchID=' + CAST(@BatchID as nvarchar(30));
  exec dbo.prc_CreateProcessInfo @ProcessInfo out,@pHeader,@msg;
  exec dbo.prc_Print @ProcessInfo,@pHandle;
END

UPDATE b
 SET b.EndTime = r.EndTime
    ,b.StatusDT = r.StatusDT
    ,b.StatusID = r.StatusID
   ,b.Err = r.Err
FROM dbo.ETLBatch b
JOIN dbo.ETLBatchRun r ON b.BatchID = r.BatchID AND r.RunID = @RunID 
WHERE b.BatchID = @BatchID;


end try
begin catch
   set @Proc = ERROR_PROCEDURE()
   set @Msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   raiserror ('ERROR: PROC %s, MSG: %s',11,11,@Proc,@Msg) 
end catch

return @err
end;
GO
PRINT N'Creating [dbo].[prc_DE_MapAttributes]...';


GO
/*
--select * from ETLStepattribute where batchid = -15
declare @uid uniqueidentifier
declare @pHeader xml
declare @pContext xml
declare @pProcessRequest xml
declare @pAttributes xml
--set @uid = newid()
exec dbo.prc_CreateHeader @pHeader out,-10,3,null,4,15
exec dbo.prc_CreateContext @pContext out,@pHeader
exec dbo.prc_CreateProcessRequest @pProcessRequest out,@pHeader,@pContext,@uid
exec dbo.prc_ReadContextAttributes @pProcessRequest,@pAttributes out
select @pAttributes
exec dbo.prc_DE_MapAttributes @pAttributes out
select @pAttributes
*/
CREATE PROCEDURE dbo.prc_DE_MapAttributes
    @pAttributes xml([ETLController]) output
As
/******************************************************************
**D File:         ETLController.SQL
**
**D Desc:         map ETL attributes to de expected 
**
**D Auth:         andreys
**D Date:         12/11/2007
**
*******************************************************************
**      Change History
*******************************************************************
**  Date:            Author:            Description:
2010-05-16           andrey@biasintelligence.com           change the mapping logic to allow for pattern mapping
                                        to support multiple destinations
2017-05-02			 andrey								   add OData source support

******************************************************************/
SET NOCOUNT ON
DECLARE @Err INT
DECLARE @ProcErr INT
DECLARE @Cnt INT
DECLARE @ProcName sysname
DECLARE @msg nvarchar(max)
DECLARE @pr nvarchar(max)


SET @ProcName = OBJECT_NAME(@@PROCID)
SET @Err = 0
SET @ProcErr = 0

begin try

declare @attr table (AttributeName nvarchar(100),AttributeValue nvarchar(max))
declare @map table (AttributeName sysname,inOverride sysname null,outOverride sysname null)


-------------------------------------------------------------------------
-- de required mapping
-------------------------------------------------------------------------
insert @map
--header
          select 'BatchID',null,'Control.BatchID'
union all select 'StepID',null,'Control.StepID'
union all select 'RunID',null,'Control.RunID'
union all select 'Conversation',null,'Control.Conversation'
union all select 'ConversationGrp',null,'Control.ConversationGrp'
union all select 'Options',null,'Control.Options'
union all select 'Control.Database',null,null
union all select 'Control.Server',null,null

--action MoveData,RunPackage
union all select 'Action',null,'Action'
--RunPackage
union all select 'Package.File',null,null

--MoveData
union all select 'Source.Server',null,null
union all select 'Source.Database',null,null
union all select 'Source.ConnectionString',null,null
union all select 'Source.ConnectionQualifier',null,null

--action MoveData
union all select 'Destination%.Server',null,null
union all select 'Destination%.Database',null,null
union all select 'Destination%.TableName',null,null
union all select 'Destination%.ConnectionString',null,null
union all select 'Destination%.ConnectionQualifier',null,null

--Partition Control
union all select 'Destination.PartitionFunction',null,null
union all select 'Destination.PartitionFunctionInput',null,null
union all select 'Destination.PartitionFunctionOutput',null,null
union all select 'Destination%.MinPartitionID',null,null
union all select 'Destination%.MaxPartitionID',null,null


--action MoveData
union all select 'Source.Component',null,null
union all select 'StagingAreaRoot',null,null
union all select 'Source.StagingAreaTable','StagingAreaTable','StagingAreaTableName'
union all select 'Source.Query',null,null
union all select 'Source.QueryType',null,null
union all select 'Source.CompessionType',null,null
--OLEDBSource
union all select 'Source.OLEDB.AccessMode',null,null
union all select 'Source.OLEDB.SqlCommand','OLEDB.SqlCommand','Query'
union all select 'Source.OLEDB.CommandTimeout',null,'QueryTimeout'
--FlatFileSource
union all select 'Source.FlatFile.ColumnDelimiter',null,null
union all select 'Source.FlatFile.RecordDelimiter',null,null
union all select 'Source.FlatFile.ConnectionString',null,null
union all select 'Source.FlatFile.TextQualifier',null,null
union all select 'Source.FlatFile.Format',null,null
union all select 'Source.FlatFile.Unicode',null,null
union all select 'Source.FlatFile.ColumnNamesInFirstDataRow',null,null
--SharePointSource
union all select 'Source.SPList.BatchSize',null,null
union all select 'Source.SPList.CamlQuery',null,null
union all select 'Source.SPList.IncludeFolders',null,null
union all select 'Source.SPList.IsRecursive',null,null
union all select 'Source.SPList.SharePointCulture',null,null
union all select 'Source.SPList.SiteListName',null,null
union all select 'Source.SPList.SiteListViewName',null,null
union all select 'Source.SPList.SiteUrl',null,null
union all select 'Source.SPList.DecodeLookupColumns',null,null
union all select 'Source.SPList.IncludeHiddenColumns',null,null
union all select 'Source.SPList.UseConnectionManager',null,null
--ExcelSource
union all select 'Source.Excel.FilePath',null,null
union all select 'Source.Excel.Header',null,null
union all select 'Source.Excel.ExcelVersion',null,null
union all select 'Source.Excel.AccessMode',null,null
union all select 'Source.Excel.OpenRowset',null,null
union all select 'Source.Excel.SqlCommand',null,null
union all select 'Source.Excel.CommandTimeout',null,'QueryTimeout'
--AdoNetSource
union all select 'Source.ADONET.AccessMode',null,null
union all select 'Source.ADONET.SqlCommand','ADONET.SqlCommand','Query'
union all select 'Source.ADONET.CommandTimeout',null,'QueryTimeout'
union all select 'Source.ADONET.AllowImplicitStringConversion',null,null
--OdbcSource
union all select 'Source.ODBC.AccessMode',null,null
union all select 'Source.ODBC.SqlCommand','ODBC.SqlCommand','Query'
union all select 'Source.ODBC.CommandTimeout',null,'QueryTimeout'
union all select 'Source.ODBC.StatementTimeout',null,'QueryTimeout'
union all select 'Source.ODBC.BatchSize',null,null
union all select 'Source.ODBC.LobChunkSize',null,null
union all select 'Source.ODBC.ExposeCharColumnsAsUnicode',null,null
union all select 'Source.ODBC.FetchMethod',null,null
union all select 'Source.ODBC.DefaultCodePage',null,null
union all select 'Source.ODBC.BindNumericAs',null,null
union all select 'Source.ODBC.BindCharColumnsAs',null,null
--ODataSource
union all select 'Source.OData.DefaultStringLength',null,null
union all select 'Source.OData.CollectionName',null,null
union all select 'Source.OData.Query',null,null
union all select 'Source.OData.ResourcePath',null,null
union all select 'Source.OData.UseResourcePath',null,null

union all select 'Destination%.StagingAreaTable','StagingAreaTable','StagingAreaTableName'
union all select 'Destination%.Component',null,null
union all select 'Destination%.CompessionType',null,null
--FlatFileDestination
union all select 'Destination%.FlatFile.ColumnDelimiter',null,null
union all select 'Destination%.FlatFile.RecordDelimiter',null,null
union all select 'Destination%.FlatFile.ConnectionString',null,null
union all select 'Destination%.FlatFile.TextQualifier',null,null
union all select 'Destination%.FlatFile.Format',null,null
union all select 'Destination%.FlatFile.Unicode',null,null
union all select 'Destination%.FlatFile.Override',null,null
--OLEDBDestination
union all select 'Destination%.OLEDB.AccessMode',null,null
union all select 'Destination%.OLEDB.OpenRowset','OLEDB.OpenRowset','TableName'
union all select 'Destination%.OLEDB.TableName','OLEDB.TableName','TableName'
union all select 'Destination%.OLEDB.OpenRowsetVariable',null,null
union all select 'Destination%.OLEDB.FastLoadOptions',null,null
union all select 'Destination%.OLEDB.FastLoadKeepIdentity',null,null
union all select 'Destination%.OLEDB.FastLoadKeepNulls',null,null
union all select 'Destination%.OLEDB.FastLoadMaxInsertCommitSize',null,null
union all select 'Destination%.OLEDB.CommandTimeout',null,'QueryTimeout'
--SharepointDestination
union all select 'Destination%.SPList.BatchSize',null,null
union all select 'Destination%.SPList.CamlQuery',null,null
union all select 'Destination%.SPList.IncludeFolders',null,null
union all select 'Destination%.SPList.IsRecursive',null,null
union all select 'Destination%.SPList.SharePointCulture',null,null
union all select 'Destination%.SPList.SiteListName',null,null
union all select 'Destination%.SPList.SiteListViewName',null,null
union all select 'Destination%.SPList.SiteUrl',null,null
union all select 'Destination%.SPList.UseConnectionManager',null,null
--ExcelDestination
union all select 'Destination%.Excel.AccessMode',null,null
union all select 'Destination%.Excel.OpenRowset',null,null
union all select 'Destination%.Excel.CommandTimeout',null,'QueryTimeout'
union all select 'Destination%.Excel.FilePath',null,null
union all select 'Destination%.Excel.Header',null,null
union all select 'Destination%.Excel.ExcelVersion',null,null
--AdoNetDestination
union all select 'Destination%.ADONET.AccessMode',null,null
union all select 'Destination%.ADONET.TableOrViewName','ADONET.TableOrViewName','TableName'
union all select 'Destination%.ADONET.BatchSize',null,null
union all select 'Destination%.ADONET.UseBulkInsertWhenPossible',null,null
union all select 'Destination%.ADONET.CommandTimeout',null,'QueryTimeout'
--OdbcDestination
union all select 'Destination%.ODBC.InsertMethod',null,null
union all select 'Destination%.ODBC.BindCharColumnsAs',null,null
union all select 'Destination%.ODBC.BindNumericAs',null,null
union all select 'Destination%.ODBC.TableName','ODBC.TableName','TableName'
union all select 'Destination%.ODBC.BatchSize',null,null
union all select 'Destination%.ODBC.TransactionSize',null,null
union all select 'Destination%.ODBC.LobChunkSize',null,null
union all select 'Destination%.ODBC.CommandTimeout',null,'QueryTimeout'
union all select 'Destination%.ODBC.StatementTimeout',null,'QueryTimeout'
union all select 'Destination%.ODBC.DefaultCodePage',null,null
--SqlBulkDestination
union all select 'Destination%.SQLBULK.DefaultCodePage',null,null
union all select 'Destination%.SQLBULK.AlwaysUseDefaultCodePage',null,null
union all select 'Destination%.SQLBULK.BulkInsertTableName','SQLBULK.BulkInsertTableName','TableName'
union all select 'Destination%.SQLBULK.TableName','SQLBULK.TableName','TableName'
union all select 'Destination%.SQLBULK.BulkInsertCheckConstraints',null,null
union all select 'Destination%.SQLBULK.BulkInsertFirstRow',null,null
union all select 'Destination%.SQLBULK.BulkInsertFireTriggers',null,null
union all select 'Destination%.SQLBULK.BulkInsertKeepIdentity',null,null
union all select 'Destination%.SQLBULK.BulkInsertKeepNulls',null,null
union all select 'Destination%.SQLBULK.BulkInsertLastRow',null,null
union all select 'Destination%.SQLBULK.BulkInsertMaxErrors',null,null
union all select 'Destination%.SQLBULK.BulkInsertOrder',null,null
union all select 'Destination%.SQLBULK.BulkInsertTablock',null,null
union all select 'Destination%.SQLBULK.CommandTimeout',null,'QueryTimeout'
union all select 'Destination%.SQLBULK.Timeout',null,'QueryTimeout'
union all select 'Destination%.SQLBULK.MaxInsertCommitSize',null,null

--Packadge control
union all select 'SavePackage',null,null
union all select 'PackageFileName',null,null
union all select 'LoadPackage',null,null
--Staging control
union all select 'Destination%.Staging',null,null
union all select 'Destination%.StagingTableName',null,null
union all select 'Destination%.StagingTablePrepare',null,null
union all select 'Destination%.StagingTableUpload',null,null
union all select 'Destination%.UserOptions',null,null
--All
union all select 'QueryTimeout',null,null
union all select 'etl:Timeout',null,'QueryTimeout'
union all select 'UserOptions',null,null
union all select 'ForceStart',null,null
union all select 'Debug',null,null


;with xmlnamespaces('ETLController.XSD' as etl)
insert @attr
select b.b.value('./@Name[1]','nvarchar(100)'),b.b.value('(.)[1]','nvarchar(max)')
  from @pAttributes.nodes('/etl:Attributes') a(a)
  cross apply a.a.nodes('./etl:Attribute') b(b)

;with xmlnamespaces ('DeltaExtractor.XSD' as de, 'ETLController.XSD' as etl)
select @pAttributes = 
 (select case when m.outOverride is null then a.AttributeName
              else replace(a.AttributeName,isnull(m.inOverride,a.AttributeName),m.outOverride)
          end as '@Name',a.AttributeValue as '*'
    from @attr a
   left join @map m on a.AttributeName like m.AttributeName
     for xml path('etl:Attribute'),type, root('etl:Attributes'))

end try
begin catch
   set @msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   set @pAttributes = null
   raiserror (@msg,11,11)
end catch

RETURN @Err
GO
PRINT N'Creating [dbo].[prc_SystemParameterSet]...';


GO

CREATE PROCEDURE [dbo].[prc_SystemParameterSet] (
        @ParameterType VARCHAR(100) = NULL  -- The system parameter category.
      , @ParameterName VARCHAR(100) = NULL  -- The system parameter name.
	  , @EnvironmentName VARCHAR(100) = 'All' --The environment Name
    ) AS
/*
** Name:  [dbo].[prc_SystemParameterSet]
**
** Purpose:
**      Set current systemParameters values 
**
**/




    SET NOCOUNT ON

    /*
    ** Declarations.
    */

    DECLARE @FAIL smallint                      -- Failure code for RETURN.
    DECLARE @SUCCEED smallint                   -- Success code for RETURN.

    DECLARE @ProcedureName sysname              -- This procedure.
	DECLARE @msg nvarchar(1000)
	DECLARE @err int;

    /*
    ** Initialize the @ProcedureName for error messages.
    */

    SET @ProcedureName = OBJECT_NAME(@@PROCID)

    /*
    ** Initialize some constants.
    */

    SET @FAIL = 1
    SET @SUCCEED = 0

    /*
    ** Parameter Check:  @ParameterName
    ** Make sure that the @Parameter name exists if it is not NULL.
    */

    IF (@ParameterName IS NULL
        OR NOT EXISTS (SELECT *
                         FROM [dbo].[SystemParameters]
                        WHERE [ParameterType] = COALESCE(@ParameterType, '')
                          AND [ParameterName] = @ParameterName
						  AND [EnvironmentName] = @EnvironmentName))
    BEGIN
		SET @msg = '@ParameterName: ' + ISNULL(@ParameterName,'null') + ' is not found or null'; 
		THROW 50008, @msg, 1;
		RETURN @FAIL
    END

    /*
    ** Set the parameter value.
    */
	BEGIN TRY
    IF (@ParameterType IS NOT NULL)
        IF (@ParameterName IS NULL)
            UPDATE [dbo].[SystemParameters]
               SET [ParameterValue_Current] = ParameterValue_New
             WHERE [ParameterType] = @ParameterType
			 AND [EnvironmentName] = @EnvironmentName
        ELSE
            UPDATE [dbo].[SystemParameters]
               SET [ParameterValue_Current] = ParameterValue_New
             WHERE [ParameterName] = @ParameterName
               AND [ParameterType] = @ParameterType
			   AND [EnvironmentName] = @EnvironmentName
    ELSE
        UPDATE [dbo].[SystemParameters]
           SET [ParameterValue_Current] = ParameterValue_New
		WHERE [EnvironmentName] = @EnvironmentName


    RETURN @SUCCEED;
	END TRY
	BEGIN CATCH
		SET @err = ERROR_NUMBER();
		SET @msg = CAST(@err AS NVARCHAR(100)) + ': ' + ERROR_MESSAGE();
		THROW 50000, @msg,1;
		THROW @Err, @msg,1;
		RETURN @FAIL;
	END CATCH
GO
PRINT N'Creating [dbo].[prc_SystemParameterLet]...';


GO

CREATE PROCEDURE [dbo].[prc_SystemParameterLet] (
        @ParameterType varchar(100)				 -- The system parameter category.
      , @ParameterName varchar(100)				 -- The system parameter name.
      , @ParameterValue varchar(1024)			 -- The new setting.
      , @ParameterDefault varchar(1024) = NULL   -- The default setting.
      , @ParameterDesc varchar(1024) = NULL    -- Parameter description
      , @LastModifiedDtim datetime = NULL -- Last updated date/time.
      , @EffectiveImmediately bit = 0            -- 0= update later, 1= update now.
	  , @EnvironmentName VARCHAR(100) = 'All'  --The environment Name for which this variable is defined
	  , @Passphrase VARCHAR(100) = '7CCC1B81-EA9E-4710-AD10-43452169017E'
    ) AS

/*
** Name:  [dbo].[prc_SystemParameterLet]
**
**
** Purpose:
**      Set systemParameters Values
**
*
** */

    SET NOCOUNT ON

    /*
    ** Declarations.
    */

    DECLARE @FAIL smallint                      -- Failure code for RETURN.
    DECLARE @SUCCEED smallint                   -- Success code for RETURN.

    DECLARE @ProcedureName sysname              -- This procedure.
    DECLARE @RetCode int                        -- Procedure return code.
	DECLARE @msg nvarchar(1000)
	DECLARE @err int;
    /*
    ** Initialize the @ProcedureName for error messages.
    */

    SET @ProcedureName = OBJECT_NAME(@@PROCID)

    /*
    ** Initialize some constants.
    */

    SET @FAIL = 1
    SET @SUCCEED = 0

    /*
    ** Parameter Check:  @ParameterName
    ** Make sure that the @Parameter name exists and is not NULL.
    */

    IF (@ParameterName IS NULL)
        BEGIN
            SET @msg = '@ParameterName can not be null'; 
			THROW 50008, @msg, 1;
            RETURN @FAIL
        END

    /*
    ** Parameter Check:  @ParameterType
    ** Make sure that the parameter category exists and is not NULL.
    */

    IF (@ParameterType IS NULL)
        BEGIN
            SET @msg = '@ParameterType can not be null'; 
			THROW 50008, @msg, 1;
            RETURN @FAIL
        END

    /*
    ** If this is a new parameter, let's create it in the table.
    */

    BEGIN TRY
	IF NOT EXISTS (SELECT 1
                     FROM [dbo].[SystemParameters]
                    WHERE [ParameterType] = @ParameterType
                      AND [ParameterName] = @ParameterName
					  AND [EnvironmentName] = @EnvironmentName)
        BEGIN

            
			DECLARE @encrypted_default varbinary(max) = EncryptByPassphrase(@Passphrase  
				, @ParameterDefault, 1, HashBytes('SHA1', CONVERT( varbinary(100) 
				, @ParameterName)));
			
			INSERT INTO [dbo].[SystemParameters] (
                [ParameterType]
              , [ParameterName]
              , [ParameterValue_Current]
              , [ParameterValue_New]
              , [ParameterValue_Default]
              , [ParameterDesc]
			  , [EnvironmentName]
              , [LastModifiedBy]
              , [LastModifiedDtim]
            ) VALUES (
                @ParameterType
              , @ParameterName
              , NULL
              , NULL
              , @encrypted_default
              , @ParameterDesc
              , @EnvironmentName
			  , SYSTEM_USER
              , CURRENT_TIMESTAMP
            )

        END

    /*
    ** Before we update, let's make sure someone else hasn't already updated!
    */

    IF (@LastModifiedDtim IS NOT NULL)
        BEGIN
            IF NOT EXISTS (
                SELECT *
                  FROM [dbo].[SystemParameters]
                 WHERE [ParameterName] = @ParameterName
                   AND [ParameterType] = @ParameterType
                   AND CONVERT(varchar, [LastModifiedDtim], 121) = CONVERT(varchar, @LastModifiedDtim, 121)
                )
                BEGIN
					SET @msg = '@ParameterName was modified outside of scope of this transaction';
					THROW 50030,@msg,1;
                    RETURN @FAIL
                END
        END

    /*
    ** Set the parameter value.
    */


	DECLARE @encrypted_value varbinary(max) = EncryptByPassphrase(@Passphrase  
	, @ParameterValue, 1, HashBytes('SHA1', CONVERT( varbinary(100) 
	, @ParameterName)));


    UPDATE [dbo].[SystemParameters]
      WITH (HOLDLOCK)
       SET [ParameterValue_New] = @encrypted_value
         , [LastModifiedBy] = SYSTEM_USER
         , [LastModifiedDtim] = CURRENT_TIMESTAMP
     WHERE [ParameterName] = @ParameterName
       AND [ParameterType] = @ParameterType
	   AND [EnvironmentName] = @EnvironmentName

    /*
    ** Commit if necessary.
    */

    IF @EffectiveImmediately = 1
        BEGIN

            EXECUTE @RetCode = [dbo].[prc_SystemParameterSet]
                @ParameterType = @ParameterType
              , @ParameterName = @ParameterName
			  , @EnvironmentName = @EnvironmentName;

            IF (@RetCode <> 0) RETURN @FAIL;

        END

    RETURN @SUCCEED
	END TRY
	BEGIN CATCH
		SET @err = ERROR_NUMBER();
		SET @msg = CAST(@err AS NVARCHAR(100)) + ': ' + ERROR_MESSAGE();
		THROW 50000, @msg,1;
		RETURN @FAIL;
	END CATCH
GO
PRINT N'Creating [dbo].[prc_ReadProcessRequest]...';


GO
/*
declare @uid uniqueidentifier
declare @uid1 uniqueidentifier
declare @pHeader xml
declare @pContext xml
declare @pProcessRequest xml
set @uid = newid()
exec dbo.prc_CreateHeader @pHeader out,-10,null,null,4,10
exec dbo.prc_CreateContext @pContext out,@pHeader
exec dbo.prc_CreateProcessRequest @pProcessRequest out,@pHeader,@pContext,@uid
select @pProcessRequest
exec dbo.prc_ReadProcessRequest @pProcessRequest,@pHeader out,@pContext out,@uid1 out
select @pHeader
select @pContext
select @uid1
*/
CREATE PROCEDURE [dbo].[prc_ReadProcessRequest]
    @pProcessRequest xml([ETLController])
   ,@pHeader xml([ETLController]) = null output
   ,@pContext xml([ETLController]) = null output
   ,@pConversation uniqueidentifier = null output
   ,@pConversationGrp uniqueidentifier = null output
As
/******************************************************************
**D File:         prc_ReadProcessRequest.SQL
**
**D Desc:         read Request object
**
**D Auth:         andreys
**D Date:         10/27/2007
**
*******************************************************************
**      Change History
*******************************************************************
**  Date:            Author:            Description:
******************************************************************/
SET NOCOUNT ON
DECLARE @Err INT
DECLARE @ProcErr INT
DECLARE @Cnt INT
DECLARE @ProcName sysname
DECLARE @msg nvarchar(max)
declare @nHandle nvarchar(36)

SET @ProcName = OBJECT_NAME(@@PROCID)
SET @Err = 0
SET @ProcErr = 0

begin try
SELECT @pHeader = @pProcessRequest.query('declare namespace etl="ETLController.XSD";(/etl:ProcessRequest/etl:Header)[1]')
SELECT @pContext = @pProcessRequest.query('declare namespace etl="ETLController.XSD";(/etl:ProcessRequest/etl:Context)[1]')
SET @nHandle = @pProcessRequest.value('declare namespace etl="ETLController.XSD";(/etl:ProcessRequest/etl:SrcConversation)[1]','nvarchar(36)')
if len(@nHandle) = 36
   set @pConversation = cast(@nHandle as uniqueidentifier)
SET @nHandle = @pProcessRequest.value('declare namespace etl="ETLController.XSD";(/etl:ProcessRequest/etl:SrcConversationGrp)[1]','nvarchar(36)')
if len(@nHandle) = 36
   set @pConversationGrp = cast(@nHandle as uniqueidentifier)

end try
begin catch
   set @msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   set @pHeader = null
   raiserror (@msg,11,11)
end catch

RETURN @Err
GO
PRINT N'Creating [dbo].[prc_AttributeGet]...';


GO
/*
declare @pHeader xml
declare @pValue nvarchar(1000)
exec dbo.prc_CreateHeader @pHeader out,-20,1,null,4,1
--select @pHeader
exec dbo.prc_AttributeGet @pValue out,@pHeader,'test'
select @pValue

*/
create procedure [dbo].[prc_AttributeGet] (
    @pValue nvarchar(max) output
   ,@pHeader xml([ETLController])
   ,@pName varchar(100) = null
) as
begin
/******************************************************************************
** File:	[prc_CounterGet].sql
** Name:	[dbo].[prc_CounterGet]

** SD Location: VSS/Development/SubjectAreas/BI/Database/Schema/Procedure/[prc_CounterGet].sql:

** Desc:	return Counter value to the client
**          
**
** Params:
** Returns:
**
** Author:	andreys
** Date:	10/30/2007
** ****************************************************************************
** CHANGE HISTORY
** ****************************************************************************
** Date				Author	version	4	#bug			Description
** ----------------------------------------------------------------------------------------------------------

*/

set nocount on
declare @err                int
declare @proc               sysname
declare @msg                nvarchar(1000)
declare @debug              tinyint
declare @Options            int
declare @query              nvarchar(max)

declare @BatchID int
declare @StepID int
declare @RunID int
declare @ConstID int
declare @ProcErr int
declare @ProcName sysname

set @err = 0
set @proc = object_name(@@procid)
begin try

exec @ProcErr = dbo.[prc_ReadHeader] @pHeader,@BatchID out,@StepID out,@ConstID out,null,null,null
set @pValue = dbo.[fn_AttributeGet] (@BatchID,@StepID,@ConstID,@pName)

end try
begin catch
   set @Proc = ERROR_PROCEDURE()
   set @pValue = null
   set @Msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   raiserror ('ERROR: PROC %s, MSG: %s',11,11,@Proc,@Msg) 
end catch

return @err
end
GO
PRINT N'Creating [dbo].[prc_AttributeSet]...';


GO
/*
declare @pHeader xml
declare @pValue nvarchar(1000)
exec dbo.prc_CreateHeader @pHeader out,20,1,null,4,1
--select @pHeader
exec [dbo].[prc_AttributeSet] @pHeader,'TEST',null
exec dbo.prc_AttributeGet @pValue out,@pHeader,'TEST'
select @pValue
*/
create procedure [dbo].[prc_AttributeSet] (
        @pHeader xml([ETLController])
       ,@pName nvarchar(100)
       ,@pValue nvarchar(4000)
)
 as
begin
/******************************************************************************
** File:	[prc_AttributeSet].sql
** Name:	[dbo].[prc_AttributeSet]

** SD Location: VSS/Development/SubjectAreas/BI/Database/Schema/Function/prc_AttributeSet.sql:

** Desc:	set  user defined attribute value for batch/step/const combination
**          
**
** Params:
** Returns:
**
** Author:	andreys
** Date:	08/01/2007
** ****************************************************************************
** CHANGE HISTORY
** ****************************************************************************
** Date				Author	version	4	#bug			Description
** ----------------------------------------------------------------------------------------------------------

*/
set nocount on
declare @retcode int
declare @msg nvarchar(max)
declare @err int
declare @proc sysname

declare @BatchID int
declare @StepID int
declare @RunID int
declare @ConstID int
declare @ProcErr int
declare @ProcName sysname

set @retcode = 0
set @err = 0
set @proc = object_name(@@procid)
begin try
   exec @ProcErr = dbo.[prc_ReadHeader] @pHeader,@BatchID out,@StepID out,@ConstID out,null,null,null;
   exec @ProcErr = dbo.prc_ETLAttributeSet @BatchID,@StepID,@ConstID,@pName,@pValue;
end try
begin catch
   set @retcode = ERROR_NUMBER()
   set @msg = ERROR_MESSAGE()
   raiserror (@msg,11,11)
end catch
   return (@retcode)
end
GO
PRINT N'Creating [dbo].[prc_CounterGet]...';


GO
/*
select * from ETLBatchRun where batchid = 130

--select * from ETLStepRunCounter
--insert ETLStepRunCounter
--values(-20,1,4,'test','xxx')
--insert ETLStepRunCounter
--values(-20,1,3,'test1','yyy')
declare @pHeader xml
declare @pCounters xml
declare @pValue nvarchar(1000)
exec dbo.prc_CreateHeader @pHeader out,-20,1,null,4,1
--select @pHeader
exec dbo.prc_CreateCounters @pCounters out,@pHeader,'test'
exec dbo.prc_CounterGet @pValue out,@pHeader,'test'
select @pCounters
select @pValue

*/
create procedure [dbo].[prc_CounterGet] (
    @pValue nvarchar(max) output
   ,@pHeader xml([ETLController])
   ,@pName varchar(100) = null
) as
begin
/******************************************************************************
** File:	[ETL_CounterGet].sql
** Name:	[dbo].[ETL_CounterGet]

** SD Location: VSS/Development/SubjectAreas/BI/Database/Schema/Procedure/[ETL_CounterGet].sql:

** Desc:	return Counter value to the client
**          
**
** Params:
** Returns:
**
** Author:	andreys
** Date:	10/30/2007
** ****************************************************************************
** CHANGE HISTORY
** ****************************************************************************
** Date				Author	version	4	#bug			Description
** ----------------------------------------------------------------------------------------------------------

*/

set nocount on
declare @err                int
declare @proc               sysname
declare @msg                nvarchar(1000)
declare @debug              tinyint
declare @Options            int
declare @query              nvarchar(max)

declare @BatchID int
declare @StepID int
declare @RunID int
declare @LGRunID int
declare @ProcErr int
declare @ProcName sysname
declare @Counters xml(ETLController)

set @err = 0
begin try

exec @ProcErr = dbo.[prc_ReadHeader] @pHeader,null,null,null,@RunID out,null,null
exec @ProcErr = dbo.[prc_CreateCounters] @Counters out, @pHeader, @pName
exec @ProcErr = dbo.[prc_ReadCounter] @Counters,@pName,@pValue out,@RunID

end try
begin catch
   set @Proc = ERROR_PROCEDURE()
   set @pValue = null
   set @Msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   raiserror ('ERROR: PROC %s, MSG: %s',11,11,@Proc,@Msg) 
end catch

return @err
end
GO
PRINT N'Creating [dbo].[prc_CounterSet]...';


GO
/*
declare @pHeader xml
declare @pCounters xml
declare @pValue nvarchar(1000)
exec dbo.prc_CreateHeader @pHeader out,-20,1,null,5,1
--select @pHeader
exec dbo.prc_CounterSet @pHeader,'test2','bbb'
exec dbo.prc_CounterGet @pValue out,@pHeader,'test2'
--select @pCounters
select @pValue

*/
create procedure [dbo].[prc_CounterSet] (
    @pHeader xml([ETLController])
   ,@pName varchar(100) = null
   ,@pValue nvarchar(max)

) as
begin
/******************************************************************************
** File:	[ETL_CounterSet].sql
** Name:	[dbo].[ETL_CounterSet]

** SD Location: VSS/Development/SubjectAreas/BI/Database/Schema/Procedure/[ETL_CounterSet].sql:

** Desc:	set client Counter value
**          
**
** Params:
** Returns:
**
** Author:	andreys
** Date:	10/30/2007
** ****************************************************************************
** CHANGE HISTORY
** ****************************************************************************
** Date				Author	version	4	#bug			Description
** ----------------------------------------------------------------------------------------------------------

*/

set nocount on
declare @err                int
declare @proc               sysname
declare @msg                nvarchar(1000)
declare @debug              tinyint
declare @Options            int
declare @query              nvarchar(max)

declare @BatchID int
declare @StepID int
declare @RunID int
declare @LGRunID int
declare @ProcErr int
declare @ProcName sysname
declare @Counters xml(ETLController)

set @err = 0
begin try

exec @ProcErr = dbo.[prc_ReadHeader] @pHeader,@BatchID out,@StepID out,null,@RunID out,null,null

   if exists(select 1 from dbo.[ETLStepRunCounter]
                      where RunID = @RunID and StepID = @StepID
                        and BatchID = @BatchID and CounterName = @pName)
   begin
      if @pValue is null
      begin
         delete dbo.[ETLStepRunCounter]
          where RunID = @RunID and StepID = @StepID
            and BatchID = @BatchID and CounterName = @pName
         raiserror('record was deleted from dbo.ETLStepRunCounter',0,1)
      end
      else
      begin
         update dbo.[ETLStepRunCounter]
         set CounterValue = @pValue
          where RunID = @RunID and StepID = @StepID
            and BatchID = @BatchID and CounterName = @pName
         raiserror('record was updated in dbo.ETLStepRunCounter',0,1)
      end
   end
   else
   begin
      insert dbo.[ETLStepRunCounter]
      (RunID,StepID,CounterName,BatchID,CounterValue)
      values(@RunID,@StepID,@pName,@BatchID,@pValue)
      raiserror('record was inserted into dbo.ETLStepRunCounter',0,1)
   end


end try
begin catch
   set @Proc = ERROR_PROCEDURE()
   set @pValue = null
   set @Msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   raiserror ('ERROR: PROC %s, MSG: %s',11,11,@Proc,@Msg) 
end catch

return @err
end
GO
PRINT N'Creating [dbo].[prc_CreateContext]...';


GO
/*
select * from ETLBatch
select * from ETLStep where batchid = -320
prc_ETLAttributeSet 60,null,null,'DsvVersion','2'
prc_ETLAttributeSet 60,3,null,'DsvObject','LastHourMR'
prc_ETLAttributeSet 60,2,null,'DsvObject','AdType'
declare @pHeader xml
declare @pContext xml
exec dbo.prc_CreateHeader @pHeader out,340,2,null,4,1,15
--select @pHeader
exec dbo.prc_CreateContext @pContext out,@pHeader
select @pContext
*/
CREATE PROCEDURE [dbo].[prc_CreateContext]
    @pContext xml([ETLController]) output
   ,@pHeader xml([ETLController])
As
/******************************************************************
**D File:         prc_CreateContext.SQL
**
**D Desc:         return Context object
**
**D Auth:         andreys
**D Date:         10/27/2007
**
*******************************************************************
**      Change History
*******************************************************************
**  Date:            Author:            Description:
**  5/20/2008        andreys            remove context resolution
**  10/15/2011       andreys            add controller and node globals
******************************************************************/
SET NOCOUNT ON
DECLARE @Err INT
DECLARE @ProcErr INT
DECLARE @Cnt INT
DECLARE @ProcName sysname
DECLARE @msg nvarchar(max)

declare @BatchID int
declare @StepID int
declare @ConstID int
declare @RunID int
declare @Options int
declare @debug int
declare @Scope int
declare @AttributeScope int

declare @id int
declare @type tinyint
declare @b int
declare @s int
declare @c int
declare @Name nvarchar(100)
declare @Value1 nvarchar(max)
declare @Value2 nvarchar(max)
declare @nValue nvarchar(max)
declare @ProcessInfo xml(ETLController)

SET @ProcName = OBJECT_NAME(@@PROCID)
SET @Err = 0
SET @ProcErr = 0

declare @a as table
 (id int identity(1,1)
 ,BatchID int
 ,StepID int null
 ,ConstID int null
 ,AttributeName nvarchar(100)
 ,AttributeValue nvarchar(max)
 ,AttributeScope tinyint
 ,CompleteFlag tinyint null
 ,unique (BatchID,StepID,ConstId,AttributeName,AttributeScope)
)

declare @ab as table
 (aid int
 ,bid int
 ,isexec tinyint
)

begin try
exec @ProcErr = dbo.[prc_ReadHeader] @pHeader,@BatchID out,@StepID out,@ConstID out,@RunID out,@Options out,@Scope out
set @debug = nullif(@Options & 1,0)


if (@debug = 1)
begin
   SET @msg =  'BEGIN Procedure ' + @ProcName + ' with context'
         + ' BatchID=' + isnull(cast(@BatchID as nvarchar(10)),'null')
         + ' StepID=' + isnull(cast(@StepID as nvarchar(10)),'null')
         + ' ConstID=' + isnull(cast(@ConstID as nvarchar(10)),'null')
         + ' RunID=' + isnull(cast(@RunID as nvarchar(10)),'null')
         + ' Scope=' + isnull(cast(@Scope as nvarchar(10)),'null')

   exec @ProcErr = dbo.[prc_CreateProcessInfo] @ProcessInfo out,@pHeader,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo
end
-------------------------------------------------------------------
--Process context attributes
-------------------------------------------------------------------
if (@StepID is null and (@Scope is null or @Scope & 4 = 4))
begin
   insert @a (BatchID,StepID,ConstID,AttributeName,AttributeValue,AttributeScope)
   select BatchID,null,ConstID,AttributeName,AttributeValue,1
     from dbo.[ETLBatchConstraintAttribute]
    where BatchID = @BatchID  and (ConstID = @ConstID or @ConstID is null)
end

if ((@StepID is not null or (@StepID is null and @ConstID is null)) and (@Scope is null or @Scope & 8 = 8))
begin
   insert @a (BatchID,StepID,ConstID,AttributeName,AttributeValue,AttributeScope)
   select  BatchID,StepID,ConstID,AttributeName,AttributeValue,2
     from dbo.[ETLStepConstraintAttribute]
    where BatchID = @BatchID and (StepID = @StepID or @StepID is null) and (ConstID = @ConstID or @ConstID is null)
end

if ((@StepID is not null or @ConstID is null) and (@Scope is null or @Scope & 2 = 2))
begin
   insert @a (BatchID,StepID,ConstID,AttributeName,AttributeValue,AttributeScope)
   select i.BatchID,i.StepID,null,i.AttributeName,i.AttributeValue,3
     from dbo.[ETLStepAttribute] i
    where i.BatchID = @BatchID and (i.StepID = @StepID or @StepID is null)
end

if(@Scope is null or @Scope & 1 = 1)
begin
    insert @a (BatchID,StepID,ConstID,AttributeName,AttributeValue,AttributeScope)
    select i.BatchID,null,null,i.AttributeName,i.AttributeValue,4
      from dbo.[ETLBatchAttribute] i
     where i.BatchID = @BatchID
end

--execution context
insert @a (BatchID,StepID,ConstID,AttributeName,AttributeValue,AttributeScope)
select null,null,null,'@BatchID' as AttributeName,cast(@BatchID as nvarchar(30)) as AttributeValue,0
union all
select null,null,null,'@StepID' as AttributeName,cast(@StepID as nvarchar(30)) as AttributeValue,0
union all
select null,null,null,'@ConstID' as AttributeName,cast(@ConstID as nvarchar(30)) as AttributeValue,0
union all
select null,null,null,'@RunID' as AttributeName,cast(@RunID as nvarchar(30)) as AttributeValue,0
union all
select null,null,null,'@Options' as AttributeName,cast(@Options as nvarchar(30)) as AttributeValue,0

-------------------------------------------------------------------
--add dsvobjectproperty attributes if any
-------------------------------------------------------------------
--declare @DsvID int
--select top (1) @DsvID = AttributeValue from @a where AttributeName = 'DsvVersion'
--if (@DsvID is not null)
--begin
--   insert @a (BatchID,StepID,ConstID,AttributeName,AttributeValue,AttributeScope)
--   select a.BatchID,a.StepID,a.ConstID,b.oName,b.oValue,a.AttributeScope
--     from @a a
--   cross apply dbo.fn_ETLObjectProperty(@DsvID,a.AttributeValue) as b
--    where a.AttributeName = 'DsvObject'
--end

/* dont need to do this here
** move all attribute resolution code to prc_ReadContextAttributes
-------------------------------------------------------------------
--relationship table
-------------------------------------------------------------------
insert @ab
select a.id,b.id,0
from @a a
join @a b on charindex('<' + a.AttributeName + '>',b.AttributeValue) > 0
      and (b.BatchID = a.BatchID or (a.BatchID is null and b.AttributeScope <= a.AttributeScope))
      and ((b.BatchID = a.BatchID and b.StepID = a.StepID) or (a.StepID  is null and b.AttributeScope <= a.AttributeScope))
      and ((b.BatchID = a.BatchID and b.StepID = a.StepID and b.ConstID = a.ConstID)
       or  (b.BatchID = a.BatchID and b.StepID is null and b.ConstID = a.ConstID)
       or (a.ConstID is null and b.AttributeScope <= a.AttributeScope))

union all select a.id,b.id,1
from @a a
join @a b on charindex('<' + a.AttributeName + '*>',b.AttributeValue) > 0
      and (b.BatchID = a.BatchID or (a.BatchID is null and b.AttributeScope <= a.AttributeScope))
      and ((b.BatchID = a.BatchID and b.StepID = a.StepID) or (a.StepID  is null and b.AttributeScope <= a.AttributeScope))
      and ((b.BatchID = a.BatchID and b.StepID = a.StepID and b.ConstID = a.ConstID)
       or  (b.BatchID = a.BatchID and b.StepID is null and b.ConstID = a.ConstID)
       or (a.ConstID is null and b.AttributeScope <= a.AttributeScope))

-------------------------------------------------------------------
--replace dynamic parameters if any
-------------------------------------------------------------------
WHILE (1=1)
BEGIN
    SET @id = null
    SELECT top(1) @id = t.id
                 ,@Name = t.AttributeName
                 ,@b = t.BatchID
                 ,@s = t.StepID
                 ,@c = t.ConstID
                 ,@Value1 = t.AttributeValue
                 ,@AttributeScope = t.AttributeScope
      FROM @a t
      WHERE t.CompleteFlag IS NULL
        AND NOT EXISTS(SELECT 1 FROM @ab t1
                         JOIN @a t2 ON t1.aid = t2.id WHERE  t.id = t1.bid AND t2.CompleteFlag IS NULL) --no parents
        AND EXISTS(SELECT 1 FROM @ab t2 WHERE  t.id = t2.aid) --have children
      order by t.AttributeScope,t.id

    IF (@id is null)
       BREAK

    update a set a.AttributeValue = REPLACE(a.AttributeValue,'<' + @Name + '>',isnull(@Value1,''))
      from @a a
      join @ab ab on a.id = ab.bid and ab.aid = @id and ab.isexec = 0

   --execute value to get the value
   IF (@Value1 is not null
       AND EXISTS(SELECT 1 FROM @ab ab WHERE ab.aid = @id and ab.isexec = 1)
       AND )
   BEGIN
      SET @nValue = 'select top 1 @value = (' + @Value1 + ')'
      SET @Value2 = null
      EXEC sp_executesql @nValue,N'@value varchar(max) output',@value = @value2 out

      update a set a.AttributeValue = REPLACE(a.AttributeValue,'<' + @Name + '*>',isnull(@Value2,''))
        from @a a
        join @ab ab on a.id = ab.bid and ab.aid = @id and ab.isexec = 1
   END


   update @a set CompleteFlag = 1 where id = @id
END
*/
-------------------------------------------------------------------
--build context object
-------------------------------------------------------------------

;WITH XMLNAMESPACES ('ETLController.XSD' as etl)
select @pContext = 
 (select b.BatchID as '@BatchID'
,b.BatchName as '@BatchName'
,b.BatchDesc as '@BatchDesc'
,b.IgnoreErr as '@IgnoreErr'
,b.RestartOnErr as '@Restart'
,(select top 1 ba1.AttributeValue from dbo.[ETLBatchAttribute] ba1 where b.BatchID = ba1.BatchID and ba1.AttributeName in ('HISTRET','etl:HistRet')) as '@HistRet'
,(select top 1 ba2.AttributeValue from dbo.[ETLBatchAttribute] ba2 where b.BatchID = ba2.BatchID and ba2.AttributeName in ('MaxThread','etl:MaxThread')) as '@MaxThread'
,(select top 1 ba3.AttributeValue from dbo.[ETLBatchAttribute] ba3 where b.BatchID = ba3.BatchID and ba3.AttributeName in ('Ping','etl:Ping')) as '@Ping'
,(select top 1 ba4.AttributeValue from dbo.[ETLBatchAttribute] ba4 where b.BatchID = ba4.BatchID and ba4.AttributeName in ('Timeout','etl:Timeout')) as '@Timeout'
,(select top 1 ba5.AttributeValue from dbo.[ETLBatchAttribute] ba5 where b.BatchID = ba5.BatchID and ba5.AttributeName in ('Lifetime','etl:Lifetime')) as '@Lifetime'
,(select top 1 ba6.AttributeValue from dbo.[ETLBatchAttribute] ba6 where b.BatchID = ba6.BatchID and ba6.AttributeName in ('Retry','etl:Retry')) as '@Retry'
,(select top 1 ba7.AttributeValue from dbo.[ETLBatchAttribute] ba7 where b.BatchID = ba7.BatchID and ba7.AttributeName in ('Delay','etl:Delay')) as '@Delay'
--,b.BatchDesc as 'Desc'
,p1.ProcessID as 'etl:OnSuccess/@ProcessID', p1.ScopeID as 'etl:OnSuccess/@ScopeID',p1.Process as 'etl:OnSuccess/etl:Process',p1.Param as 'etl:OnSuccess/etl:Param'
,p2.ProcessID as 'etl:OnFailure/@ProcessID', p2.ScopeID as 'etl:OnFailure/@ScopeID',p2.Process as 'etl:OnFailure/etl:Process',p2.Param as 'etl:OnFailure/etl:Param'
--batch attributes
--,(select ba.AttributeName as '@Name',ba.AttributeValue as '*' from dbo.ETLBatchAttribute ba
--   where b.BatchID = ba.BatchID
--     and ba.AttributeName not in ('HISTRET','MAXTHREAD','PING','TIMEOUT','LIFETIME','RETRY','DELAY')
--     for xml path('etl:Attribute'),type) as 'etl:Attributes'
,(select ba.AttributeName as '@Name',ba.AttributeValue as '*' from @a ba
   where b.BatchID = ba.BatchID and ba.StepID is null and ba.ConstID is null
     and ba.AttributeName not in ('HISTRET','MAXTHREAD','PING','TIMEOUT','LIFETIME','RETRY','DELAY',
     'etl:HISTRET','etl:MAXTHREAD','etl:PING','etl:TIMEOUT','etl:LIFETIME','etl:RETRY','etl:DELAY')
     for xml path('etl:Attribute'),type) as 'etl:Attributes'

--
--batch constraints
,(select
 bc.ConstID as '@ConstID'
,bc.ConstOrder as '@ConstOrder'
,bc.WaitPeriod as '@WaitPeriod'
,(select top 1 bca1.AttributeValue from dbo.[ETLBatchConstraintAttribute] bca1 where bc.BatchID = bca1.BatchID and bc.ConstID = bca1.ConstID and bca1.AttributeName in ('Disabled','etl:Disabled')) as '@Disabled'
,(select top 1 bca2.AttributeValue from dbo.[ETLBatchConstraintAttribute] bca2 where bc.BatchID = bca2.BatchID and bc.ConstID = bca2.ConstID and bca2.AttributeName in ('Ping','etl:Ping')) as '@Ping'
,p0.ProcessID as 'etl:Process/@ProcessID', p0.ScopeID as 'etl:Process/@ScopeID',p0.Process as 'etl:Process/etl:Process',p0.Param as 'etl:Process/etl:Param'
--batch constraint attributes
--,(select bca.AttributeName as '@Name',bca.AttributeValue as '*'
--    from dbo.ETLBatchConstraintAttribute bca
--   where bc.BatchID = bca.BatchID and bc.ConstID = bca.ConstID
--     and bca.AttributeName not in ('DISABLED','PING')
--     for xml path('etl:Attribute'),type) as 'etl:Attributes'
,(select bca.AttributeName as '@Name',bca.AttributeValue as '*'
    from @a bca
   where bc.BatchID = bca.BatchID and bc.ConstID = bca.ConstID and bca.StepID is null
     and bca.AttributeName not in ('DISABLED','PING','etl:DISABLED','etl:PING')
     for xml path('etl:Attribute'),type) as 'etl:Attributes'
--
   from dbo.[ETLBatchConstraint] bc
   left join dbo.[ETLProcess] p0 on bc.ProcessID = p0.ProcessID
  where b.BatchID = bc.BatchID and (@StepID is null and (bc.ConstID = @ConstID or @ConstID is null)) and (@Scope is null or @Scope & 4 = 4) 
  for xml path('etl:Constraint'),type) as 'etl:Constraints'
--
--step
,(select s.StepID as '@StepID'
,s.StepName as '@StepName'
,s.StepDesc as '@StepDesc'
,s.IgnoreErr as '@IgnoreErr'
,s.StepOrder as '@StepOrder'
,(select top 1 sa1.AttributeValue from dbo.[ETLStepAttribute] sa1 where s.BatchID = sa1.BatchID and s.StepID = sa1.StepID and sa1.AttributeName in ('DISABLED','etl:Disabled')) as '@Disabled'
,(select top 1 sa2.AttributeValue from dbo.[ETLStepAttribute] sa2 where s.BatchID = sa2.BatchID and s.StepID = sa2.StepID and sa2.AttributeName in ('SeqGroup','etl:SeqGroup')) as '@SeqGroup'
,(select top 1 sa3.AttributeValue from dbo.[ETLStepAttribute] sa3 where s.BatchID = sa3.BatchID and s.StepID = sa3.StepID and sa3.AttributeName in ('PriGroup','etl:PriGroup')) as '@PriGroup'
,(select top 1 sa4.AttributeValue from dbo.[ETLStepAttribute] sa4 where s.BatchID = sa4.BatchID and s.StepID = sa4.StepID and sa4.AttributeName in ('Retry','etl:Retry')) as '@Retry'
,(select top 1 sa5.AttributeValue from dbo.[ETLStepAttribute] sa5 where s.BatchID = sa5.BatchID and s.StepID = sa5.StepID and sa5.AttributeName in ('Delay','etl:Delay')) as '@Delay'
,(select top 1 sa6.AttributeValue from dbo.[ETLStepAttribute] sa6 where s.BatchID = sa6.BatchID and s.StepID = sa6.StepID and sa6.AttributeName in ('Restart','etl:Restart')) as '@Restart'
,(select top 1 sa7.AttributeValue from dbo.[ETLStepAttribute] sa7 where s.BatchID = sa7.BatchID and s.StepID = sa7.StepID and sa7.AttributeName in ('LoopGroup','etl:LoopGroup')) as '@LoopGroup'
,(select top 1 sa8.AttributeValue from dbo.[ETLStepAttribute] sa8 where s.BatchID = sa8.BatchID and s.StepID = sa8.StepID and sa8.AttributeName in ('Timeout','etl:Timeout')) as '@Timeout'
--,s.StepDesc as 'Desc'
,p0.ProcessID as 'etl:Process/@ProcessID', p0.ScopeID as 'etl:Process/@ScopeID',p0.Process as 'etl:Process/etl:Process',p0.Param as 'etl:Process/etl:Param'
,p1.ProcessID as 'etl:OnSuccess/@ProcessID', p1.ScopeID as 'etl:OnSuccess/@ScopeID',p1.Process as 'etl:OnSuccess/etl:Process',p1.Param as 'etl:OnSuccess/etl:Param'
,p2.ProcessID as 'etl:OnFailure/@ProcessID', p2.ScopeID as 'etl:OnFailure/@ScopeID',p2.Process as 'etl:OnFailure/etl:Process',p2.Param as 'etl:OnFailure/etl:Param'
--step attributes
--,(select sa.AttributeName as '@Name',sa.AttributeValue as '*' from dbo.ETLStepAttribute sa
--   where s.BatchID = sa.BatchID and s.StepID = sa.StepID
--     and sa.AttributeName not in ('DISABLED','SEQGROUP','PRIGROUP','RETRY','RESTART')
--     for xml path('etl:Attribute'),type) as 'etl:Attributes'
,(select sa.AttributeName as '@Name',sa.AttributeValue as '*' from @a sa
   where s.BatchID = sa.BatchID and s.StepID = sa.StepID and sa.ConstID is null
     and sa.AttributeName not in ('DISABLED','SEQGROUP','PRIGROUP','RETRY','DELAY','RESTART','LOOPGROUP','TIMEOUT')
     and sa.AttributeName not in ('etl:DISABLED','etl:SEQGROUP','etl:PRIGROUP','etl:RETRY','etl:DELAY','etl:RESTART','etl:LOOPGROUP','etl:TIMEOUT')
     for xml path('etl:Attribute'),type) as 'etl:Attributes'
--
--step constraints
,(select
 sc.ConstID as '@ConstID'
,sc.ConstOrder as '@ConstOrder'
,sc.WaitPeriod as '@WaitPeriod'
,(select top 1 sca1.AttributeValue from dbo.[ETLStepConstraintAttribute] sca1 where sc.BatchID = sca1.BatchID and sc.StepID = sca1.StepID and sc.ConstID = sca1.ConstID and sca1.AttributeName in ('DISABLED','etl:Disabled')) as '@Disabled'
,(select top 1 sca2.AttributeValue from dbo.[ETLStepConstraintAttribute] sca2 where sc.BatchID = sca2.BatchID and sc.StepID = sca2.StepID and sc.ConstID = sca2.ConstID and sca2.AttributeName in ('Ping','etl:Ping')) as '@Ping'
,p0.ProcessID as 'etl:Process/@ProcessID', p0.ScopeID as 'etl:Process/@ScopeID',p0.Process as 'etl:Process/etl:Process',p0.Param as 'etl:Process/etl:Param'
--step constraint attributes
--,(select sca.AttributeName as '@Name',sca.AttributeValue as '*'
--    from dbo.ETLStepConstraintAttribute sca where sc.BatchID = sca.BatchID and sc.StepID = sca.StepID and sc.ConstID = sca.ConstID
--     and sca.AttributeName not in ('DISABLED','PING')
--    for xml path('etl:Attribute'),type) as 'etl:Attributes'
,(select sca.AttributeName as '@Name',sca.AttributeValue as '*'
    from @a sca where sc.BatchID = sca.BatchID and sc.StepID = sca.StepID and sc.ConstID = sca.ConstID
     and sca.AttributeName not in ('DISABLED','PING','etl:DISABLED','etl:PING')
    for xml path('etl:Attribute'),type) as 'etl:Attributes'
--
   from dbo.[ETLStepConstraint] sc
   left join dbo.[ETLProcess] p0 on sc.ProcessID = p0.ProcessID
   where s.BatchID = sc.BatchID and s.StepID = sc.StepID  and (sc.ConstID = @ConstID or @ConstID is null) and (@Scope is null or @Scope & 8 = 8)
   for xml path('etl:Constraint'),type) as 'etl:Constraints'
--
 from dbo.[ETLStep] s
 left join dbo.[ETLProcess] p0 on s.StepProcID = p0.ProcessID
 left join dbo.[ETLProcess] p1 on s.OnSuccessID = p1.ProcessID
 left join dbo.[ETLProcess] p2 on s.OnFailureID = p2.ProcessID
 where b.BatchID = s.BatchID and (s.StepID = @StepID or @StepID is null) and (@Scope is null or @Scope & 2 = 2)
   for xml path('etl:Step'),type) as 'etl:Steps'
 from dbo.[ETLBatch] b
 left join dbo.[ETLProcess] p1 on b.OnSuccessID = p1.ProcessID
 left join dbo.[ETLProcess] p2 on b.OnFailureID = p2.ProcessID
 where (b.BatchID = @BatchID) and (@Scope is null or @Scope & 1 = 1)
for xml path ('etl:Context'),type)

end try
begin catch
   set @msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   set @pHeader = null
   raiserror (@msg,11,11)
end catch

if (@debug = 1)
begin
   SET @msg =  'END Procedure ' + @ProcName
   exec @ProcErr = dbo.[prc_CreateProcessInfo] @ProcessInfo out,@pHeader,@msg,@Err
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo
end

RETURN @Err
GO
PRINT N'Creating [dbo].[prc_RemoveContext]...';


GO
/*

declare @Header xml
declare @pBatchName nvarchar(30)
set @pBatchName = 'xxx' 
exec prc_RemoveContext @pBatchName,null,'debug'
*/
CREATE PROCEDURE [dbo].[prc_RemoveContext]
    @pBatchName nvarchar(30)
   ,@pHandle uniqueidentifier = null 
   ,@pOptions nvarchar(100) = null
As
/******************************************************************
**D File:         prc_PersistContext.SQL
**
**D Desc:         create persist context into ETLBatch tables
**
** @Options       debug

**D Auth:         andreys
**D Date:         10/27/2007
**
*******************************************************************
**      Change History
*******************************************************************
**  Date:            Author:            Description:
******************************************************************/
SET NOCOUNT ON
DECLARE @Err INT
DECLARE @ProcErr INT
DECLARE @Cnt INT
DECLARE @ProcName sysname
DECLARE @msg nvarchar(max)
DECLARE @trancount int
DECLARE @debug tinyint

DECLARE @BatchID int

DECLARE @Header xml(ETLController)
DECLARE @ProcessInfo xml(ETLController)

SET @ProcName = OBJECT_NAME(@@PROCID)
SET @Err = 0
SET @ProcErr = 0
SET @trancount = @@trancount


begin try
set @debug = case when charindex('debug',@pOptions) > 0 then 1 else 0 end

select @BatchID = BatchID
  from dbo.[ETLBatch] where BatchName = @pBatchName

if (@BatchID is null)
BEGIN
   --SET @Err = 50101
   --SET @msg = '   ERROR pContext: BatchName=' + @pBatchName + ' not found'
   --RAISERROR(@msg,11,11)
   --batch not found and nothing to remove
   SET @msg = '   WARNING pContext: BatchName=' + @pBatchName + ' not found'
   RAISERROR(@msg,0,1)
   RETURN @Err 
END

exec [prc_CreateHeader] @Header out,@BatchID,null,null,0,@debug,15
if (@debug = 1)
begin
   SET @msg =  'BEGIN Procedure ' + @ProcName + ' for BatchName=' + isnull(@pBatchName,'NULL')
            + ' (' + isnull(cast(@BatchID as nvarchar(10)),'NULL') + ')'

   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

--BEGIN TRAN

   delete dbo.[ETLStepConstraintAttribute] where BatchID = @BatchID
   delete dbo.[ETLStepConstraint] where BatchID = @BatchID
   delete dbo.[ETLStepAttribute] where BatchID = @BatchID
   delete dbo.[ETLStep] where BatchID = @BatchID
   delete dbo.[ETLBatchConstraintAttribute] where BatchID = @BatchID
   delete dbo.[ETLBatchConstraint] where BatchID = @BatchID
   delete dbo.[ETLBatchAttribute] where BatchID = @BatchID
   delete dbo.[ETLBatch] where BatchID = @BatchID

--COMMIT TRAN

IF (@debug = 1)
BEGIN
   SET @msg = 'END Procedure ' + @ProcName
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
END

end try
begin catch
   if @Trancount < @@trancount
      ROLLBACK TRAN

   set @msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   raiserror (@msg,11,11)
end catch

RETURN @Err
GO
PRINT N'Creating [dbo].[prc_ReadContextAttributes]...';


GO
/*
declare @pHeader xml
declare @pContext xml
declare @pProcessRequest xml
declare @pAttributes xml
exec dbo.prc_CreateHeader @pHeader out,301,2,null,4,15
exec dbo.prc_CreateContext @pContext out,@pHeader
select @pcontext
exec dbo.prc_CreateProcessRequest @pProcessRequest out,@pHeader,@pContext
select @pProcessRequest
exec dbo.prc_ReadContextAttributes @pProcessRequest,@pAttributes out
select @pAttributes
*/
CREATE PROCEDURE [dbo].[prc_ReadContextAttributes]
    @pProcessRequest xml([ETLController])
   ,@pAttributes xml([ETLController]) = null output
As
/******************************************************************
**D File:         prc_ReadContextAttributes.SQL
**
**D Desc:         create Attributes object for a Context
**
**D Auth:         andreys
**D Date:         10/27/2007
**
*******************************************************************
**      Change History
*******************************************************************
**  Date:            Author:            Description:
**  05/21/2008       andreys            add etl namespace to system attributes
******************************************************************/
SET NOCOUNT ON
DECLARE @Err INT
DECLARE @ProcErr INT
DECLARE @Cnt INT
DECLARE @ProcName sysname
DECLARE @msg nvarchar(max)

DECLARE @BatchID int
DECLARE @StepID int
DECLARE @ConstID int
DECLARE @RunID int
DECLARE @Options int
DECLARE @debug tinyint
DECLARE @Handle uniqueidentifier

declare @Name nvarchar(100)
declare @Value1 nvarchar(max)
declare @Value2 nvarchar(max)
declare @nValue nvarchar(max)
declare @id int

DECLARE @Header xml(ETLController)
DECLARE @Context xml(ETLController)
DECLARE @ProcessInfo xml(ETLController)

SET @ProcName = OBJECT_NAME(@@PROCID)
SET @Err = 0
SET @ProcErr = 0

declare @attr table(id int identity(1,1),AttributeName nvarchar(100),AttributeValue nvarchar(max) null,CompleteFlag tinyint null)
declare @ab table (aid int,bid int,isexec tinyint)

begin try
exec @ProcErr = dbo.[prc_ReadProcessRequest] @pProcessRequest,@Header out,@Context out,@Handle out
exec @ProcErr = dbo.[prc_ReadHeader] @Header,@BatchID out,@StepID out,@ConstID out,@RunID out,@Options out

set @debug = nullif(@Options & 1,0)
IF (@debug IS NOT NULL)
BEGIN
   SET @msg = 'BEGIN Procedure ' + @ProcName
                           + ' with @BatchID=' + CAST(@BatchID AS nvarchar(30))
                           + ISNULL( ', @StepID=' +CAST(@StepID AS nvarchar(30)),'')
                           + ISNULL( ', @ConstID=' +CAST(@ConstID AS nvarchar(30)),'')

   exec @ProcErr = dbo.[prc_CreateProcessInfo] @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@handle
END

if (@ConstID is not null and @StepID is null)
begin
   ;with xmlnamespaces('ETLController.XSD' as etl)
   insert @attr (AttributeName,AttributeValue)
   select cba.ba.value('@Name[1]','nvarchar(100)'),cba.ba.value('(.)[1]','nvarchar(max)')
     from @Context.nodes('/etl:Context[@BatchID=(sql:variable("@BatchID"))]
/etl:Constraints/etl:Constraint[@ConstID=(sql:variable("@ConstID"))]/etl:Attributes') cb(b)
   cross apply cb.b.nodes('./etl:Attribute') cba(ba)

--system batch constraint attributes
   ;with xmlnamespaces('ETLController.XSD' as etl)
   insert @attr (AttributeName,AttributeValue)
   select cba.ba.value('concat("etl:",local-name(.))','nvarchar(100)'),cba.ba.value('string(.)','nvarchar(max)')
     from @Context.nodes('/etl:Context[@BatchID=(sql:variable("@BatchID"))]
/etl:Constraints/etl:Constraint[@ConstID=(sql:variable("@ConstID"))]') cb(b)
   cross apply cb.b.nodes('./@*') cba(ba)
   left join @attr a on a.AttributeName = cba.ba.value('concat("etl:",local-name(.))','nvarchar(100)')
   where a.AttributeName is null

end
else if (@ConstID is not null)
begin
   ;with xmlnamespaces('ETLController.XSD' as etl)
   insert @attr (AttributeName,AttributeValue)
   select cba.ba.value('@Name[1]','nvarchar(100)'),cba.ba.value('(.)[1]','nvarchar(max)')
     from @Context.nodes('/etl:Context[@BatchID=(sql:variable("@BatchID"))]
/etl:Steps/etl:Step[@StepID=(sql:variable("@StepID"))]
/etl:Constraints/etl:Constraint[@ConstID=(sql:variable("@ConstID"))]/etl:Attributes') cb(b)
   cross apply cb.b.nodes('./etl:Attribute') cba(ba)

--system step constraint attributes
   ;with xmlnamespaces('ETLController.XSD' as etl)
   insert @attr (AttributeName,AttributeValue)
   select cba.ba.value('concat("etl:",local-name(.))','nvarchar(100)'),cba.ba.value('string(.)','nvarchar(max)')
     from @Context.nodes('/etl:Context[@BatchID=(sql:variable("@BatchID"))]
/etl:Steps/etl:Step[@StepID=(sql:variable("@StepID"))]
/etl:Constraints/etl:Constraint[@ConstID=(sql:variable("@ConstID"))]') cb(b)
   cross apply cb.b.nodes('./@*') cba(ba)
   left join @attr a on a.AttributeName = cba.ba.value('concat("etl:",local-name(.))','nvarchar(100)')
   where a.AttributeName is null
end

if(@StepID is not null)
begin
   ;with xmlnamespaces('ETLController.XSD' as etl)
   insert @attr (AttributeName,AttributeValue)
   select cba.ba.value('@Name[1]','nvarchar(100)'),cba.ba.value('(.)[1]','nvarchar(max)')
     from @Context.nodes('/etl:Context[@BatchID=(sql:variable("@BatchID"))]
/etl:Steps/etl:Step[@StepID=(sql:variable("@StepID"))]/etl:Attributes') cb(b)
   cross apply cb.b.nodes('./etl:Attribute') cba(ba)
   left join @attr a on a.AttributeName = cba.ba.value('@Name[1]','nvarchar(100)')
   where a.AttributeName is null

--system step attributes
   ;with xmlnamespaces('ETLController.XSD' as etl)
   insert @attr (AttributeName,AttributeValue)
   select cba.ba.value('concat("etl:",local-name(.))','nvarchar(100)'),cba.ba.value('string(.)','nvarchar(max)')
     from @Context.nodes('/etl:Context[@BatchID=(sql:variable("@BatchID"))]
/etl:Steps/etl:Step[@StepID=(sql:variable("@StepID"))]') cb(b)
   cross apply cb.b.nodes('./@*') cba(ba)
   left join @attr a on a.AttributeName = cba.ba.value('concat("etl:",local-name(.))','nvarchar(100)')
   where a.AttributeName is null

end

;with xmlnamespaces('ETLController.XSD' as etl)
insert @attr (AttributeName,AttributeValue)
select cba.ba.value('@Name[1]','nvarchar(100)'),cba.ba.value('(.)[1]','nvarchar(max)')
  from @Context.nodes('/etl:Context[@BatchID=(sql:variable("@BatchID"))]/etl:Attributes') cb(b)
cross apply cb.b.nodes('./etl:Attribute') cba(ba)
left join @attr a on a.AttributeName = cba.ba.value('@Name[1]','nvarchar(100)')
 where a.AttributeName is null

--system batch attributes
;with xmlnamespaces('ETLController.XSD' as etl)
insert @attr (AttributeName,AttributeValue)
select cba.ba.value('concat("etl:",local-name(.))','nvarchar(100)'),cba.ba.value('string(.)','nvarchar(max)')
  from @Context.nodes('/etl:Context[@BatchID=(sql:variable("@BatchID"))]') cb(b)
cross apply cb.b.nodes('./@*') cba(ba)
left join @attr a on a.AttributeName = cba.ba.value('concat("etl:",local-name(.))','nvarchar(100)')
where a.AttributeName is null

declare @inputoptions nvarchar(1000)
set @inputoptions = case when @options & 1 = 1 then 'debug' else '' end
+ case when @options & 2 = 2 then ',forcestart' else '' end

--legacy system attributes
insert @attr (AttributeName,AttributeValue)
select '@BatchID',cast(@BatchID as nvarchar(100))
union select '@StepID',cast(@StepID as nvarchar(100))
union select '@ConstID',cast(@ConstID as nvarchar(100))
union select '@RunID',cast(@RunID as nvarchar(100))
union select '@Options',cast(@inputoptions as nvarchar(100))
union select '@Handle',cast(@handle as nvarchar(100))
union select 'etl:RunID',cast(@RunID as nvarchar(100))


-------------------------------------------------------------------
--relationship table
-------------------------------------------------------------------
insert @ab
select a.id,b.id,0
  from @attr a
  join @attr b on charindex('<' + a.AttributeName + '>',b.AttributeValue) > 0
union all select a.id,b.id,1
  from @attr a
  join @attr b on charindex('<' + a.AttributeName + '*>',b.AttributeValue) > 0

-------------------------------------------------------------------
--replace dynamic parameters if any
-------------------------------------------------------------------
WHILE (1=1)
BEGIN
    SET @id = null
    SELECT top(1) @id = t.id
                 ,@Name = t.AttributeName
                 ,@Value1 = t.AttributeValue
      FROM @attr t
      WHERE t.CompleteFlag IS NULL
        AND NOT EXISTS(SELECT 1 FROM @ab t1
                         JOIN @attr t2 ON t1.aid = t2.id WHERE  t.id = t1.bid AND t2.CompleteFlag IS NULL) --no parents
        AND EXISTS(SELECT 1 FROM @ab t2 WHERE  t.id = t2.aid) --have children
      order by t.id

    IF (@id is null)
       BREAK


    update a set a.AttributeValue = REPLACE(a.AttributeValue,'<' + @Name + '>',isnull(@Value1,''))
      from @attr a
      join @ab ab on a.id = ab.bid and ab.aid = @id and ab.isexec = 0


   --execute value to get the value
   IF (@Value1 is not null
       AND EXISTS(SELECT 1 FROM @ab ab WHERE ab.aid = @id and ab.isexec = 1))
   BEGIN
      SET @nValue = 'select top 1 @value = (' + @Value1 + ')'

	  IF (@debug IS NOT NULL)
	  BEGIN
		  SET @msg = 'Evaluate attribute: ' + @Name + ' = ' + @Value1
		  exec @ProcErr = dbo.[prc_CreateProcessInfo] @ProcessInfo out,@Header,@msg
		  exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@handle
	  END

      SET @Value2 = null
      EXEC sp_executesql @nValue,N'@value varchar(max) output',@value = @value2 out

      update a set a.AttributeValue = REPLACE(a.AttributeValue,'<' + @Name + '*>',isnull(@Value2,''))
        from @attr a
        join @ab ab on a.id = ab.bid and ab.aid = @id and ab.isexec = 1
   END


   update @attr set CompleteFlag = 1 where id = @id
END


;with xmlnamespaces('ETLController.XSD' as etl)
select @pAttributes = 
 (select a.AttributeName as '@Name',a.AttributeValue as '*' from @attr a
     for xml path('etl:Attribute'),root('etl:Attributes'),type)

if @pAttributes is null
   set @pAttributes = '<etl:Attributes xmlns:etl="ETLController.XSD" />'

IF (@debug IS NOT NULL)
BEGIN
   SET @msg = 'END Procedure ' + @ProcName
   exec @ProcErr = dbo.[prc_CreateProcessInfo] @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@handle
END

end try
begin catch
   set @msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   set @pAttributes = null
   raiserror (@msg,11,11)
end catch

RETURN @Err
GO
PRINT N'Creating [dbo].[prc_ConstraintCheck]...';


GO
/*
declare @BatchID int
set @BatchID = 310
declare @pHeader xml
declare @pContext xml
declare @pProcessRequest xml
declare @pProcessReceipt xml
exec dbo.prc_CreateHeader @pHeader out,@BatchID,1,1,138,1
exec dbo.prc_CreateContext @pContext out,@pHeader
exec dbo.prc_CreateProcessRequest @pProcessRequest out,@pHeader,@pContext
--select @pProcessRequest
exec dbo.prc_ConstraintCheck @pProcessRequest,@pProcessReceipt out
--select @pProcessReceipt
*/
CREATE PROCEDURE [dbo].[prc_ConstraintCheck]
    @pRequest xml([ETLController])
   ,@pReceipt  xml([ETLController]) = NULL OUTPUT
As
/******************************************************************
**D File:         prc_ConstraintCheck.SQL
**
**D Desc:         Check Constraints
**
**D Auth:         andreys
**D Date:         10/30/2007
**
** Param: @pRequest  - BatchID info
                  @pReceipt results (StatusID - 2 - SUCCESS, 3 - FAILURE) (OUTPUT only)
*******************************************************************
**      Change History
*******************************************************************
**  Date:            Author:            Description:
**  2010/07/12       andrey@biasintelligence.com           stop constraint processing on ExitEvent
******************************************************************/
SET NOCOUNT ON
DECLARE @Err INT
DECLARE @ExitCode INT
DECLARE @Cnt INT
DECLARE @ProcName sysname
DECLARE @StartDT datetime
DECLARE @BatchID INT
DECLARE @StepID INT
DECLARE @ConstID int
DECLARE @StatusID tinyint
DECLARE @BatchStatusID tinyint
DECLARE @debug tinyint
DECLARE @Options int
DECLARE @msg nvarchar(max)
DECLARE @RaiserrMsg nvarchar(max)
DECLARE @handle uniqueidentifier
DECLARE @RunID int
DECLARE @Scope int

DECLARE @Process nvarchar(max)
DECLARE @WaitPeriod int    -- in seconds
DECLARE @Wait varchar(20)
DECLARE @Disabled int

SET @ProcName = OBJECT_NAME(@@PROCID)
SET @Err = 0
SET @ExitCode = 0

DECLARE @ATT_PING INT

DECLARE @STAT_SUCCESS TINYINT
DECLARE @STAT_FAILURE TINYINT
DECLARE @STAT_ERROR TINYINT
DECLARE @STAT_FAILURE_IMMEDIATE TINYINT

SET @STAT_SUCCESS = 2
SET @STAT_FAILURE = 3
SET @STAT_ERROR = 4
SET @STAT_FAILURE_IMMEDIATE = 6
-------------------------------------------------------------------
--Return Statuses
--2 - Success
--3 - Failure
--4 - Error
--5 - Failure with abort
-------------------------------------------------------------------
DECLARE @ProcessInfo AS xml (ETLController)
DECLARE @Header AS xml (ETLController)
DECLARE @Context AS xml (ETLController)
DECLARE @cHeader AS xml (ETLController)
DECLARE @cRequest AS xml (ETLController)
DECLARE @cReceipt AS xml (ETLController)

BEGIN TRY

exec @ExitCode = dbo.[prc_ReadProcessRequest] @pRequest,@Header out,@Context out,@handle out
exec @ExitCode = dbo.[prc_ReadHeader] @Header,@BatchID out,@StepID out,null,@RunID out,@Options out,@Scope out

set @debug = isnull(@Options & 1,0)
IF (@debug = 1)
BEGIN
   SET @msg = 'BEGIN Procedure ' + @ProcName
                           + ' with @BatchID=' + CAST(@BatchID AS nvarchar(30))
                           + ISNULL( ', @StepID=' +CAST(@StepID AS nvarchar(30)),'')

   exec @ExitCode = dbo.[prc_CreateProcessInfo] @ProcessInfo out,@Header,@msg
   exec @ExitCode = dbo.[prc_Print] @ProcessInfo,@handle
END

-------------------------------------------------------------------
--Check for the constraints existance
-------------------------------------------------------------------
SET @ExitCode = 0
IF (@StepID is null)
  SET @ExitCode = @Context.exist('declare namespace etl="ETLController.XSD";(/etl:Context[@BatchID=(sql:variable("@BatchID"))]/etl:Constraints)')
ELSE
  SET @ExitCode = @Context.exist('declare namespace etl="ETLController.XSD";
                                 (/etl:Context[@BatchID=(sql:variable("@BatchID"))]/etl:Steps/etl:Step[@StepID=(sql:variable("@StepID"))]/etl:Constraints)')

IF (@ExitCode = 0)
BEGIN
  SET @StatusID = @STAT_SUCCESS
END
ELSE
BEGIN

declare @const table
(ConstID int
,Process nvarchar(max)
,WaitPeriod int null
,Ping int null
,[Disabled] tinyint null
,ConstOrder nvarchar(10)
)

if (@StepID is null)
begin
   ;with xmlnamespaces ('ETLController.XSD' as etl)
   insert @const
   SELECT
    c.const.value('./@ConstID','int') as ConstID
   ,'exec @ExitCode = ' + c.const.value('(./etl:Process/etl:Process)[1]','nvarchar(max)') + ' @pRequest=@Request, @pReceipt=@Receipt out' 
    + isnull(',' + c.const.value('(./etl:Process/etl:Param)[1]','nvarchar(max)'),'') as Process
   ,c.const.value('./@WaitPeriod','int') as WaitPeriod
   ,isnull(c.const.value('./@Ping','int'),10) as Ping
   ,isnull(c.const.value('./@Disabled','int'),0) as [Disabled]
   ,c.const.value('./@ConstOrder','int') as ConstOrder
   FROM @Context.nodes('/etl:Context[@BatchID=(sql:variable("@BatchID"))]/etl:Constraints/etl:Constraint') c(const)
end
else
begin
   ;with xmlnamespaces ('ETLController.XSD' as etl)
   insert @const
   SELECT
    c.const.value('./@ConstID','int') as ConstID
   ,'exec @ExitCode = ' + c.const.value('(./etl:Process/etl:Process)[1]','nvarchar(max)') + ' @pRequest=@Request,@pReceipt=@Receipt out' 
    + isnull(',' + c.const.value('(./etl:Process/etl:Param)[1]','nvarchar(max)'),'') as Process
   ,c.const.value('./@WaitPeriod','int') as WaitPeriod
   ,isnull(c.const.value('./@Ping','int'),10) as Ping
   ,isnull(c.const.value('./@Disabled','int'),0) as [Disabled]
   ,c.const.value('./@ConstOrder','int') as ConstOrder
   FROM @Context.nodes('/etl:Context[@BatchID=(sql:variable("@BatchID"))]/etl:Steps/etl:Step[@StepID=(sql:variable("@StepID"))]/etl:Constraints/etl:Constraint') c(const)
end

-------------------------------------------------------------------
--Loop through the Step Constraints
-------------------------------------------------------------------
DECLARE StepConstCursor CURSOR LOCAL FAST_FORWARD
FOR SELECT c.ConstID,c.Process,c.WaitPeriod,c.Ping,c.Disabled
FROM @const c
ORDER BY c.ConstOrder

OPEN StepConstCursor
WHILE (1=1)
BEGIN
   SET @StartDT = getdate()
   SET @ConstID = NULL
   FETCH NEXT FROM StepConstCursor INTO @ConstID,@Process,@WaitPeriod,@ATT_PING,@Disabled
   IF (@@FETCH_STATUS <> 0 OR @ConstID IS NULL)
      BREAK

   IF isnull(@Disabled,0) = 1 
   BEGIN
      IF (@debug = 1)
      BEGIN
         SET @msg = '   Constraint=' +  CAST(@ConstID AS nvarchar(30)) + ' is disabled:  ' + @Process
         exec @ExitCode = dbo.[prc_CreateProcessInfo] @ProcessInfo out,@Header,@msg
         exec @ExitCode = dbo.[prc_Print] @ProcessInfo,@handle
      END
      CONTINUE
   END

   SET @Wait = right('00' + cast(@ATT_PING/3600 as varchar(10)),3)
             + ':' + right('0' + cast((@ATT_PING/60)%60 as varchar(10)),2)
             + ':' + right('0' + cast(@ATT_PING%60 as varchar(10)),2)

   IF (@debug = 1)
   BEGIN
      SET @msg = '   Constraint=' +  CAST(@ConstID AS nvarchar(30))
               + ' wait=' + CAST(@WaitPeriod AS nvarchar(30)) + '(' + isnull(@Wait,'null') + ')'
               + ':  ' + @Process
      exec @ExitCode = dbo.[prc_CreateProcessInfo] @ProcessInfo out,@Header,@msg
      exec @ExitCode = dbo.[prc_Print] @ProcessInfo,@handle
   END

   IF (@Process IS NOT NULL)
   BEGIN
       exec @ExitCode = dbo.[prc_CreateHeader] @cHeader out,@BatchID,@StepID,@ConstID,@RunID,@Options,@Scope
       exec @ExitCode = dbo.[prc_CreateProcessRequest] @cRequest out,@cHeader,@Context,@handle
      --Wait Until WaitPeriod is expired
      WHILE (1=1)
      BEGIN
         SET @StatusID = NULL
         SET @cReceipt = NULL
         EXEC sp_ExecuteSQL @Process
                  ,N'@ExitCode int output,@Request xml(ETLController),@Receipt xml(ETLController) output'
                  ,@ExitCode = @ExitCode output
                  ,@Request = @cRequest
                  ,@Receipt = @cReceipt output

         exec @ExitCode = dbo.[prc_ReadProcessReceipt] @cReceipt,null,@StatusID out,@Err out--,@msg out

         SET @StatusID = ISNULL(@StatusID,@STAT_ERROR)
         IF (@debug = 1)
         BEGIN
            SET @msg = '   Constraint=' +  CAST(@ConstID AS nvarchar(30)) + ' returns StatusID=' + CAST(@StatusID AS nvarchar(30))
            exec @ExitCode = dbo.[prc_CreateProcessInfo] @ProcessInfo out,@Header,@msg
            exec @ExitCode = dbo.[prc_Print] @ProcessInfo,@handle
         END

-------------------------------------------------------------------
--Exit Batch on Exit Event for batch constraints only
-------------------------------------------------------------------
         if (@StepID is null)
         begin
            set @BatchStatusID = cast(dbo.[fn_ETLCounterGet] (@BatchID,0,@RunID,'ExitEvent') as tinyint)
            IF (@BatchStatusID is not null)
            BEGIN
               SET @StatusID = @BatchStatusID
               IF (@debug = 1)
               BEGIN
                  SET @msg = '   Costraint Check Exit on ExitEvent with StatusID=' + CAST(@StatusID as nvarchar(30))
                  exec @ExitCode = dbo.[prc_CreateProcessInfo] @ProcessInfo out,@Header,@msg
                  exec @ExitCode = dbo.[prc_Print] @ProcessInfo,@handle
               END
            END
         end


         IF (@StatusID = @STAT_ERROR)
         BEGIN
            SET @RaiserrMsg = '   ERROR Constraint=' +  CAST(@ConstID AS nvarchar(30)) + ' failed'
            BREAK
         END
         ELSE IF(@StatusID = @STAT_SUCCESS)
         BEGIN
            BREAK
         END
         ELSE
         BEGIN
            IF (@StatusID = @STAT_FAILURE_IMMEDIATE OR DATEDIFF(minute,@StartDT,getdate()) > @WaitPeriod)
            BEGIN
               SET @RaiserrMsg = '   ERROR Constraint=' +  CAST(@ConstID AS nvarchar(30)) + ' was not met'
               SET @StatusID = @STAT_FAILURE
               SET @Err = 50107 -- constraint was not met
               BREAK
            END

            IF (@debug = 1)
            BEGIN
               SET @msg = '   Constraint=' +  CAST(@ConstID AS nvarchar(30)) + ' wait=' + isnull(@Wait,'null')
               exec @ExitCode = dbo.[prc_CreateProcessInfo] @ProcessInfo out,@Header,@msg
               exec @ExitCode = dbo.[prc_Print] @ProcessInfo,@handle
            END
            WAITFOR DELAY @Wait

            --check conversation
            IF (@handle IS NOT NULL)
               IF EXISTS (SELECT * FROM sys.conversation_endpoints WHERE [conversation_handle] = @handle AND  state IN ('DI','DO','ER','CD'))
               BEGIN
                  SET @RaiserrMsg = '   ERROR conversation is not active'
                  SET @StatusID = @STAT_ERROR
                  SET @Err = 50110
                  BREAK
               END

         END
      END --WHILE(@Err = 0)
      IF @StatusID IN (@STAT_FAILURE,@STAT_ERROR,@STAT_FAILURE_IMMEDIATE)
         BREAK
    END
END --WHILE (@Err = 0)

DEALLOCATE StepConstCursor
IF (@RaiserrMsg is not null )
BEGIN
   RAISERROR(@RaiserrMsg,11,11)
END

SET @StatusID = @STAT_SUCCESS
END
END TRY
BEGIN CATCH
SET @Err = ISNULL(NULLIF(@Err,0),ERROR_NUMBER())
SET @RaiserrMsg = ISNULL(@RaiserrMsg,ERROR_MESSAGE())
SET @StatusID = isnull(@StatusID,@STAT_ERROR)
IF (@RaiserrMsg IS NOT NULL)
BEGIN
      exec @ExitCode = dbo.[prc_CreateProcessInfo] @ProcessInfo out,@Header,@RaiserrMsg,@Err
      exec @ExitCode = dbo.[prc_Print] @ProcessInfo,@handle
END
END CATCH

if (@pReceipt is null)
   exec @ExitCode = dbo.[prc_CreateProcessReceipt] @pReceipt out,@Header,@StatusID,@Err,@RaiserrMsg

IF (@debug = 1)
BEGIN
   SET @msg = 'END Procedure ' + @ProcName
   exec @ExitCode = dbo.[prc_CreateProcessInfo] @ProcessInfo out,@Header,@msg,@Err
   exec @ExitCode = dbo.[prc_Print] @ProcessInfo,@handle
END
RETURN @Err
GO
PRINT N'Creating [dbo].[prc_de_CreateParameters]...';


GO
/*
--select * from ETLStepattribute where batchid = -1
--select * from ETLBatch where batchid = -15
declare @uid uniqueidentifier
declare @pHeader xml
declare @pContext xml
declare @pProcessRequest xml
declare @pParameters xml--(ETLClient_DE)
--set @uid = newid()
exec dbo.prc_CreateHeader @pHeader out,-10,12,null,4,10
exec dbo.prc_CreateContext @pContext out,@pHeader
exec dbo.prc_CreateProcessRequest @pProcessRequest out,@pHeader,@pContext,@uid
exec dbo.prc_de_CreateParameters @pParameters out, @pProcessRequest
--select @pHeader
select @pContext
--select @pProcessRequest
select @pParameters
*/
CREATE PROCEDURE [dbo].[prc_de_CreateParameters]
    @pParameters xml([ETLClient_DE]) output
   --@pParameters xml output
   ,@pProcessRequest xml([ETLController])
As
/******************************************************************
**D File:         prc_de_CreateParameters.SQL
**
**D Desc:         return delta extractor parameters object
**
**D Auth:         andreys
**D Date:         12/11/2007
**
*******************************************************************
**      Change History
*******************************************************************
**  Date:            Author:            Description:
2010-05-16           andrey@biasintelligence.com           add multiple destination support
2017-05-02			 andrey								   add OData source support
******************************************************************/
SET NOCOUNT ON
DECLARE @Err INT
DECLARE @ProcErr INT
DECLARE @Cnt INT
DECLARE @ProcName sysname
DECLARE @msg nvarchar(max)
DECLARE @pr nvarchar(max)

DECLARE @Header xml (ETLController)
DECLARE @Context xml (ETLController)
DECLARE @Attributes xml (ETLController)
DECLARE @Handle uniqueidentifier
DECLARE @HandleGrp uniqueidentifier
DECLARE @BatchID int
DECLARE @StepID int
DECLARE @RunID int
DECLARE @Options int
DECLARE @Scope int

SET @ProcName = OBJECT_NAME(@@PROCID)
SET @Err = 0
SET @ProcErr = 0

begin try

exec @ProcErr = dbo.[prc_ReadProcessRequest] @pProcessRequest,@Header out,@Context out,@Handle out,@HandleGrp out
exec @ProcErr = dbo.[prc_ReadHeader] @Header,@BatchID out,@StepID out,null,@RunID out,@Options out,@Scope out
exec @ProcErr = dbo.[prc_ReadContextAttributes] @pProcessRequest,@Attributes out
exec @ProcErr = dbo.prc_DE_MapAttributes @Attributes out
--select @Attributes

declare @attr table (AttributeName nvarchar(100),AttributeValue nvarchar(max))
;with xmlnamespaces('ETLController.XSD' as etl)
insert @attr
select b.b.value('./@Name[1]','nvarchar(100)'),b.b.value('(.)[1]','nvarchar(max)')
  from @Attributes.nodes('/etl:Attributes') a(a)
  cross apply a.a.nodes('./etl:Attribute') b(b)


declare @dst table (DestinationName nvarchar(100),DestinationType nvarchar(100))
insert @dst
select replace(AttributeName,'.Component',''),AttributeValue
  from @attr where AttributeName like 'Destination%.Component'


--;with xmlnamespaces ('DeltaExtractor.XSD' as de,'ETLController.XSD' as etl)
;with xmlnamespaces ('DeltaExtractor.XSD' as de)
select @pParameters = 
--header
 (select @BatchID as 'de:ETLHeader/de:BatchID',@StepID as 'de:ETLHeader/de:StepID',@RunID as 'de:ETLHeader/de:RunID'
,isnull((select top 1 AttributeValue from @attr where AttributeName = 'Control.Server'),@@SERVERNAME) as 'de:ETLHeader/de:Controller/de:Server'
,isnull((select top 1 AttributeValue from @attr where AttributeName = 'Control.Database'),DB_NAME()) as 'de:ETLHeader/de:Controller/de:Database'
,(select top 1 AttributeValue from @attr where AttributeName = 'QueryTimeout') as 'de:ETLHeader/de:Controller/de:QueryTimeout'
,@@SERVERNAME as 'de:ETLHeader/de:Node/de:Server'
,DB_NAME() as 'de:ETLHeader/de:Node/de:Database'
,(select top 1 AttributeValue from @attr where AttributeName = 'QueryTimeout') as 'de:ETLHeader/de:Node/de:QueryTimeout'
,@handle as 'de:ETLHeader/de:Conversation',@Options as 'de:ETLHeader/de:Options'
--
,case (select AttributeValue from @attr where AttributeName = 'Action')
 when 'MoveData'
 then
    (select
--define source
--supported OLEDB, FlatFile, Excel, Sharepoint, AdoNet, ODBC
    case when (isnull((select top 1 AttributeValue from @attr where AttributeName = 'Source.Component' and AttributeValue = 'OLEDB'),'') <> '')
      then
--OLEDB source
    (select
   (select top 1 AttributeValue from @attr where AttributeName = 'Source.Server') as 'de:OleDbSource/de:DBConnection/de:Server'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.Database') as 'de:OleDbSource/de:DBConnection/de:Database'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.ConnectionString') as 'de:OleDbSource/de:DBConnection/de:ConnectionString'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'QueryTimeout') as 'de:OleDbSource/de:DBConnection/de:QueryTimeout'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.QueryType') as 'de:OleDbSource/de:QueryType'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.OLEDB.AccessMode') as 'de:OleDbSource/de:CustomProperties/de:AccessMode'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.Query') as 'de:OleDbSource/de:CustomProperties/de:SqlCommand'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'QueryTimeout') as 'de:OleDbSource/de:CustomProperties/de:CommandTimeout'
  for xml path('de:DataSource'),type)
--FlatFile source  
      when (isnull((select top 1 AttributeValue from @attr where AttributeName = 'Source.Component' and AttributeValue = 'FlatFile'),'') <> '')
      then
    (select
   (select top 1 AttributeValue from @attr where AttributeName = 'Source.FlatFile.CodePage') as 'de:FlatFileSource/de:CustomProperties/de:CodePage'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.FlatFile.ConnectionString') as 'de:FlatFileSource/de:CustomProperties/de:ConnectionString'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.FlatFile.DataRowsToSkip') as 'de:FlatFileSource/de:CustomProperties/de:DataRowsToSkip'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.FlatFile.Format') as 'de:FlatFileSource/de:CustomProperties/de:Format'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.FlatFile.ColumnNamesInFirstDataRow') as 'de:FlatFileSource/de:CustomProperties/de:ColumnNamesInFirstDataRow'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.FlatFile.HeaderRowDelimiter') as 'de:FlatFileSource/de:CustomProperties/de:HeaderRowDelimiter'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.FlatFile.HeaderRowsToSkip') as 'de:FlatFileSource/de:CustomProperties/de:HeaderRowsToSkip'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.FlatFile.TextQualifier') as 'de:FlatFileSource/de:CustomProperties/de:TextQualifier'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.FlatFile.Unicode') as 'de:FlatFileSource/de:CustomProperties/de:Unicode'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.FlatFile.ColumnDelimiter') as 'de:FlatFileSource/de:CustomProperties/de:ColumnDelimiter'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.FlatFile.RecordDelimiter') as 'de:FlatFileSource/de:CustomProperties/de:RecordDelimiter'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.FlatFile.FileNameColumnName') as 'de:FlatFileSource/de:CustomProperties/de:FileNameColumnName'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.FlatFile.RetainNulls') as 'de:FlatFileSource/de:CustomProperties/de:RetainNulls'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.CompressionType') as 'de:FlatFileSource/de:CustomProperties/de:DataCompression'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.StagingAreaTableName') as 'de:FlatFileSource/de:CustomProperties/de:StagingAreaTableName'
  for xml path('de:DataSource'),type)
--Sharepoint source  
      when (isnull((select top 1 AttributeValue from @attr where AttributeName = 'Source.Component' and AttributeValue = 'SPList'),'') <> '')
      then
    (select
   (select top 1 AttributeValue from @attr where AttributeName = 'Source.ConnectionString') as 'de:SharePointSource/de:ConnectionString'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.SPList.BatchSize') as 'de:SharePointSource/de:CustomProperties/de:BatchSize'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.SPList.CamlQuery') as 'de:SharePointSource/de:CustomProperties/de:CamlQuery'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.SPList.IncludeFolders') as 'de:SharePointSource/de:CustomProperties/de:IncludeFolders'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.SPList.IsRecursive') as 'de:SharePointSource/de:CustomProperties/de:IsRecursive'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.SPList.SharePointCulture') as 'de:SharePointSource/de:CustomProperties/de:SharePointCulture'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.SPList.SiteListName') as 'de:SharePointSource/de:CustomProperties/de:SiteListName'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.SPList.SiteListViewName') as 'de:SharePointSource/de:CustomProperties/de:SiteListViewName'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.SPList.SiteUrl') as 'de:SharePointSource/de:CustomProperties/de:SiteUrl'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.SPList.DecodeLookupColumns') as 'de:SharePointSource/de:CustomProperties/de:DecodeLookupColumns'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.SPList.IncludeHiddenColumns') as 'de:SharePointSource/de:CustomProperties/de:IncludeHiddenColumns'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.SPList.UseConnectionManager') as 'de:SharePointSource/de:CustomProperties/de:UseConnectionManager'
  for xml path('de:DataSource'),type)
--Excel source
      when (isnull((select top 1 AttributeValue from @attr where AttributeName = 'Source.Component' and AttributeValue = 'Excel'),'') <> '')
      then
    (select
   (select top 1 AttributeValue from @attr where AttributeName = 'Source.Excel.FilePath') as 'de:ExcelSource/de:FilePath'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.Excel.Header') as 'de:ExcelSource/de:Header'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.Excel.ExcelVersion') as 'de:ExcelSource/de:ExcelVersion'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.Excel.AccessMode') as 'de:ExcelSource/de:CustomProperties/de:AccessMode'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.Excel.OpenRowset') as 'de:ExcelSource/de:CustomProperties/de:OpenRowset'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.Excel.SqlCommand') as 'de:ExcelSource/de:CustomProperties/de:SqlCommand'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'QueryTimeout') as 'de:ExcelSource/de:CustomProperties/de:CommandTimeout'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.CompressionType') as 'de:ExcelSource/de:DataCompression'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.StagingAreaTableName') as 'de:ExcelSource/de:StagingAreaTableName'
  for xml path('de:DataSource'),type)
--AdoNet source
    when (isnull((select top 1 AttributeValue from @attr where AttributeName = 'Source.Component' and AttributeValue = 'ADONET'),'') <> '')
      then
    (select
   (select top 1 AttributeValue from @attr where AttributeName = 'Source.Server') as 'de:AdoNetSource/de:DBConnection/de:Server'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.Database') as 'de:AdoNetSource/de:DBConnection/de:Database'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.ConnectionString') as 'de:AdoNetSource/de:DBConnection/de:ConnectionString'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.ConnectionQualifier') as 'de:AdoNetSource/de:DBConnection/de:Qualifier'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'QueryTimeout') as 'de:AdoNetSource/de:DBConnection/de:QueryTimeout'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.ADONET.AccessMode') as 'de:AdoNetSource/de:CustomProperties/de:AccessMode'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.Query') as 'de:AdoNetSource/de:CustomProperties/de:SqlCommand'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'QueryTimeout') as 'de:AdoNetSource/de:CustomProperties/de:CommandTimeout'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.ADONET.AllowImplicitStringConversion') as 'de:AdoNetSource/de:CustomProperties/de:AllowImplicitStringConversion'
  for xml path('de:DataSource'),type)
--Odbc source
    when (isnull((select top 1 AttributeValue from @attr where AttributeName = 'Source.Component' and AttributeValue = 'ODBC'),'') <> '')
      then
    (select
   (select top 1 AttributeValue from @attr where AttributeName = 'Source.Server') as 'de:OdbcSource/de:DBConnection/de:Server'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.Database') as 'de:OdbcSource/de:DBConnection/de:Database'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.ConnectionString') as 'de:OdbcSource/de:DBConnection/de:ConnectionString'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.ConnectionQualifier') as 'de:OdbcSource/de:DBConnection/de:Qualifier'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'QueryTimeout') as 'de:OdbcSource/de:DBConnection/de:QueryTimeout'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.ODBC.AccessMode') as 'de:OdbcSource/de:CustomProperties/de:AccessMode'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.Query') as 'de:OdbcSource/de:CustomProperties/de:SqlCommand'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'QueryTimeout') as 'de:OdbcSource/de:CustomProperties/de:StatementTimeout'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.ODBC.BatchSize') as 'de:OdbcSource/de:CustomProperties/de:BatchSize'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.ODBC.LobChunkSize') as 'de:OdbcSource/de:CustomProperties/de:LobChunkSize'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.ODBC.ExposeCharColumnsAsUnicode') as 'de:OdbcSource/de:CustomProperties/de:ExposeCharColumnsAsUnicode'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.ODBC.FetchMethod') as 'de:OdbcSource/de:CustomProperties/de:FetchMethod'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.ODBC.DefaultCodePage') as 'de:OdbcSource/de:CustomProperties/de:DefaultCodePage'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.ODBC.BindNumericAs') as 'de:OdbcSource/de:CustomProperties/de:BindNumericAs'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.ODBC.BindCharColumnsAs') as 'de:OdbcSource/de:CustomProperties/de:BindCharColumnsAs'
  for xml path('de:DataSource'),type)
--OData source  
      when (isnull((select top 1 AttributeValue from @attr where AttributeName = 'Source.Component' and AttributeValue = 'ODATA'),'') <> '')
      then
    (select
   (select top 1 AttributeValue from @attr where AttributeName = 'Source.ConnectionString') as 'de:ODataSource/de:ConnectionString'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.OData.DefaultStringLength') as 'de:ODataSource/de:CustomProperties/de:DefaultStringLength'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.OData.CollectionName') as 'de:ODataSource/de:CustomProperties/de:CollectionName'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.OData.Query') as 'de:ODataSource/de:CustomProperties/de:Query'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.OData.ResourcePath') as 'de:ODataSource/de:CustomProperties/de:ResourcePath'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Source.OData.UseResourcePath') as 'de:ODataSource/de:CustomProperties/de:UseResourcePath'
  for xml path('de:DataSource'),type)
      end

--define destinations
  ,(select
-- OLEDB destination
    (select
   (select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.Server') as 'de:DBConnection/de:Server'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.Database') as 'de:DBConnection/de:Database'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.ConnectionString') as 'de:DBConnection/de:ConnectionString'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'QueryTimeout') as 'de:DBConnection/de:QueryTimeout'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.Staging') as 'de:StagingBlock/@Staging'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.StagingTableName') as 'de:StagingBlock/de:StagingTableName'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.StagingTablePrepare') as 'de:StagingBlock/de:StagingTablePrepare'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.StagingTableUpload') as 'de:StagingBlock/de:StagingTableUpload'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.UserOptions') as 'de:StagingBlock/de:UserOptions'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.MinPartitionID') as 'de:PartitionRange/@Min'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.MaxPartitionID') as 'de:PartitionRange/@Max'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.OLEDB.AccessMode') as 'de:CustomProperties/de:AccessMode'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.TableName') as 'de:CustomProperties/de:OpenRowset'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.OLEDB.FastLoadOptions') as 'de:CustomProperties/de:FastLoadOptions'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.OLEDB.FastLoadKeepIdentity') as 'de:CustomProperties/de:FastLoadKeepIdentity'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.OLEDB.FastLoadKeepNulls') as 'de:CustomProperties/de:FastLoadKeepNulls'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.OLEDB.FastLoadMaxInsertCommitSize') as 'de:CustomProperties/de:FastLoadMaxInsertCommitSize'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'QueryTimeout') as 'de:CustomProperties/de:CommandTimeout'
  from @dst dst where dst.DestinationType = 'OLEDB'
  for xml path('de:OleDbDestination'),type)
--FlatFile destination 
   ,(select 
   (select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.MinPartitionID') as 'de:PartitionRange/@Min'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.MaxPartitionID') as 'de:PartitionRange/@Max'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.FlatFile.CodePage') as 'de:CustomProperties/de:CodePage'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.FlatFile.ConnectionString') as 'de:CustomProperties/de:ConnectionString'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.FlatFile.DataRowsToSkip') as 'de:CustomProperties/de:DataRowsToSkip'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.FlatFile.Format') as 'de:CustomProperties/de:Format'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.FlatFile.ColumnNamesInFirstDataRow') as 'de:CustomProperties/de:ColumnNamesInFirstDataRow'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.FlatFile.HeaderRowDelimiter') as 'de:CustomProperties/de:HeaderRowDelimiter'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.FlatFile.TextQualifier') as 'de:CustomProperties/de:TextQualifier'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.FlatFile.Unicode') as 'de:CustomProperties/de:Unicode'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.FlatFile.ColumnDelimiter') as 'de:CustomProperties/de:ColumnDelimiter'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.FlatFile.RecordDelimiter') as 'de:CustomProperties/de:RecordDelimiter'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.FlatFile.Header') as 'de:CustomProperties/de:Header'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.FlatFile.Override') as 'de:CustomProperties/de:Override'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.CompressionType') as 'de:CustomProperties/de:DataCompression'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.StagingAreaTableName') as 'de:CustomProperties/de:StagingAreaTableName'
  from @dst dst where dst.DestinationType = 'FlatFile'
  for xml path('de:FlatFileDestination'),type)
--Sharepoint destination 
   ,(select 
   (select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.ConnectionString') as 'de:ConnectionString'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.SPList.BatchSize') as 'de:CustomProperties/de:BatchSize'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.SPList.CamlQuery') as 'de:CustomProperties/de:CamlQuery'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.SPList.IncludeFolders') as 'de:CustomProperties/de:IncludeFolders'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.SPList.IsRecursive') as 'de:CustomProperties/de:IsRecursive'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.SPList.SharePointCulture') as 'de:CustomProperties/de:SharePointCulture'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.SPList.SiteListName') as 'de:CustomProperties/de:SiteListName'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.SPList.SiteListViewName') as 'de:CustomProperties/de:SiteListViewName'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.SPList.SiteUrl') as 'de:CustomProperties/de:SiteUrl'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.SPList.UseConnectionManager') as 'de:CustomProperties/de:UseConnectionManager'
  from @dst dst where dst.DestinationType = 'SPList'
  for xml path('de:SharePointDestination'),type)
-- Excel destination
   ,(select
   (select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.Excel.FilePath') as 'de:FilePath'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.Excel.Header') as 'de:Header'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.Excel.ExcelVersion') as 'de:ExcelVersion'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.MinPartitionID') as 'de:PartitionRange/@Min'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.MaxPartitionID') as 'de:PartitionRange/@Max'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.Excel.AccessMode') as 'de:CustomProperties/de:AccessMode'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.Excel.OpenRowset') as 'de:CustomProperties/de:OpenRowset'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'QueryTimeout') as 'de:CustomProperties/de:CommandTimeout'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.CompressionType') as 'de:CustomProperties/de:DataCompression'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.StagingAreaTableName') as 'de:CustomProperties/de:StagingAreaTableName'
  from @dst dst where dst.DestinationType = 'Excel'
  for xml path('de:ExcelDestination'),type)
-- ADONET destination
   ,(select
   (select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.Server') as 'de:DBConnection/de:Server'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.Database') as 'de:DBConnection/de:Database'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.ConnectionString') as 'de:DBConnection/de:ConnectionString'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.ConnectionQualifier') as 'de:DBConnection/de:Qualifier'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'QueryTimeout') as 'de:DBConnection/de:QueryTimeout'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.Staging') as 'de:StagingBlock/@Staging'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.StagingTableName') as 'de:StagingBlock/de:StagingTableName'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.StagingTablePrepare') as 'de:StagingBlock/de:StagingTablePrepare'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.StagingTableUpload') as 'de:StagingBlock/de:StagingTableUpload'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.UserOptions') as 'de:StagingBlock/de:UserOptions'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.MinPartitionID') as 'de:PartitionRange/@Min'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.MaxPartitionID') as 'de:PartitionRange/@Max'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.ADONET.AccessMode') as 'de:CustomProperties/de:AccessMode'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.TableName') as 'de:CustomProperties/de:TableOrViewName'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.ADONET.BatchSize') as 'de:CustomProperties/de:BatchSize'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.ADONET.UseBulkInsertWhenPossible') as 'de:CustomProperties/de:UseBulkInsertWhenPossible'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'QueryTimeout') as 'de:CustomProperties/de:CommandTimeout'
  from @dst dst where dst.DestinationType = 'ADONET'
  for xml path('de:AdoNetDestination'),type)
-- ODBC destination
   ,(select
   (select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.Server') as 'de:DBConnection/de:Server'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.Database') as 'de:DBConnection/de:Database'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.ConnectionString') as 'de:DBConnection/de:ConnectionString'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.ConnectionQualifier') as 'de:DBConnection/de:Qualifier'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'QueryTimeout') as 'de:DBConnection/de:QueryTimeout'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.Staging') as 'de:StagingBlock/@Staging'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.StagingTableName') as 'de:StagingBlock/de:StagingTableName'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.StagingTablePrepare') as 'de:StagingBlock/de:StagingTablePrepare'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.StagingTableUpload') as 'de:StagingBlock/de:StagingTableUpload'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.UserOptions') as 'de:StagingBlock/de:UserOptions'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.MinPartitionID') as 'de:PartitionRange/@Min'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.MaxPartitionID') as 'de:PartitionRange/@Max'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.ODBC.InsertMethod') as 'de:CustomProperties/de:InsertMethod'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.ODBC.BindCharColumnsAs') as 'de:CustomProperties/de:BindCharColumnsAs'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.ODBC.BindNumericAs') as 'de:CustomProperties/de:BindNumericAs'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.TableName') as 'de:CustomProperties/de:TableName'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.ODBC.BatchSize') as 'de:CustomProperties/de:BatchSize'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.ODBC.TransactionSize') as 'de:CustomProperties/de:TransactionSize'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.ODBC.LobChunkSize') as 'de:CustomProperties/de:LobChunkSize'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'QueryTimeout') as 'de:CustomProperties/de:StatementTimeout'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.ODBC.DefaultCodePage') as 'de:CustomProperties/de:DefaultCodePage'
  from @dst dst where dst.DestinationType = 'ODBC'
  for xml path('de:OdbcDestination'),type)
-- SqlBulk destination
   ,(select
   (select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.Server') as 'de:DBConnection/de:Server'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.Database') as 'de:DBConnection/de:Database'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.ConnectionString') as 'de:DBConnection/de:ConnectionString'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'QueryTimeout') as 'de:DBConnection/de:QueryTimeout'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.Staging') as 'de:StagingBlock/@Staging'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.StagingTableName') as 'de:StagingBlock/de:StagingTableName'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.StagingTablePrepare') as 'de:StagingBlock/de:StagingTablePrepare'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.StagingTableUpload') as 'de:StagingBlock/de:StagingTableUpload'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.UserOptions') as 'de:StagingBlock/de:UserOptions'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.MinPartitionID') as 'de:PartitionRange/@Min'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.MaxPartitionID') as 'de:PartitionRange/@Max'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.SQLBULK.DefaultCodePage') as 'de:CustomProperties/de:DefaultCodePage'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.SQLBULK.AlwaysUseDefaultCodePage') as 'de:CustomProperties/de:AlwaysUseDefaultCodePage'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.TableName') as 'de:CustomProperties/de:BulkInsertTableName'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.SQLBULK.BulkInsertCheckConstraints') as 'de:CustomProperties/de:BulkInsertCheckConstraints'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.SQLBULK.BulkInsertFirstRow') as 'de:CustomProperties/de:BulkInsertFirstRow'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.SQLBULK.BulkInsertFireTriggers') as 'de:CustomProperties/de:BulkInsertFireTriggers'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.SQLBULK.BulkInsertKeepIdentity') as 'de:CustomProperties/de:BulkInsertKeepIdentity'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.SQLBULK.BulkInsertKeepNulls') as 'de:CustomProperties/de:BulkInsertKeepNulls'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.SQLBULK.BulkInsertLastRow') as 'de:CustomProperties/de:BulkInsertLastRow'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.SQLBULK.BulkInsertMaxErrors') as 'de:CustomProperties/de:BulkInsertMaxErrors'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.SQLBULK.BulkInsertOrder') as 'de:CustomProperties/de:BulkInsertOrder'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.SQLBULK.BulkInsertTablock') as 'de:CustomProperties/de:BulkInsertTablock'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'QueryTimeout') as 'de:CustomProperties/de:Timeout'
  ,(select top 1 AttributeValue from @attr where AttributeName = dst.DestinationName + '.SQLBULK.MaxInsertCommitSize') as 'de:CustomProperties/de:MaxInsertCommitSize'
  from @dst dst where dst.DestinationType = 'SQLBULK'
  for xml path('de:SqlBulkDestination'),type)
  for xml path('de:DataDestination'),type)
  
  ,(select top 1 AttributeValue from @attr where AttributeName = 'StagingAreaRoot') as 'de:StagingAreaRoot'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Destination.PartitionFunction') as 'de:Partition/@Function'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Destination.PartitionFunctionInput') as 'de:Partition/de:Input'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'Destination.PartitionFunctionOutput') as 'de:Partition/de:Output'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'SavePackage') as 'de:SavePackage/@Save'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'LoadPackage') as 'de:SavePackage/@Load'
  ,(select top 1 AttributeValue from @attr where AttributeName = 'PackageFileName') as 'de:SavePackage'
  for xml path('de:MoveData'),type)
 when 'RunPackage'
 then (select
  (select top 1 AttributeValue from @attr where AttributeName = 'Package.File') as 'de:File'
  for xml path('de:RunPackage'),type)
end
 for xml path(''),type, root('de:Parameters'))


end try
begin catch
   set @msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   set @pParameters = null
   raiserror (@msg,11,11)
end catch

RETURN @Err
GO
PRINT N'Creating [dbo].[prc_PersistContext]...';


GO
/*

declare @Header xml
declare @pContext xml
declare @pProcessRequest xml
declare @pAttributes xml
exec dbo.prc_CreateHeader @Header out,-20,null,null,4,15
exec dbo.prc_CreateContext @pContext out,@Header
--exec dbo.prc_CreateProcessRequest @pProcessRequest out,@Header,@pContext
--select @pProcessRequest
--exec dbo.prc_ReadContextAttributes @pProcessRequest,@pAttributes out
--select @pAttributes
select @pContext
exec prc_PersistContext @pContext,'debug,replace'
exec dbo.prc_CreateContext @pContext out,@Header
select @pContext
rollback tran
*/
CREATE PROCEDURE dbo.prc_PersistContext
    @pContext xml([ETLController])
   ,@pHandle uniqueidentifier = null 
   ,@pOptions nvarchar(100) = null
As
/******************************************************************
**D File:         prc_PersistContext.SQL
**
**D Desc:         create persist context into ETLBatch tables
**
** @Options       debug,replace
** @pHandle       conversation handle to communicate messages back to main thread

**D Auth:         andreys
**D Date:         10/27/2007
**
*******************************************************************
**      Change History
*******************************************************************
**  Date:            Author:            Description:
01/12/2008           Praveen			Added Retry and Delay 83349
******************************************************************/
SET NOCOUNT ON
DECLARE @Err INT
DECLARE @ProcErr INT
DECLARE @Cnt INT
DECLARE @ProcName sysname
DECLARE @msg nvarchar(max)
DECLARE @trancount int

DECLARE @BatchID int
DECLARE @StepID int
DECLARE @ConstID int
DECLARE @RunID int
DECLARE @Options int
DECLARE @debug tinyint
DECLARE @replace tinyint
DECLARE @Handle uniqueidentifier
DECLARE @BatchName nvarchar(30)

declare @Name nvarchar(100)
declare @Value1 nvarchar(max)
declare @Value2 nvarchar(max)
declare @nValue nvarchar(max)

DECLARE @Header xml(ETLController)
DECLARE @Context xml(ETLController)
DECLARE @ProcessInfo xml(ETLController)

SET @ProcName = OBJECT_NAME(@@PROCID)
SET @Err = 0
SET @ProcErr = 0
SET @trancount = @@trancount


begin try
set @debug = case when charindex('debug',@pOptions) > 0 then 1 else 0 end
set @replace = case when charindex('replace',@pOptions) > 0 then 1 else 0 end

;with xmlnamespaces('ETLController.XSD' as etl)
select @BatchID = @pContext.value('(/etl:Context/@BatchID)[1]','int')
      ,@BatchName = @pContext.value('(/etl:Context/@BatchName)[1]','nvarchar(30)')

exec [prc_CreateHeader] @Header out,@BatchID,null,null,0,@debug,15
if (@debug = 1)
begin
   SET @msg =  'BEGIN Procedure ' + @ProcName + ' for BatchName=' + isnull(@BatchName,'NULL')
            + ' (' + isnull(cast(@BatchID as nvarchar(10)),'NULL') + ')'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end


if exists (select 1 from dbo.[ETLBatch] where BatchName = @BatchName and BatchID <> @BatchID)
BEGIN
   SET @Err = 50101
   SET @msg = '   ERROR pContext: BatchName=' + @BatchName + ' already exists with different BatchID'
   RAISERROR(@msg,11,11) 
END

--b shred
;with xmlnamespaces('ETLController.XSD' as etl)
select
       cb.b.value('(./@BatchID)[1]','int') as BatchID
      ,cb.b.value('(./@BatchName)[1]','nvarchar(30)') as BatchName
      ,cb.b.value('(./@BatchDesc)[1]','nvarchar(500)') as BatchDesc
      ,cb.b.value('(./etl:OnSuccess/@ProcessID)[1]','int') as OnSuccessID
      ,cb.b.value('(./etl:OnFailure/@ProcessID)[1]','int') as OnFailureID
      ,cb.b.value('(./@IgnoreErr)[1]','tinyint') as IgnoreErr
      ,cb.b.value('(./@Restart)[1]','tinyint') as RestartOnErr
      ,cb.b.value('(./@MaxThread)[1]','tinyint') as MaxThread
      ,cb.b.value('(./@Timeout)[1]','int') as [Timeout]
      ,cb.b.value('(./@Lifetime)[1]','int') as Lifetime
      ,cb.b.value('(./@Ping)[1]','tinyint') as Ping
      ,cb.b.value('(./@HistRet)[1]','int') as HistRet
      ,cb.b.value('(./@Retry)[1]','int') as Retry
      ,cb.b.value('(./@Delay)[1]','int') as [Delay]
  into #b
  from @pContext.nodes('/etl:Context[@BatchID=(sql:variable("@BatchID"))]') cb(b)

set @cnt = @@ROWCOUNT
if (@debug = 1)
begin
   SET @msg =  'Shredding B:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

--ba shred
;with xmlnamespaces('ETLController.XSD' as etl)
select
       cb.b.value('(./@BatchID)[1]','int') as BatchID
      ,cba.ba.value('(./@Name)[1]','nvarchar(100)') as AttributeName
      ,cba.ba.value('(.)[1]','nvarchar(4000)') as AttributeValue
  into #ba
  from @pContext.nodes('/etl:Context[@BatchID=(sql:variable("@BatchID"))]') cb(b)
  cross apply cb.b.nodes('./etl:Attributes/etl:Attribute') cba(ba)
  union select BatchID,'MAXTHREAD',cast(MaxThread as nvarchar(1000)) from #b where MaxThread is not null
  union select BatchID,'TIMEOUT',cast([Timeout] as nvarchar(1000)) from #b where [Timeout] is not null
  union select BatchID,'LIFETIME',cast(Lifetime as nvarchar(1000)) from #b where Lifetime is not null
  union select BatchID,'PING',cast(Ping as nvarchar(1000)) from #b where Ping is not null
  union select BatchID,'HISTRET',cast(HistRet as nvarchar(1000)) from #b where HistRet is not null
  union select BatchID,'RETRY',cast(Retry as nvarchar(1000)) from #b where Retry is not null
  union select BatchID,'DELAY',cast([Delay] as nvarchar(1000)) from #b where [Delay] is not null

set @cnt = @@ROWCOUNT
if (@debug = 1)
begin
   SET @msg =  'Shredding BA:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end


;with xmlnamespaces('ETLController.XSD' as etl)
select
       cb.b.value('(./@BatchID)[1]','int') as BatchID
      ,cbc.bc.value('(./@ConstID)[1]','int') as ConstID
      ,cbc.bc.value('(./etl:Process/@ProcessID)[1]','int') as ProcessID
      ,cbc.bc.value('(./@ConstOrder)[1]','nvarchar(10)') as ConstOrder
      ,cbc.bc.value('(./@WaitPeriod)[1]','int') as WaitPeriod
      ,cbc.bc.value('(./@Disabled)[1]','tinyint') as [Disabled]
      ,cbc.bc.value('(./@Ping)[1]','int') as Ping
  into #bc
  from @pContext.nodes('/etl:Context[@BatchID=(sql:variable("@BatchID"))]') cb(b)
  cross apply cb.b.nodes('./etl:Constraints/etl:Constraint') cbc(bc)
set @cnt = @@ROWCOUNT
if (@debug = 1)
begin
   SET @msg =  'Shredding BC:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

;with xmlnamespaces('ETLController.XSD' as etl)
select
       cb.b.value('(./@BatchID)[1]','int') as BatchID
      ,cbc.bc.value('(./@ConstID)[1]','int') as ConstID
      ,cbca.bca.value('(./@Name)[1]','nvarchar(100)') as AttributeName
      ,cbca.bca.value('(.)[1]','nvarchar(4000)') as AttributeValue
  into #bca
  from @pContext.nodes('/etl:Context[@BatchID=(sql:variable("@BatchID"))]') cb(b)
  cross apply cb.b.nodes('./etl:Constraints/etl:Constraint') cbc(bc)
  cross apply cbc.bc.nodes('./etl:Attributes/etl:Attribute') cbca(bca)
  union select BatchID,ConstID,'DISABLED',cast([Disabled] as nvarchar(1000)) from #bc where [Disabled] is not null
  union select BatchID,ConstID,'PING',cast(Ping as nvarchar(1000)) from #bc where Ping is not null

set @cnt = @@ROWCOUNT
if (@debug = 1)
begin
   SET @msg =  'Shredding BCA:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

--s shred
;with xmlnamespaces('ETLController.XSD' as etl)
select
       cb.b.value('(./@BatchID)[1]','int') as BatchID
      ,cs.s.value('(./@StepID)[1]','int') as StepID
      ,cs.s.value('(./@StepName)[1]','nvarchar(100)') as StepName
      ,cs.s.value('(./@StepDesc)[1]','nvarchar(500)') as StepDesc
      ,cs.s.value('(./etl:Process/@ProcessID)[1]','int') as StepProcID
      ,cs.s.value('(./etl:OnSuccess/@ProcessID)[1]','int') as OnSuccessID
      ,cs.s.value('(./etl:OnFailure/@ProcessID)[1]','int') as OnFailureID
      ,cs.s.value('(./@IgnoreErr)[1]','tinyint') as IgnoreErr
      ,cs.s.value('(./@Restart)[1]','tinyint') as RestartOnErr
      ,cs.s.value('(./@StepOrder)[1]','nvarchar(10)') as StepOrder
      ,cs.s.value('(./@Disabled)[1]','tinyint') as [Disabled]
      ,cs.s.value('(./@SeqGroup)[1]','int') as SeqGroup
      ,cs.s.value('(./@PriGroup)[1]','int') as PriGroup
      ,cs.s.value('(./@Retry)[1]','int') as Retry
      ,cs.s.value('(./@Delay)[1]','int') as [Delay]
  into #s
  from @pContext.nodes('/etl:Context[@BatchID=(sql:variable("@BatchID"))]') cb(b)
  cross apply cb.b.nodes('./etl:Steps/etl:Step') cs(s)

set @cnt = @@ROWCOUNT
if (@debug = 1)
begin
   SET @msg =  'Shredding S:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

--sa shred
;with xmlnamespaces('ETLController.XSD' as etl)
select
       cb.b.value('(./@BatchID)[1]','int') as BatchID
      ,cs.s.value('(./@StepID)[1]','int') as StepID
      ,csa.sa.value('(./@Name)[1]','nvarchar(100)') as AttributeName
      ,csa.sa.value('(.)[1]','nvarchar(4000)') as AttributeValue
  into #sa
  from @pContext.nodes('/etl:Context[@BatchID=(sql:variable("@BatchID"))]') cb(b)
  cross apply cb.b.nodes('./etl:Steps/etl:Step') cs(s)
  cross apply cs.s.nodes('./etl:Attributes/etl:Attribute') csa(sa)
  union select BatchID,StepID,'DISABLED',cast([Disabled] as nvarchar(1000)) from #s where [Disabled] is not null
  union select BatchID,StepID,'SEQGROUP',cast(SeqGroup as nvarchar(1000)) from #s where SeqGroup is not null
  union select BatchID,StepID,'PRIGROUP',cast(PriGroup as nvarchar(1000)) from #s where PriGroup is not null
  union select BatchID,StepID,'RETRY',cast(Retry as nvarchar(1000)) from #s where Retry is not null
  union select BatchID,StepID,'DELAY',cast([Delay] as nvarchar(1000)) from #s where [Delay] is not null
  union select BatchID,StepID,'RESTART',cast(RestartOnErr as nvarchar(1000)) from #s where RestartOnErr is not null

set @cnt = @@ROWCOUNT
if (@debug = 1)
begin
   SET @msg =  'Shredding SA:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

--sc shred
;with xmlnamespaces('ETLController.XSD' as etl)
select
       cb.b.value('(./@BatchID)[1]','int') as BatchID
      ,cs.s.value('(./@StepID)[1]','int') as StepID
      ,csc.sc.value('(./@ConstID)[1]','int') as ConstID
      ,csc.sc.value('(./etl:Process/@ProcessID)[1]','int') as ProcessID
      ,csc.sc.value('(./@ConstOrder)[1]','nvarchar(10)') as ConstOrder
      ,csc.sc.value('(./@WaitPeriod)[1]','int') as WaitPeriod
      ,csc.sc.value('(./@Disabled)[1]','tinyint') as [Disabled]
      ,csc.sc.value('(./@Ping)[1]','int') as Ping
  into #sc
  from @pContext.nodes('/etl:Context[@BatchID=(sql:variable("@BatchID"))]') cb(b)
  cross apply cb.b.nodes('./etl:Steps/etl:Step') cs(s)
  cross apply cs.s.nodes('./etl:Constraints/etl:Constraint') csc(sc)

set @cnt = @@ROWCOUNT
if (@debug = 1)
begin
   SET @msg =  'Shredding SC:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

--sca shred
;with xmlnamespaces('ETLController.XSD' as etl)
select
       cb.b.value('(./@BatchID)[1]','int') as BatchID
      ,cs.s.value('(./@StepID)[1]','int') as StepID
      ,csc.sc.value('(./@ConstID)[1]','int') as ConstID
      ,csca.sca.value('(./@Name)[1]','nvarchar(100)') as AttributeName
      ,csca.sca.value('(.)[1]','nvarchar(4000)') as AttributeValue
  into #sca
  from @pContext.nodes('/etl:Context[@BatchID=(sql:variable("@BatchID"))]') cb(b)
  cross apply cb.b.nodes('./etl:Steps/etl:Step') cs(s)
  cross apply cs.s.nodes('./etl:Constraints/etl:Constraint') csc(sc)
  cross apply csc.sc.nodes('./etl:Attributes/etl:Attribute') csca(sca)
  union select BatchID,ConstID,ConstID,'DISABLED',cast([Disabled] as nvarchar(1000)) from #sc where [Disabled] is not null
  union select BatchID,ConstID,ConstID,'PING',cast(Ping as nvarchar(1000)) from #sc where Ping is not null

set @cnt = @@ROWCOUNT
if (@debug = 1)
begin
   SET @msg =  'Shredding SCA:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

BEGIN TRAN

if (@Replace = 1)
begin

   exec @ProcErr = dbo.[prc_RemoveContext] @BatchName,@pHandle,@pOptions

   if (@debug = 1)
   begin
      SET @msg =  'Deleted all old records (Replace=1)...'
      exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
      exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
   end

end

--b persist
update d
   set
       d.BatchName = t.BatchName
      ,d.BatchDesc = t.BatchDesc
      ,d.OnSuccessID = t.OnSuccessID
      ,d.OnFailureID = t.OnFailureID
      ,d.IgnoreErr = t.IgnoreErr
      ,d.RestartOnErr = t.RestartOnErr
  from dbo.[ETLBatch] d
  join #b t on d.BatchID = t.BatchID

set @cnt = @@ROWCOUNT
if (@debug = 1)
begin
   SET @msg =  'Updated B:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

--set identity_insert dbo.[ETLBatch] on
insert dbo.[ETLBatch]
    (BatchID,BatchName,BatchDesc,OnSuccessID,OnFailureID,IgnoreErr,RestartOnErr)
select
       t.BatchID
      ,t.BatchName
      ,t.BatchDesc
      ,t.OnSuccessID
      ,t.OnFailureID
      ,t.IgnoreErr
      ,t.RestartOnErr
  from #b t
  left join dbo.[ETLBatch] d on t.BatchID = d.BatchID
 where d.BatchID is null
set @cnt = @@ROWCOUNT
--set identity_insert dbo.[ETLBatch] off

if (@debug = 1)
begin
   SET @msg =  'Inserted B:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

--ba persist
update d
   set
       d.AttributeValue = t.AttributeValue
  from dbo.[ETLBatchAttribute] d
  join #ba t on d.BatchID = t.BatchID and d.AttributeName = t.AttributeName

set @cnt = @@ROWCOUNT
if (@debug = 1)
begin
   SET @msg =  'Updated BA:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

insert dbo.[ETLBatchAttribute]
    (BatchID,AttributeName,AttributeValue)
select
       t.BatchID
      ,t.AttributeName
      ,t.AttributeValue
  from #ba t
  left join dbo.[ETLBatchAttribute] d on t.BatchID = d.BatchID and t.AttributeName = d.AttributeName
 where d.BatchID is null

set @cnt = @@ROWCOUNT
if (@debug = 1)
begin
   SET @msg =  'Inserted B:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

--bc persist
update d
   set
       d.ProcessID = t.ProcessID
      ,d.ConstOrder = t.ConstOrder
      ,d.WaitPeriod = t.WaitPeriod
  from dbo.[ETLBatchConstraint] d
  join #bc t on d.BatchID = t.BatchID and d.ConstID = t.ConstID

set @cnt = @@ROWCOUNT
if (@debug = 1)
begin
   SET @msg =  'Updated BC:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

--set identity_insert dbo.[ETLBatchConstraint] on
insert dbo.[ETLBatchConstraint]
    (BatchID,ConstID,ProcessID,ConstOrder,WaitPeriod)
select
       t.BatchID
      ,t.ConstID
      ,t.ProcessID
      ,t.ConstOrder
      ,t.WaitPeriod
  from #bc t
  left join dbo.[ETLBatchConstraint] d on t.BatchID = d.BatchID and d.ConstID = t.ConstID
 where d.BatchID is null
set @cnt = @@ROWCOUNT
--set identity_insert dbo.[ETLBatchConstraint] off

if (@debug = 1)
begin
   SET @msg =  'Inserted BC:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

--bca persist
update d
   set
       d.AttributeValue = t.AttributeValue
  from dbo.[ETLBatchConstraintAttribute] d
  join #bca t on t.BatchID = d.BatchID and t.ConstID = d.ConstID and t.AttributeName = d.AttributeName

set @cnt = @@ROWCOUNT
if (@debug = 1)
begin
   SET @msg =  'Updated BCA:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

insert dbo.[ETLBatchConstraintAttribute]
    (BatchID,ConstID,AttributeName,AttributeValue)
select
       t.BatchID
      ,t.ConstID
      ,t.AttributeName
      ,t.AttributeValue
  from #bca t
  left join dbo.[ETLBatchConstraintAttribute] d on t.BatchID = d.BatchID and t.ConstID = d.ConstID and t.AttributeName = d.AttributeName
 where d.BatchID is null

set @cnt = @@ROWCOUNT
if (@debug = 1)
begin
   SET @msg =  'Inserted BCA:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

--s persist
update d
   set
       d.StepName = t.StepName
      ,d.StepDesc = t.StepDesc
      ,d.StepProcID = t.StepProcID
      ,d.OnSuccessID = t.OnSuccessID
      ,d.OnFailureID = t.OnFailureID
      ,d.IgnoreErr = t.IgnoreErr
      ,d.StepOrder = t.StepOrder
  from dbo.[ETLStep] d
  join #s t on d.BatchID = t.BatchID and t.StepID = d.StepID

set @cnt = @@ROWCOUNT
if (@debug = 1)
begin
   SET @msg =  'Updated S:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

--set identity_insert dbo.[ETLStep] on
insert dbo.[ETLStep]
    (BatchID,StepID,StepName,StepDesc,StepProcID,OnSuccessID,OnFailureID,IgnoreErr,StepOrder)
select
       t.BatchID
      ,t.StepID
      ,t.StepName
      ,t.StepDesc
      ,t.StepProcID
      ,t.OnSuccessID
      ,t.OnFailureID
      ,t.IgnoreErr
      ,t.StepOrder
  from #s t
  left join dbo.[ETLStep] d on t.BatchID = d.BatchID
 where d.BatchID is null

set @cnt = @@ROWCOUNT
--set identity_insert dbo.[ETLStep] off

if (@debug = 1)
begin
   SET @msg =  'Inserted S:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

--sa persist
update d
   set
       d.AttributeValue = t.AttributeValue
  from dbo.[ETLStepAttribute] d
  join #sa t on d.BatchID = t.BatchID and d.StepID = t.StepID and d.AttributeName = t.AttributeName

set @cnt = @@ROWCOUNT
if (@debug = 1)
begin
   SET @msg =  'Updated SA:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

insert dbo.[ETLStepAttribute]
    (BatchID,StepID,AttributeName,AttributeValue)
select
       t.BatchID
      ,t.StepID
      ,t.AttributeName
      ,t.AttributeValue
  from #sa t
  left join dbo.[ETLStepAttribute] d on t.BatchID = d.BatchID and d.StepID = t.StepID and t.AttributeName = d.AttributeName
 where d.BatchID is null

set @cnt = @@ROWCOUNT
if (@debug = 1)
begin
   SET @msg =  'Inserted SA:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

--sc persist
update d
   set
       d.ProcessID = t.ProcessID
      ,d.ConstOrder = t.ConstOrder
      ,d.WaitPeriod = t.WaitPeriod
  from dbo.[ETLStepConstraint] d
  join #sc t on d.BatchID = t.BatchID and d.StepID = t.StepID and d.ConstID = t.ConstID

set @cnt = @@ROWCOUNT
if (@debug = 1)
begin
   SET @msg =  'Updated SC:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

--set identity_insert dbo.[ETLStepConstraint] on
insert dbo.[ETLStepConstraint]
    (BatchID,StepID,ConstID,ProcessID,ConstOrder,WaitPeriod)
select
       t.BatchID
      ,t.StepID
      ,t.ConstID
      ,t.ProcessID
      ,t.ConstOrder
      ,t.WaitPeriod
  from #sc t
  left join dbo.[ETLStepConstraint] d on t.BatchID = d.BatchID and d.StepID = t.StepID and d.ConstID = t.ConstID
 where d.BatchID is null

set @cnt = @@ROWCOUNT
--set identity_insert dbo.[ETLStepConstraint] off

if (@debug = 1)
begin
   SET @msg =  'Inserted SC:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

--sca persist
update d
   set
       d.AttributeValue = t.AttributeValue
  from dbo.[ETLStepConstraintAttribute] d
  join #sca t on t.BatchID = d.BatchID and d.StepID = t.StepID and t.ConstID = d.ConstID and t.AttributeName = d.AttributeName

set @cnt = @@ROWCOUNT
if (@debug = 1)
begin
   SET @msg =  'Updated SCA:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

insert dbo.[ETLStepConstraintAttribute]
    (BatchID,StepID,ConstID,AttributeName,AttributeValue)
select
       t.BatchID
      ,t.StepID
      ,t.ConstID
      ,t.AttributeName
      ,t.AttributeValue
  from #sca t
  left join dbo.[ETLStepConstraintAttribute] d on t.BatchID = d.BatchID and d.StepID = t.StepID and t.ConstID = d.ConstID and t.AttributeName = d.AttributeName
 where d.BatchID is null

set @cnt = @@ROWCOUNT
if (@debug = 1)
begin
   SET @msg =  'Inserted CSA:' + cast(@cnt as nvarchar(10)) + ' rows'
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
end

COMMIT TRAN

IF (@debug = 1)
BEGIN
   SET @msg = 'END Procedure ' + @ProcName
   exec @ProcErr = dbo.prc_CreateProcessInfo @ProcessInfo out,@Header,@msg
   exec @ProcErr = dbo.[prc_Print] @ProcessInfo,@pHandle
END

end try
begin catch
   if @Trancount < @@trancount
      ROLLBACK TRAN

   set @msg = ERROR_MESSAGE()
   set @Err = ERROR_NUMBER()
   raiserror (@msg,11,11)
end catch

RETURN @Err
GO
/*
Post-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/

--:r .\Environment.sql
--:r .\Misc\PopulateWFRunnerImportProcess.sql
--:r .\Misc\PopulateLegacyImportProcess.sql
--:r .\Misc\ETLMonitorPermissions.sql
--:r .\Workflows\Test.sql
--:r .\Workflows\Call_BCP.sql
--:r .\Workflows\Call_Powershell.sql
--:r .\Workflows\Call_SP.sql
--:r .\Workflows\FileCheck.sql
--:r .\Workflows\IncrementalStaging.sql
--:r .\Workflows\MoveData_Excel.sql
--:r .\Workflows\MoveData_TableToFile.sql
--:r .\Workflows\MoveData_TableToTable.sql
--:r .\Workflows\Process1.sql
--:r .\Workflows\Process2.sql
--:r .\Workflows\QueryType_MDX.sql
--:r .\Workflows\SeqGroup.sql
--:r .\Workflows\Step_WaitConstraint_Met.sql
--:r .\Workflows\Loop.sql




GO

GO
DECLARE @VarDecimalSupported AS BIT;

SELECT @VarDecimalSupported = 0;

IF ((ServerProperty(N'EngineEdition') = 3)
    AND (((@@microsoftversion / power(2, 24) = 9)
          AND (@@microsoftversion & 0xffff >= 3024))
         OR ((@@microsoftversion / power(2, 24) = 10)
             AND (@@microsoftversion & 0xffff >= 1600))))
    SELECT @VarDecimalSupported = 1;

IF (@VarDecimalSupported > 0)
    BEGIN
        EXECUTE sp_db_vardecimal_storage_format N'$(DatabaseName)', 'ON';
    END


GO
PRINT N'Update complete.';


GO
